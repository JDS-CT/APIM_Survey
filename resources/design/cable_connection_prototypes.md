# Cable Connection Prototypes

## Goals
- Allow survey participants to draw and validate service cables/lines between equipment in the 2D survey and first-person (FPV) walkthrough.
- Support click-to-connect interactions that snap cable endpoints to registered sockets on asset bounding boxes without requiring precise mesh-level data.
- Keep the design modular so additional cable types, connection points, or routing heuristics can be layered in during later iterations.

## Shared Interaction Foundations
- **Socket registry:** Each placeable asset exposes a handful of logical sockets (power, air, vacuum, etc.) defined as offsets on its axis-aligned bounding box (AABB). Endpoints use normalized coordinates `(u, v, w)` in the range `[0, 1]` so the same metadata works in both 2D and 3D once multiplied by the asset's width/height/depth.
- **Endpoint picking:** When a user hovers near a socket, the UI highlights the target and previews the allowable cable types. Clicking establishes a start anchor; the next valid socket click completes the connection.
- **Length limits:** Cable instances store their measured path length in millimeters. Validation warns when a run exceeds the configured maximum length for the cable type (default 10 ft / 3 m, overridable per cable type).
- **Shared persistence:** Layout snapshots include cable instances as records referencing `sourceSocketId`, `targetSocketId`, `cableType`, and optional manual bend points. Both prototypes consume the same data model.

## Prototype A — Draggable Bézier Splines

### Overview
A lightweight interaction that renders cables as quadratic or cubic Bézier curves. Users can drag intermediate control handles to refine the route when avoiding obstacles. This builds on existing SVG in the 2D survey and Three.js line rendering in FPV mode.

### Key Mechanics
1. **Creation:** After selecting a cable type, click a source socket, then a destination socket. A default S-curve is generated by offsetting control points away from the sockets based on the vector between them and a configurable slack ratio.
2. **Editing:** Expose control handles (two for cubic Bézier) that can be dragged in 2D. In FPV mode, show gizmos in the overhead mini-map or project them into 3D using TransformControls for precision adjustments.
3. **Bend point support:** Allow users to insert additional bend points that become new control points, re-splitting the curve into chained cubic segments when routing around obstacles.
4. **Length calculation:** Sample the curve (e.g., 32 segments) to approximate total length. Update warnings live as handles move.
5. **Snapping:** Control handles optionally snap to the room grid when near walls/floor intersections to keep runs tidy.

### Connection Point Registration
- Bounding boxes expose sockets using metadata: `[{ id, label, surface, anchor: { u, v, w }, allowedCableTypes: [] }]`.
- During placement, convert `anchor` into world coordinates by scaling `u`, `v`, `w` with the asset's dimensions and applying its transform. Because sockets may sit on walls or ceilings, `surface` hints whether to project the point to the floor, ceiling, or wall plane.

### Implementation Steps
1. Extend the layout store to include a `cables` array with the shared schema (see Metadata section).
2. 2D Survey: render cables on a dedicated SVG layer using `<path>` with cubic Bézier curves; reuse the drag infrastructure from wall sockets for control handles.
3. FPV: use `THREE.CatmullRomCurve3` or manual cubic curve sampling to draw a `TubeGeometry` with a thin radius, updating geometry when control points move.
4. Provide UI affordances for selecting cables (hover highlight, delete, duplicate).
5. Persist manual bend points as normalized offsets so cables remain valid if the room scales.

### Pros & Risks
- ✅ Quick to implement with existing rendering primitives.
- ✅ Easy to author tidy manual routes.
- ⚠️ Users must manage obstacle avoidance themselves.
- ⚠️ Requires careful UX to keep handle manipulation approachable in FPV mode.

## Prototype B — Physics-Guided Cable Simulation

### Overview
Simulates cables as semi-rigid ropes driven by a lightweight physics solver. Users define endpoints; the system relaxes the rope while respecting maximum length and gravity, biasing the path to drape naturally and avoid collisions.

### Key Mechanics
1. **Underlying model:** Represent the cable as a chain of mass nodes connected by distance constraints (Verlet integration). Add bending stiffness to keep loops smooth.
2. **Obstacle avoidance:** Cast collision segments against room meshes (walls, floor, placed assets). When penetration is detected, push nodes outward along the surface normal; optionally introduce repulsion zones around assets to encourage clearance.
3. **User control:** Allow manual pinning of intermediate nodes to create intentional service loops. Users can drag these pins; the solver re-relaxes remaining segments.
4. **Length enforcement:** Clamp the total rest length to the cable's maximum. If endpoints move farther apart than allowed, surface a warning and color the cable red.
5. **Cross-view sync:** The 2D survey shows the relaxed path projected onto the floor plane, while FPV renders the 3D rope geometry with subtle animation to convey weight.

### Connection Point Registration
- Socket metadata includes an optional `tetherDirection` hint (`'floor' | 'ceiling' | 'wall' | 'free'`) so the solver can seed initial node positions (e.g., drop toward the floor before running horizontally).
- Each cable endpoint remains locked to the world position derived from the socket metadata; node positions update per frame to respect asset motion.

### Implementation Steps
1. Integrate a lightweight rope solver (custom or based on an MIT-licensed library) that can run at 60 Hz in the FPV render loop; expose a downsampled approximation for the 2D SVG view.
2. Build a background worker to recompute relaxed paths when assets move in 2D, preventing UI stalls.
3. Persist user-defined pins and solver configuration (gravity, stiffness) alongside each cable instance.
4. Add visual indicators for tension (color ramp) and length overruns (status HUD updates).

### Pros & Risks
- ✅ Produces realistic draped cables with minimal manual tweaking.
- ✅ Naturally avoids intersections when tuned correctly.
- ⚠️ Higher implementation complexity and performance considerations, especially on lower-end hardware.
- ⚠️ Requires careful synchronization between worker updates and Three.js scene graph.

## Metadata Schema Updates for Cable-Aware Assets

### Asset Catalog Extensions
Add a shared JSON (e.g., `resources/layout_samples/catalog.json`) consumed by both the 2D survey and FPV demo.

```json
{
  "cableTypes": {
    "power": { "label": "Power", "maxLength_mm": 3048 },
    "air": { "label": "Compressed Air", "maxLength_mm": 3048 },
    "n2": { "label": "Nitrogen", "maxLength_mm": 3048 },
    "vacuum": { "label": "Vacuum", "maxLength_mm": 3048 },
    "water": { "label": "Water", "maxLength_mm": 3048 },
    "ethernet": { "label": "Ethernet", "maxLength_mm": 3048 },
    "ground": { "label": "Ground", "maxLength_mm": 3048 }
  },
  "assets": {
    "microscope": {
      "boundingBox_mm": { "w": 2200, "l": 1800, "h": 2200 },
      "connectionSockets": [
        {
          "id": "microscope_power",
          "label": "Microscope Power",
          "anchor": { "u": 0.1, "v": 0.2, "w": 0.5 },
          "surface": "floor",
          "allowedCableTypes": ["power", "ground"]
        },
        {
          "id": "microscope_vacuum",
          "label": "Vacuum Input",
          "anchor": { "u": 0.9, "v": 0.2, "w": 0.5 },
          "surface": "floor",
          "allowedCableTypes": ["vacuum"]
        }
      ]
    },
    "wall_socket": {
      "boundingBox_mm": { "w": 400, "l": 120, "h": 600 },
      "connectionSockets": [
        {
          "id": "wall_outlet_duplex",
          "label": "Duplex Outlet",
          "anchor": { "u": 0.5, "v": 0.5, "w": 0.5 },
          "surface": "wall",
          "allowedCableTypes": ["power", "ground"]
        }
      ]
    }
  }
}
```

### Layout Snapshot Additions
Persist cables alongside existing `floor_items` and `wall_items`:

```json
{
  "cables": [
    {
      "id": "cable_001",
      "cableType": "power",
      "source": { "assetId": "microscope_1", "socketId": "microscope_power" },
      "target": { "assetId": "wall_socket_3", "socketId": "wall_outlet_duplex" },
      "controlPoints": [
        { "u": 0.3, "v": 0, "w": 0.5 },
        { "u": 0.7, "v": 0, "w": 0.5 }
      ],
      "pins": [],
      "length_mm": 2950,
      "status": "within_limit"
    }
  ]
}
```

- `controlPoints` store normalized offsets relative to the straight line between sockets (Bézier prototype) or solver pins (physics prototype). Empty arrays indicate fully automatic routing.
- `pins` is optional metadata used only by the physics prototype; leave empty for simple splines.
- `status` caches the last validation state to drive UI chips without recomputing on every render.

### Validation Rules
- Ensure both endpoints reference sockets that include the chosen `cableType` in `allowedCableTypes`.
- When loading a layout, drop cables referencing missing assets or sockets and surface a warning banner.
- During editing, disable socket selections that would exceed their per-socket capacity if we later add `maxConnections`.

## Implementation Checklist
- [ ] Parse the shared catalog metadata on both the 2D survey and FPV loaders.
- [ ] Expose socket hover/selection affordances in both views.
- [ ] Stand up the Bézier spline renderer and persistence wiring (Prototype A baseline).
- [ ] Evaluate performance envelope for the physics solver; if risky, keep Prototype B as an opt-in lab feature behind a flag.
- [ ] Extend regression tests to ensure layouts with cables serialize/deserialize without loss.
