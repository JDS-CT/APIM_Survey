<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive 3D Room — First-Person Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../shared/styles/glass_light_theme.css" />
  <link rel="stylesheet" href="../shared/styles/glass_dark_theme.css" />
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: 100vh;
      background: var(--room-ui-bg);
      color: var(--room-ui-text);
      position: relative;
      overflow-x: hidden;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 18% 18%, rgba(96, 165, 250, 0.2), transparent 45%),
                  radial-gradient(circle at 82% 12%, rgba(129, 140, 248, 0.24), transparent 52%);
      opacity: 0.82;
      pointer-events: none;
      z-index: -2;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      gap: 16px;
      border-bottom: 1px solid var(--room-ui-border);
      background: var(--room-ui-surface);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header nav {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    header .subtitle {
      font-size: 13px;
      color: var(--room-ui-muted-strong);
      margin-top: 2px;
    }
    .nav-link {
      color: var(--room-ui-link);
      text-decoration: none;
      font-weight: 600;
      padding: 6px 10px;
      border-radius: 6px;
      transition: background 120ms ease, color 120ms ease;
    }
    .nav-link:hover {
      background: rgba(37, 99, 235, 0.12);
    }
    .nav-link.active {
      background: rgba(37, 99, 235, 0.18);
    }
    main {
      display: grid;
      grid-template-columns: minmax(260px, 340px) 1fr;
      min-height: 0;
      position: relative;
      z-index: 0;
    }
    aside {
      padding: 16px;
      display: grid;
      gap: 16px;
      align-content: start;
      border-right: 1px solid var(--room-ui-border-soft);
      background: var(--room-ui-surface);
    }
    aside h2 {
      margin: 0;
      font-size: 18px;
    }
    aside p {
      margin: 0;
      color: var(--room-ui-muted-strong);
      font-size: 14px;
      line-height: 1.5;
    }
    aside .controls {
      display: grid;
      gap: 8px;
    }
    .controls .control-status {
      font-size: 13px;
      color: var(--room-ui-muted);
      margin: 4px 0 0;
      min-height: 1.2em;
    }
    .controls .asset-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .controls .control-status[data-tone="warn"] {
      color: #facc15;
    }
    .controls .control-status[data-tone="success"] {
      color: #34d399;
    }
    label {
      display: grid;
      gap: 6px;
      font-weight: 600;
      font-size: 14px;
    }
    input[type="file"] {
      font: inherit;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      appearance: none;
      font: inherit;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid var(--room-ui-button-border);
      background: linear-gradient(180deg, var(--room-ui-button-bg-top), var(--room-ui-button-bg-bottom));
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px var(--room-ui-shadow);
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .controls .slider-value {
      font-weight: 600;
    }
    .viewport {
      position: relative;
      background: radial-gradient(circle at top, var(--room-ui-viewport-radial), transparent 55%), var(--room-ui-viewport-bg);
      display: flex;
      align-items: stretch;
      justify-content: center;
      min-height: 0;
    }
    #rendererHost {
      flex: 1 1 auto;
      position: relative;
    }
    #rendererHost canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      transition: opacity 160ms ease;
    }
    .overlay.hidden {
      opacity: 0;
    }
    .overlay .card {
      pointer-events: auto;
      background: var(--room-ui-overlay-bg);
      color: var(--room-ui-overlay-text);
      padding: 18px 20px;
      border-radius: 12px;
      max-width: 320px;
      text-align: center;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 40px var(--room-ui-overlay-shadow);
    }
    .overlay h3 {
      margin: 0 0 8px;
      font-size: 18px;
    }
    .overlay p {
      margin: 0;
      font-size: 14px;
      line-height: 1.5;
    }
    .info-box {
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--room-ui-info-border);
      background: var(--room-ui-info-bg);
      font-size: 13px;
      line-height: 1.5;
      color: var(--room-ui-muted-strong);
    }
    .info-box ul {
      margin: 8px 0 0;
      padding-left: 18px;
    }
    .info-box li {
      margin: 4px 0;
    }
    .legend {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--room-ui-legend-text);
    }
    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(15,23,42,0.2);
    }
  </style>
</head>
<body data-room-theme="glass-dark">
  <header>
    <div>
      <strong>3D Room Viewer — First-Person Prototype</strong>
      <div class="subtitle">Walk inside the imported room layout, experiment with the FreeCAD <em>dozenSidedStack</em> sample, and preview placement in 3D.</div>
    </div>
    <nav>
      <a class="nav-link" href="../index.html">Home</a>
      <a class="nav-link" href="../room_survey_min/room_survey_min_v1.html">2D Survey</a>
      <a class="nav-link active" href="interactive_3d_room_fps_demo.html">First-Person Demo</a>
    </nav>
  </header>
  <main>
    <aside>
      <div>
        <h2>Workflow</h2>
        <p>Import the JSON exported from the 2D survey, then use first-person controls to explore. The FreeCAD <em>dozenSidedStack</em> sample is included to prove we can load GLTF assets.</p>
      </div>
      <div class="controls">
        <label>Import 2D Layout JSON
          <input id="layoutImport" type="file" accept="application/json" />
        </label>
        <button id="resetLayout">Reset to Default Room</button>
        <button id="load-gltf">Load Sample GLTF Asset</button>
        <div class="asset-actions">
          <button id="focusAsset" disabled>Frame Loaded Asset</button>
          <button id="resetAssetView" disabled>Reset View to Asset</button>
        </div>
        <p class="control-status" id="assetStatus" aria-live="polite"></p>
      </div>
      <div class="controls">
        <label for="translationSnap">Translation Snap Increment
          <input id="translationSnap" type="range" min="1" max="50" step="1" value="5" />
        </label>
        <p class="control-status" id="translationSnapHint">Hand Mode nudges &amp; gizmo moves use <span class="slider-value" id="translationSnapValue">5&nbsp;cm</span> steps.</p>
      </div>
      <div class="controls">
        <button id="enter-walk">Enter Walk Mode</button>
        <button id="resetWalk">Reset Walk Position</button>
        <p class="control-status" id="walkStatus" aria-live="polite"></p>
      </div>
      <div class="info-box" id="roomInfo"></div>
      <div class="info-box">
        <strong>Controls</strong>
        <ul>
          <li>Click <strong>Enter Walk Mode</strong> to lock the pointer, then use <strong>WASD</strong>, the mouse, <strong>Space</strong> to fly up, and <strong>Shift</strong> to fly down.</li>
          <li>Press <strong>Ctrl</strong> to toggle <strong>Hand Mode</strong>: movement pauses so you can drag gizmos or tap <strong>WASD</strong>/<strong>Space</strong>/<strong>Shift</strong>/<strong>Q</strong>/<strong>E</strong> to nudge or rotate the selected object.</li>
          <li>Hold <strong>Alt</strong> and drag in the viewport (while not walking) to orbit the camera and frame the room before entering.</li>
          <li>Select the sample asset to reveal the move gizmo, then drag the arrows to reposition it anywhere in the room.</li>
        </ul>
      </div>
      <div class="legend">
        <span><span class="swatch" style="background:var(--room-ui-legend-wall)"></span> Walls (default thickness 200&nbsp;mm)</span>
        <span><span class="swatch" style="background:var(--room-ui-legend-custom)"></span> Custom walls</span>
        <span><span class="swatch" style="background:var(--room-ui-legend-door)"></span> Doors (2.1&nbsp;m tall)</span>
        <span><span class="swatch" style="background:var(--room-ui-legend-floor)"></span> Floor items from survey</span>
        <span><span class="swatch" style="background:var(--room-ui-legend-asset)"></span> Loaded GLTF asset</span>
      </div>
    </aside>
    <section class="viewport">
      <div id="rendererHost"></div>
      <div class="overlay" id="walkOverlay">
        <div class="card">
          <h3>Click “Enter Walk Mode”</h3>
          <p>Use <strong>WASD</strong> to move, <strong>mouse</strong> to look, <strong>Space</strong> to rise, and <strong>Shift</strong> to descend. Press <strong>Ctrl</strong> for Hand Mode when you want to adjust objects, and <strong>Alt</strong>+drag (while idle) to orbit.</p>
        </div>
      </div>
    </section>
  </main>

  <script src="../shared/scripts/cable_catalog_defaults.js"></script>
  <script type="module">
    import * as THREE from '../shared/vendor/three/three.module.js';
    import { PointerLockControls } from '../shared/vendor/three/PointerLockControls.js';
    import { TransformControls } from '../shared/vendor/three/TransformControls.js';
    import { GLTFLoader } from '../shared/vendor/three/GLTFLoader.js';
    import { createMovementController } from './fpv_movement_controller.js';

    const mm2m = value => value / 1000;
    const m2mm = value => value * 1000;
    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const toNumber = (value, fallback = 0) => {
      const num = Number(value);
      return Number.isFinite(num) ? num : fallback;
    };

    const ROOM_HEIGHT_MM = 3000; // align with survey default (3 m)
    const DEFAULT_WALL_MOUNT_HEIGHT_MM = 1200;
    const CABLE_LATERAL_SLACK_RATIO = 0.25;
    const CABLE_SAG_RATIO = 0.3;
    const CABLE_SAG_MIN_MM = 150;
    const CABLE_SAG_MAX_MM = 1200;
    const HUMAN_EYE_HEIGHT_M = 1.62; // ~5'4" eye level for first-person scale cues
    const WALK_SPEED_MPS = 3.5;
    const MOVEMENT_DAMPING = 10;
    const DEFAULT_WALL_THICKNESS_MM = 200;
    const DOOR_DEFAULT_THICKNESS_MM = 80;
    const DOOR_HEIGHT_MM = 2100;
    const DOOR_VISUAL_EXTRA_THICKNESS_MM = 20;
    const DOOR_INTERIOR_CLEARANCE_MM = 8;
    const WALL_ITEM_DEFAULT_SIZE_MM = { width: 400, height: 600, depth: 120 };
    const WALL_ITEM_EXTRA_DEPTH_MM = 10;
    const WALL_ITEM_SURFACE_CLEARANCE_MM = 6;

    const ASSET_FLOOR_ITEM_TYPE = 'gltfAsset';
    const SAMPLE_ASSET_REF = 'sample/dozenSidedStack';
    const SAMPLE_ASSET_ID = 'asset_sample';

    const FLOOR_ITEM_META = {
      floorBox: { label: 'Floor Box', wmm: 600, lmm: 600, color: 0x2e6fba, height: 0.5 },
      microscope: { label: 'Microscope', wmm: 2200, lmm: 1800, color: 0x8c5dd8, height: 2.0 },
      table: { label: 'Table', wmm: 1800, lmm: 900, color: 0x3956b5, height: 0.9 },
      pump: { label: 'Pump', wmm: 1200, lmm: 600, color: 0xeb7127, height: 0.8 },
      chiller: { label: 'Chiller', wmm: 1200, lmm: 800, color: 0x1d4ed8, height: 1.4 },
      n2_bottle: { label: 'N2 Bottle', wmm: 450, lmm: 450, color: 0x14532d, height: 1.45, kind: 'cylinder' },
      bottled_air_line: { label: 'Bottled Air Line', wmm: 600, lmm: 600, color: 0xf97316, height: 1.1 },
      table_resizable: { label: 'Resizable Table', wmm: 2000, lmm: 1000, color: 0x2563eb, height: 0.9 },
      thermostat_ceiling: {
        label: 'Ceiling Thermostat',
        wmm: 240,
        lmm: 240,
        color: 0xfdba74,
        height: 0.35,
        heightMm: 120,
        dropMm: 350,
        kind: 'ceilingThermostat'
      },
      [ASSET_FLOOR_ITEM_TYPE]: { label: 'GLTF Asset', wmm: 2000, lmm: 2000, color: 0x8b5cf6, height: 0.2 }
    };

    const ALL_CATALOG_TYPES = window.DEFAULT_CABLE_CATALOG && window.DEFAULT_CABLE_CATALOG.cableTypes
      ? Object.keys(window.DEFAULT_CABLE_CATALOG.cableTypes)
      : ['power', 'ground', 'air', 'n2', 'vacuum', 'water', 'ethernet'];

    const WALL_ITEM_META = {
      socket: {
        label: 'Wall Socket',
        assetKey: 'wall_socket',
        defaultDepthMm: 300,
        color: 0xf9a825,
        mountHeightMm: 1200,
        sizeMm: { ...WALL_ITEM_DEFAULT_SIZE_MM },
        fallbackSockets: [
          {
            id: 'wall_outlet_duplex',
            label: 'Duplex Outlet',
            anchor: { u: 0.5, v: 0.5, w: 0.5 },
            allowedCableTypes: ['power', 'ground'],
            surface: 'wall',
            offsetDirection: 1
          }
        ]
      },
      gas_socket: {
        label: 'Gas Socket',
        assetKey: 'wall_gas_socket',
        defaultDepthMm: 300,
        color: 0x22c55e,
        mountHeightMm: 1400,
        sizeMm: { ...WALL_ITEM_DEFAULT_SIZE_MM },
        fallbackSockets: [
          {
            id: 'wall_gas_outlet',
            label: 'Gas Outlet',
            anchor: { u: 0.5, v: 0.5, w: 0.5 },
            allowedCableTypes: ['air', 'n2', 'vacuum'],
            surface: 'wall',
            offsetDirection: 1
          }
        ]
      },
      feedthrough: {
        label: 'Feedthrough',
        assetKey: 'wall_feedthrough',
        defaultDepthMm: 200,
        color: 0x0ea5e9,
        mountHeightMm: 1300,
        sizeMm: { ...WALL_ITEM_DEFAULT_SIZE_MM },
        fallbackSockets: [
          {
            id: 'feedthrough_room',
            label: 'Feedthrough (Room Side)',
            anchor: { u: 0.5, v: 0.5, w: 0.5 },
            allowedCableTypes: ALL_CATALOG_TYPES,
            surface: 'wall',
            offsetDirection: 1
          },
          {
            id: 'feedthrough_service',
            label: 'Feedthrough (Service Side)',
            anchor: { u: 0.5, v: 0.5, w: 0.5 },
            allowedCableTypes: ALL_CATALOG_TYPES,
            surface: 'wall',
            offsetDirection: -1
          }
        ]
      },
      wall_air_barb: {
        label: 'Wall Air Barb',
        assetKey: 'wall_air_barb',
        defaultDepthMm: 260,
        color: 0x38bdf8,
        mountHeightMm: 1500,
        sizeMm: { ...WALL_ITEM_DEFAULT_SIZE_MM, depth: 90, width: 260, height: 220 },
        fallbackSockets: [
          {
            id: 'wall_air_barb',
            label: 'Air Barb',
            anchor: { u: 0.5, v: 0.5, w: 0.5 },
            allowedCableTypes: ['air'],
            surface: 'wall',
            offsetDirection: 1
          }
        ]
      },
      thermostat_wall: {
        label: 'Wall Thermostat',
        assetKey: 'thermostat_wall',
        defaultDepthMm: 120,
        color: 0xf59e0b,
        mountHeightMm: 1500,
        sizeMm: { ...WALL_ITEM_DEFAULT_SIZE_MM, depth: 80, width: 180, height: 220 },
        fallbackSockets: [
          {
            id: 'thermostat_power',
            label: 'Thermostat Power',
            anchor: { u: 0.5, v: 0.5, w: 0.6 },
            allowedCableTypes: ['power'],
            surface: 'wall',
            offsetDirection: 1
          },
          {
            id: 'thermostat_data',
            label: 'Thermostat Data',
            anchor: { u: 0.5, v: 0.5, w: 0.3 },
            allowedCableTypes: ['ethernet'],
            surface: 'wall',
            offsetDirection: 1
          }
        ]
      }
    };

    const CABLE_CATALOG_URL = '../resources/layout_samples/catalog.json';
    const FALLBACK_CABLE_COLORS = (function () {
      if (!window.DEFAULT_CABLE_CATALOG || !window.DEFAULT_CABLE_CATALOG.cableTypes) {
        return {};
      }
      return Object.fromEntries(
        Object.entries(window.DEFAULT_CABLE_CATALOG.cableTypes).map(([key, def]) => [
          key,
          def && def.color ? def.color : '#94a3b8'
        ])
      );
    })();
    const DEFAULT_CABLE_RADIUS_M = 0.025;
    const CABLE_SAMPLE_SEGMENTS = 48;

    const HAND_MODE_TOGGLE_KEY = 'Control';
    const HAND_MODE_ROTATE_STEP = THREE.MathUtils.degToRad(5);
    const WALK_OVERLAY_AUTO_HIDE_MS = 1800;
    const MIN_TRANSLATION_SNAP = 0.01;
    const MAX_TRANSLATION_SNAP = 0.5;
    const DEFAULT_TRANSLATION_SNAP = 0.05;
    let translationSnap = DEFAULT_TRANSLATION_SNAP;
    let handModeTranslateStep = DEFAULT_TRANSLATION_SNAP;
    let handModeVerticalStep = DEFAULT_TRANSLATION_SNAP;

    const DEFAULT_ROOM_PRESET = () => ({
      room: { W: 6000, L: 8000 },
      floor_items: [
        { id: 'floor_1', type: 'microscope', x: 2200, y: 5200, rotation: 0 },
        { id: 'floor_2', type: 'table', x: 3800, y: 5200, rotation: 0 },
        { id: 'floor_3', type: 'pump', x: 4200, y: 3400, rotation: 0 },
        { id: 'floor_4', type: 'floorBox', x: 3000, y: 3600, rotation: 0 }
      ],
      wall_items: [
        { id: 'socket_5', type: 'socket', wall: 'base:1', s: 1500, h: 300 },
        { id: 'socket_6', type: 'socket', wall: 'base:3', s: 4500, h: 300 }
      ],
      custom_walls: [],
      doors: [],
      cables: [
        {
          id: 'cable_7',
          cableType: 'power',
          source: { kind: 'floor', assetId: 'floor_1', socketId: 'microscope_power' },
          target: { kind: 'wall', assetId: 'socket_5', socketId: 'wall_outlet_duplex' }
        }
      ]
    });

    const layout = {
      room: { Wmm: 6000, Lmm: 8000 },
      floor_items: [],
      wall_items: [],
      custom_walls: [],
      doors: [],
      cables: []
    };

    const LAYOUT_STORAGE_KEY = 'apim-room.latest-layout';

    const rendererHost = document.getElementById('rendererHost');
    const walkOverlay = document.getElementById('walkOverlay');
    const enterWalkBtn = document.getElementById('enter-walk');
    const resetWalkBtn = document.getElementById('resetWalk');
    const layoutImport = document.getElementById('layoutImport');
    const resetLayoutBtn = document.getElementById('resetLayout');
    const loadGltfBtn = document.getElementById('load-gltf');
    const focusAssetBtn = document.getElementById('focusAsset');
    const resetAssetViewBtn = document.getElementById('resetAssetView');
    const assetStatus = document.getElementById('assetStatus');
    const roomInfo = document.getElementById('roomInfo');
    const walkStatus = document.getElementById('walkStatus');
    const translationSnapInput = document.getElementById('translationSnap');
    const translationSnapValue = document.getElementById('translationSnapValue');
    const viewportSection = document.querySelector('.viewport');
    const NAVIGATION_KEYS = new Set(['Space', 'ShiftLeft', 'ShiftRight']);
    const INTERACTIVE_TAGS = new Set(['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON']);

    let handMode = false;
    document.body.dataset.handMode = 'off';
    let walkOverlayHideTimer = null;
    let viewportInteracting = false;
    let cableCatalogData = null;

    const supportsPointerLock = typeof document !== 'undefined' && 'pointerLockElement' in document;
    const POINTER_LOCK_UNSUPPORTED_MESSAGE = 'Pointer lock is unavailable in this browser. Try a desktop Chromium or Firefox build.';

    function resolveThemeColor(variable, fallback) {
      const styles = getComputedStyle(document.body);
      const value = styles.getPropertyValue(variable);
      return value ? value.trim() : fallback;
    }

    const scene = new THREE.Scene();
    let sceneBgColor = resolveThemeColor('--room-ui-bg', '#0b1120');
    try {
      scene.background = new THREE.Color(sceneBgColor);
    } catch (err) {
      console.warn('Failed to apply theme background color, falling back to default.', err);
      scene.background = new THREE.Color('#0b1120');
    }

    const camera = new THREE.PerspectiveCamera(65, 1, 0.1, 100);
    camera.position.set(0, HUMAN_EYE_HEIGHT_M, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = false;
    renderer.setClearColor(scene.background);
    rendererHost.appendChild(renderer.domElement);
    renderer.domElement.tabIndex = -1;

    const pointerControls = new PointerLockControls(camera, renderer.domElement);
    const transformControls = new TransformControls(camera, renderer.domElement);
    transformControls.setMode('translate');
    transformControls.showY = true;
    transformControls.setTranslationSnap(translationSnap);
    scene.add(transformControls);
    scene.add(pointerControls.getObject());

    const ambient = new THREE.AmbientLight(0xf2f5ff, 0.8);
    scene.add(ambient);
    const keyLight = new THREE.DirectionalLight(0xffffff, 0.65);
    keyLight.position.set(4, 6, 3);
    scene.add(keyLight);
    const fillLight = new THREE.DirectionalLight(0xcad6ff, 0.25);
    fillLight.position.set(-5, 3, -2);
    scene.add(fillLight);

    const floorGroup = new THREE.Group();
    const wallGroup = new THREE.Group();
    const doorGroup = new THREE.Group();
    const wallItemGroup = new THREE.Group();
    const itemGroup = new THREE.Group();
    const cableGroup = new THREE.Group();
    const scaleMarkerGroup = new THREE.Group();
    const assetAnchor = new THREE.Group();
    assetAnchor.visible = false;
    assetAnchor.name = 'SampleAssetAnchor';
    scene.add(floorGroup);
    scene.add(wallGroup);
    scene.add(doorGroup);
    scene.add(wallItemGroup);
    scene.add(itemGroup);
    scene.add(cableGroup);
    scene.add(scaleMarkerGroup);
    scene.add(assetAnchor);

    const selectable = [];
    const clock = new THREE.Clock();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const movementController = createMovementController({
      speed: WALK_SPEED_MPS,
      damping: MOVEMENT_DAMPING,
    });
    const moveState = movementController.moveState;
    let walkBounds = { minX: -3, maxX: 3, minZ: -4, maxZ: 4, minY: 0.1, maxY: 3.5 };
    let assetLoaded = false;
    let assetSize = new THREE.Vector3(1, 1, 1);
    let selectedObject = null;

    function resetMovementState() {
      movementController.reset();
      velocity.set(0, 0, 0);
      direction.set(0, 0, 0);
    }

    function setWalkStatus(message, tone = 'neutral') {
      if (!walkStatus) return;
      walkStatus.textContent = message;
      walkStatus.dataset.tone = tone;
    }

    function setAssetStatus(message, tone = 'neutral') {
      if (!assetStatus) return;
      assetStatus.textContent = message;
      assetStatus.dataset.tone = tone;
    }

    function showWalkOverlay() {
      if (!walkOverlay) return;
      walkOverlay.classList.remove('hidden');
    }

    function hideWalkOverlay() {
      if (!walkOverlay) return;
      walkOverlay.classList.add('hidden');
      if (walkOverlayHideTimer) {
        clearTimeout(walkOverlayHideTimer);
        walkOverlayHideTimer = null;
      }
    }

    function scheduleWalkOverlayAutoHide() {
      if (!walkOverlay) return;
      if (walkOverlayHideTimer) {
        clearTimeout(walkOverlayHideTimer);
      }
      walkOverlayHideTimer = window.setTimeout(() => {
        hideWalkOverlay();
      }, WALK_OVERLAY_AUTO_HIDE_MS);
    }

    function isEditableTarget(target) {
      if (!(target instanceof HTMLElement)) return false;
      if (target.isContentEditable) return true;
      if (INTERACTIVE_TAGS.has(target.tagName)) return true;
      return Boolean(
        target.closest('input, textarea, select, [contenteditable="true"]')
      );
    }

    function isViewportNode(node) {
      return viewportSection instanceof HTMLElement && node instanceof Node
        ? viewportSection.contains(node)
        : false;
    }

    function shouldTrapNavigationKey(event) {
      if (pointerControls.isLocked || handMode) return true;
      if (!viewportInteracting) return false;
      const target = event.target;
      if (isViewportNode(target)) return true;
      return target === document.body || target === document.documentElement;
    }

    function maybePreventNavigationKey(event) {
      if (!NAVIGATION_KEYS.has(event.code)) return false;
      if (event.defaultPrevented) return false;
      if (isEditableTarget(event.target)) return false;
      if (!shouldTrapNavigationKey(event)) return false;
      event.preventDefault();
      return true;
    }

    function updateWalkUi() {
      const locked = pointerControls.isLocked;
      if (enterWalkBtn) enterWalkBtn.disabled = locked || !supportsPointerLock || handMode;
      if (resetWalkBtn) resetWalkBtn.disabled = false;
    }

    function formatSnapDisplay(value) {
      const centimeters = value * 100;
      const precision = Math.abs(centimeters % 1) < 1e-6 ? 0 : 1;
      return `${centimeters.toFixed(precision)} cm`;
    }

    function applyTranslationSnap(value) {
      const clamped = clamp(value, MIN_TRANSLATION_SNAP, MAX_TRANSLATION_SNAP);
      translationSnap = clamped;
      handModeTranslateStep = clamped;
      handModeVerticalStep = clamped;
      transformControls.setTranslationSnap(translationSnap);
      if (translationSnapValue) {
        translationSnapValue.textContent = formatSnapDisplay(translationSnap);
      }
    }

    function initializeTranslationSnapControls() {
      if (!translationSnapInput) {
        applyTranslationSnap(translationSnap);
        return;
      }
      translationSnapInput.value = `${Math.round(translationSnap * 100)}`;
      applyTranslationSnap(translationSnap);
      translationSnapInput.addEventListener('input', event => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        const centimeters = Number(target.value);
        if (!Number.isFinite(centimeters)) return;
        applyTranslationSnap(centimeters / 100);
      });
    }

    function setHandMode(active, options = {}) {
      const { silent = false, showOverlay = false } = options;
      if (handMode === active) {
        if (!handMode) {
          if (showOverlay) {
            scheduleWalkOverlayAutoHide();
          } else {
            hideWalkOverlay();
          }
        }
        return;
      }
      handMode = active;
      viewportInteracting = handMode;
      document.body.dataset.handMode = handMode ? 'on' : 'off';
      if (handMode) {
        if (pointerControls.isLocked) {
          pointerControls.unlock();
        }
        resetMovementState();
        if (showOverlay) {
          showWalkOverlay();
          scheduleWalkOverlayAutoHide();
        } else {
          hideWalkOverlay();
        }
        if (!silent) {
          setWalkStatus('Hand Mode active — drag gizmos or tap WASDQE/Space/Shift to adjust the selected object. Adjust the Translation Snap slider to change the step size.', 'info');
        }
      } else {
        if (!silent) {
          setWalkStatus('Hand Mode off. Click “Enter Walk Mode” to explore.', 'neutral');
        }
        if (showOverlay) {
          scheduleWalkOverlayAutoHide();
        } else {
          hideWalkOverlay();
        }
      }
      updateWalkUi();
    }

    function adjustSelectedObjectFromHandMode(event) {
      if (!handMode || !selectedObject) return false;
      const fastMultiplier = event.altKey ? 5 : 1;
      const step = handModeTranslateStep * fastMultiplier;
      const verticalStep = handModeVerticalStep * fastMultiplier;
      const rotateStep = HAND_MODE_ROTATE_STEP * fastMultiplier;
      let handled = false;
      switch (event.code) {
        case 'KeyW':
          selectedObject.position.z -= step;
          handled = true;
          break;
        case 'KeyS':
          selectedObject.position.z += step;
          handled = true;
          break;
        case 'KeyA':
          selectedObject.position.x -= step;
          handled = true;
          break;
        case 'KeyD':
          selectedObject.position.x += step;
          handled = true;
          break;
        case 'Space':
          selectedObject.position.y += verticalStep;
          handled = true;
          break;
        case 'ShiftLeft':
        case 'ShiftRight':
          selectedObject.position.y -= verticalStep;
          handled = true;
          break;
        case 'KeyQ':
          selectedObject.rotation.y += rotateStep;
          handled = true;
          break;
        case 'KeyE':
          selectedObject.rotation.y -= rotateStep;
          handled = true;
          break;
      }
      if (handled) {
        clampAsset(selectedObject);
        selectedObject.userData.baseY = selectedObject.position.y;
        if (selectedObject === assetAnchor) {
          syncAssetLayoutFromAnchor();
        }
        scheduleWalkOverlayAutoHide();
      }
      return handled;
    }

    function updateRendererSize() {
      const { clientWidth, clientHeight } = rendererHost;
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / Math.max(1, clientHeight);
      camera.updateProjectionMatrix();
    }

    function baseWallDefinitions() {
      const W = layout.room.Wmm;
      const L = layout.room.Lmm;
      const t = DEFAULT_WALL_THICKNESS_MM;
      return [
        { ref: 'base:1', label: 'Wall 1 (y=0)', start: { x: 0, y: 0 }, end: { x: W, y: 0 }, thickness: t },
        { ref: 'base:2', label: 'Wall 2 (x=W)', start: { x: W, y: 0 }, end: { x: W, y: L }, thickness: t },
        { ref: 'base:3', label: 'Wall 3 (y=L)', start: { x: W, y: L }, end: { x: 0, y: L }, thickness: t },
        { ref: 'base:4', label: 'Wall 4 (x=0)', start: { x: 0, y: L }, end: { x: 0, y: 0 }, thickness: t }
      ];
    }

    function enrichWallGeometry(wall) {
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const length = Math.hypot(dx, dy);
      if (length < 1e-6) return null;
      const tangent = { x: dx / length, y: dy / length };
      const normal = { x: -tangent.y, y: tangent.x };
      return { ...wall, length, tangent, normal };
    }

    function getCustomWall(ref) {
      const id = ref.split(':')[1];
      return layout.custom_walls.find(w => String(w.id) === id);
    }

    function getWallGeometry(ref) {
      if (ref === undefined || ref === null) return null;
      let normalized = ref;
      if (typeof normalized === 'number') normalized = `base:${normalized}`;
      normalized = String(normalized);
      if (/^\d$/.test(normalized)) normalized = `base:${normalized}`;
      if (normalized.startsWith('base:')) {
        const wall = baseWallDefinitions().find(w => w.ref === normalized);
        return wall ? enrichWallGeometry(wall) : null;
      }
      if (normalized.startsWith('custom:')) {
        const wall = getCustomWall(normalized);
        if (!wall) return null;
        return enrichWallGeometry({
          ref: normalized,
          label: wall.name || 'Custom Wall',
          start: { x: toNumber(wall.x1, 0), y: toNumber(wall.y1, 0) },
          end: { x: toNumber(wall.x2, 0), y: toNumber(wall.y2, 0) },
          thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM) }
        );
      }
      return null;
    }

    function pointAlongWall(geom, offsetMm) {
      const distance = clamp(offsetMm, 0, geom.length);
      return {
        x: geom.start.x + geom.tangent.x * distance,
        y: geom.start.y + geom.tangent.y * distance
      };
    }

    function normalizeFloorItem(item) {
      const type = item.type || 'floorBox';
      const meta = FLOOR_ITEM_META[type] || FLOOR_ITEM_META.floorBox;
      return {
        ...item,
        type,
        id: item.id,
        x: toNumber(item.x, layout.room.Wmm / 2),
        y: toNumber(item.y, layout.room.Lmm / 2),
        w: toNumber(item.w !== undefined ? item.w : item.size, meta.wmm),
        l: toNumber(item.l !== undefined ? item.l : item.size, meta.lmm),
        rotation: toNumber(item.rotation, 0),
        assetRef: typeof item.assetRef === 'string' ? item.assetRef : undefined,
        elevation_mm: item.elevation_mm !== undefined ? toNumber(item.elevation_mm, 0) : undefined
      };
    }

    function normalizeWallItem(item) {
      let wallRef = item.wall;
      if (typeof wallRef === 'number') wallRef = `base:${wallRef}`;
      if (typeof wallRef === 'string' && /^\d$/.test(wallRef)) wallRef = `base:${wallRef}`;
      const type = typeof item.type === 'string' ? item.type : 'socket';
      const meta = WALL_ITEM_META[type] || WALL_ITEM_META.socket;
      const depth = item.h !== undefined ? item.h : meta.defaultDepthMm;
      const mountSource = item.mount_height_mm ?? item.mountHeight_mm ?? item.mount_height ?? item.mountHeight;
      const fallbackMount = meta.mountHeightMm !== undefined ? meta.mountHeightMm : DEFAULT_WALL_MOUNT_HEIGHT_MM;
      return {
        ...item,
        type,
        wall: wallRef || 'base:1',
        s: toNumber(item.s, 0),
        h: toNumber(depth, meta.defaultDepthMm),
        mountHeight_mm: toNumber(mountSource !== undefined ? mountSource : fallbackMount, fallbackMount)
      };
    }

    function normalizeCustomWall(wall, idx) {
      return {
        ...wall,
        id: wall.id !== undefined ? String(wall.id) : `cw_${idx}`,
        x1: toNumber(wall.x1, 0),
        y1: toNumber(wall.y1, 0),
        x2: toNumber(wall.x2, 0),
        y2: toNumber(wall.y2, 0),
        thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM),
        name: wall.name
      };
    }

    function normalizeDoor(door, idx) {
      let wallRef = door.wall;
      if (typeof wallRef === 'number') wallRef = `base:${wallRef}`;
      if (typeof wallRef === 'string' && /^\d$/.test(wallRef)) wallRef = `base:${wallRef}`;
      return {
        ...door,
        id: door.id !== undefined ? String(door.id) : `door_${idx}`,
        wall: wallRef || 'base:1',
        offset: toNumber(door.offset, 0),
        width: toNumber(door.width, 900),
        thickness: toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM)
      };
    }

    async function ensureCableCatalog() {
      if (cableCatalogData) return cableCatalogData;
      let loaded = null;
      try {
        const resp = await fetch(CABLE_CATALOG_URL, { cache: 'no-store' });
        if (!resp.ok) {
          throw new Error(`Failed to load cable catalog: ${resp.status}`);
        }
        loaded = await resp.json();
      } catch (err) {
        console.warn('Falling back to default cable catalog', err);
      }
      if (typeof window.normalizeCableCatalogWithDefaults === 'function') {
        cableCatalogData = window.normalizeCableCatalogWithDefaults(loaded);
      } else {
        cableCatalogData = loaded || window.DEFAULT_CABLE_CATALOG || {};
      }
      return cableCatalogData;
    }

    function cableColorForType(type) {
      const catalogColor = cableCatalogData && cableCatalogData.cableTypes && cableCatalogData.cableTypes[type]
        ? cableCatalogData.cableTypes[type].color
        : null;
      if (catalogColor) return catalogColor;
      if (window.DEFAULT_CABLE_CATALOG && window.DEFAULT_CABLE_CATALOG.cableTypes[type]) {
        return window.DEFAULT_CABLE_CATALOG.cableTypes[type].color;
      }
      return FALLBACK_CABLE_COLORS[type] || (window.getDefaultCableColor ? window.getDefaultCableColor(type) : '#94a3b8');
    }

    function parseCableColor(value) {
      if (typeof value === 'number') {
        return { color: new THREE.Color(value), opacity: 1 };
      }
      if (typeof value === 'string') {
        const rgbaMatch = value.match(/^rgba?\(([^)]+)\)$/i);
        if (rgbaMatch) {
          const parts = rgbaMatch[1].split(',').map(v => Number(v.trim()));
          if (parts.length >= 3) {
            const [r, g, b, a] = parts;
            const color = new THREE.Color(r / 255, g / 255, b / 255);
            const opacity = parts.length === 4 && Number.isFinite(a) ? a : 1;
            return { color, opacity: clamp(opacity, 0, 1) };
          }
        }
        const color = new THREE.Color();
        color.setStyle(value);
        return { color, opacity: 1 };
      }
      return { color: new THREE.Color('#94a3b8'), opacity: 1 };
    }

    function guessCableEndpointKind(assetId) {
      if (!assetId) return null;
      if ((layout.floor_items || []).some(item => item && item.id === assetId)) return 'floor';
      if ((layout.wall_items || []).some(item => item && item.id === assetId)) return 'wall';
      return null;
    }

    function normalizeCable(entry, idx) {
      if (!entry || typeof entry !== 'object') return null;
      const cableType = typeof entry.cableType === 'string' ? entry.cableType : null;
      if (!cableType) return null;
      const sourceRaw = entry.source && typeof entry.source === 'object' ? entry.source : {};
      const targetRaw = entry.target && typeof entry.target === 'object' ? entry.target : {};
      const sourceAssetId = sourceRaw.assetId || entry.sourceAssetId;
      const targetAssetId = targetRaw.assetId || entry.targetAssetId;
      const sourceSocketId = sourceRaw.socketId || entry.sourceSocketId;
      const targetSocketId = targetRaw.socketId || entry.targetSocketId;
      if (!sourceAssetId || !sourceSocketId || !targetAssetId || !targetSocketId) return null;
      const sourceKind = sourceRaw.kind || guessCableEndpointKind(sourceAssetId);
      const targetKind = targetRaw.kind || guessCableEndpointKind(targetAssetId);
      if (!sourceKind || !targetKind) return null;
      const controlPoints = Array.isArray(entry.controlPoints)
        ? entry.controlPoints
            .map(pt => {
              if (!pt || typeof pt !== 'object') return null;
              const u = Number(pt.u);
              const v = Number(pt.v);
              const w = Number(pt.w != null ? pt.w : pt.z);
              const xMm = Number(pt.x_mm);
              const yMm = Number(pt.y_mm);
              const zMm = Number(pt.z_mm);
              const hasNormalized = Number.isFinite(u) && Number.isFinite(v);
              const x = Number.isFinite(xMm) ? xMm : hasNormalized ? u * layout.room.Wmm : null;
              const y = Number.isFinite(yMm) ? yMm : hasNormalized ? v * layout.room.Lmm : null;
              const z = Number.isFinite(zMm)
                ? zMm
                : Number.isFinite(w)
                  ? w * ROOM_HEIGHT_MM
                  : ROOM_HEIGHT_MM / 2;
              if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
              return { x, y, z };
            })
            .filter(Boolean)
        : [];
      const bendPoints = Array.isArray(entry.bendPoints)
        ? entry.bendPoints
            .map(pt => {
              if (!pt || typeof pt !== 'object') return null;
              const u = Number(pt.u);
              const v = Number(pt.v);
              const w = Number(pt.w != null ? pt.w : pt.z);
              const xMm = Number(pt.x_mm);
              const yMm = Number(pt.y_mm);
              const zMm = Number(pt.z_mm);
              const hasNormalized = Number.isFinite(u) && Number.isFinite(v);
              const x = Number.isFinite(xMm) ? xMm : hasNormalized ? u * layout.room.Wmm : null;
              const y = Number.isFinite(yMm) ? yMm : hasNormalized ? v * layout.room.Lmm : null;
              const z = Number.isFinite(zMm)
                ? zMm
                : Number.isFinite(w)
                  ? w * ROOM_HEIGHT_MM
                  : ROOM_HEIGHT_MM / 2;
              if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
              return { x, y, z };
            })
            .filter(Boolean)
        : [];
      return {
        id: entry.id || `cable_${idx}`,
        cableType,
        source: { kind: sourceKind, assetId: sourceAssetId, socketId: sourceSocketId },
        target: { kind: targetKind, assetId: targetAssetId, socketId: targetSocketId },
        bendPoints,
        controlPoints,
        pins: Array.isArray(entry.pins) ? entry.pins : [],
        length_mm: toNumber(entry.length_mm, 0),
        status: entry.status || 'unknown'
      };
    }

    function exportCableSnapshot(cable) {
      const safePoints = (cable.controlPoints || []).map(pt => {
        const rawU = Number(pt.x) / layout.room.Wmm;
        const rawV = Number(pt.y) / layout.room.Lmm;
        const rawW = Number(pt.z || 0) / ROOM_HEIGHT_MM;
        return {
          u: Number.isFinite(rawU) ? rawU : 0,
          v: Number.isFinite(rawV) ? rawV : 0,
          w: Number.isFinite(rawW) ? rawW : 0,
          x_mm: Number.isFinite(pt.x) ? pt.x : 0,
          y_mm: Number.isFinite(pt.y) ? pt.y : 0,
          z_mm: Number.isFinite(pt.z) ? pt.z : 0
        };
      });
      const bendPoints = (cable.bendPoints || []).map(pt => {
        const rawU = Number(pt.x) / layout.room.Wmm;
        const rawV = Number(pt.y) / layout.room.Lmm;
        const rawW = Number(pt.z || 0) / ROOM_HEIGHT_MM;
        return {
          u: Number.isFinite(rawU) ? rawU : 0,
          v: Number.isFinite(rawV) ? rawV : 0,
          w: Number.isFinite(rawW) ? rawW : 0,
          x_mm: Number.isFinite(pt.x) ? pt.x : 0,
          y_mm: Number.isFinite(pt.y) ? pt.y : 0,
          z_mm: Number.isFinite(pt.z) ? pt.z : 0
        };
      });
      return {
        id: cable.id,
        cableType: cable.cableType,
        source: {
          assetId: cable.source.assetId,
          socketId: cable.source.socketId,
          kind: cable.source.kind
        },
        target: {
          assetId: cable.target.assetId,
          socketId: cable.target.socketId,
          kind: cable.target.kind
        },
        controlPoints: safePoints,
        bendPoints,
        pins: Array.isArray(cable.pins) ? cable.pins : [],
        length_mm: Math.round(cable.length_mm || 0),
        status: cable.status || 'unknown'
      };
    }

    function resolveCableSocketMm(ref) {
      if (!ref) return null;
      if (ref.kind === 'floor') {
        const item = (layout.floor_items || []).find(it => it && it.id === ref.assetId);
        if (!item) return null;
        const assets = cableCatalogData && cableCatalogData.assets ? cableCatalogData.assets : {};
        const meta = assets[item.type];
        if (!meta) return null;
        const socket = (meta.connectionSockets || []).find(s => s.id === ref.socketId);
        if (!socket) return null;
        const anchor = socket.anchor || { u: 0.5, v: 0.5, w: 0.5 };
        const dims = meta.boundingBox_mm || {};
        const width = toNumber(item.w, dims.w || 0);
        const length = toNumber(item.l, dims.l || 0);
        const height = dims.h || ROOM_HEIGHT_MM;
        const offsetX = (anchor.u - 0.5) * width;
        const offsetY = (anchor.v - 0.5) * length;
        const rot = THREE.MathUtils.degToRad(toNumber(item.rotation, 0));
        const cos = Math.cos(rot);
        const sin = Math.sin(rot);
        const baseX = toNumber(item.x, layout.room.Wmm / 2) + offsetX * cos - offsetY * sin;
        const baseY = toNumber(item.y, layout.room.Lmm / 2) + offsetX * sin + offsetY * cos;
        const elevation = toNumber(item.elevation_mm, 0);
        const baseZ = (anchor.w || 0) * height + elevation;
        return { x: baseX, y: baseY, z: baseZ };
      }
      if (ref.kind === 'wall') {
        const item = (layout.wall_items || []).find(it => it && it.id === ref.assetId);
        if (!item) return null;
        const geom = getWallGeometry(item.wall);
        if (!geom) return null;
        const type = typeof item.type === 'string' ? item.type : 'socket';
        const wallMeta = WALL_ITEM_META[type] || WALL_ITEM_META.socket;
        const assets = cableCatalogData && cableCatalogData.assets ? cableCatalogData.assets : {};
        const assetKey = wallMeta.assetKey || 'wall_socket';
        const meta = assets[assetKey] || {};
        const socketsMeta = Array.isArray(meta.connectionSockets) && meta.connectionSockets.length
          ? meta.connectionSockets
          : wallMeta.fallbackSockets || [];
        const socket = socketsMeta.find(s => s.id === ref.socketId) || socketsMeta[0] || null;
        const anchor = socket && socket.anchor ? socket.anchor : { u: 0.5, v: 0.5, w: 0.5 };
        const offset = clamp(toNumber(item.s, 0), 0, geom.length);
        const base = pointAlongWall(geom, offset);
        const rawDepth = toNumber(item.h, wallMeta.defaultDepthMm);
        const depthMagnitude = clamp(Math.abs(rawDepth), 0, 4000);
        const offsetDirection = socket && socket.offsetDirection !== undefined
          ? Math.sign(socket.offsetDirection) || 1
          : 1;
        const depth = depthMagnitude * offsetDirection;
        const tip = {
          x: base.x + geom.normal.x * depth,
          y: base.y + geom.normal.y * depth
        };
        const fallbackMount = meta.mountHeightMm !== undefined ? meta.mountHeightMm : DEFAULT_WALL_MOUNT_HEIGHT_MM;
        const mountHeight = clamp(toNumber(item.mountHeight_mm, fallbackMount), 0, ROOM_HEIGHT_MM);
        const bboxHeight = meta.boundingBox_mm && meta.boundingBox_mm.h ? meta.boundingBox_mm.h : ROOM_HEIGHT_MM;
        const anchorOffset = (anchor.w != null ? anchor.w - 0.5 : 0) * bboxHeight;
        const height = clamp(mountHeight + anchorOffset, 0, ROOM_HEIGHT_MM);
        return { x: tip.x, y: tip.y, z: height };
      }
      return null;
    }

    function resolveCableSocketWorld(ref) {
      const mm = resolveCableSocketMm(ref);
      return mm ? cablePointMmToWorld(mm) : null;
    }

    function cablePointMmToWorld(point) {
      const world = mmPointToWorld(point.x, point.y);
      return new THREE.Vector3(world.x, mm2m(point.z || 0), world.z);
    }

    function cloneCablePointMm(pt) {
      if (!pt) return { x: 0, y: 0, z: 0 };
      return { x: Number(pt.x) || 0, y: Number(pt.y) || 0, z: Number(pt.z) || 0 };
    }

    function getCableAnchorsMm(cable, startMm, endMm) {
      const anchors = [];
      if (startMm) anchors.push(cloneCablePointMm(startMm));
      const bends = Array.isArray(cable.bendPoints) ? cable.bendPoints : [];
      bends.forEach(pt => anchors.push(cloneCablePointMm(pt)));
      if (endMm) anchors.push(cloneCablePointMm(endMm));
      return anchors;
    }

    function defaultHandlesForSegmentMm(startMm, endMm) {
      const dx = endMm.x - startMm.x;
      const dy = endMm.y - startMm.y;
      const planarLength = Math.hypot(dx, dy) || 1;
      const nx = -dy / planarLength;
      const ny = dx / planarLength;
      const slack = planarLength * CABLE_LATERAL_SLACK_RATIO;
      const startZ = Number.isFinite(startMm.z) ? startMm.z : ROOM_HEIGHT_MM / 2;
      const endZ = Number.isFinite(endMm.z) ? endMm.z : ROOM_HEIGHT_MM / 2;
      const baseHeight = Math.min(startZ, endZ);
      const sag = clamp(planarLength * CABLE_SAG_RATIO, CABLE_SAG_MIN_MM, CABLE_SAG_MAX_MM);
      const midZ = Math.max(baseHeight - sag, 0);
      return [
        {
          x: startMm.x + dx * 0.25 + nx * slack,
          y: startMm.y + dy * 0.25 + ny * slack,
          z: midZ
        },
        {
          x: startMm.x + dx * 0.75 + nx * slack,
          y: startMm.y + dy * 0.75 + ny * slack,
          z: midZ
        }
      ];
    }

    function ensureCableControlPointsForCable(cable, startMm, endMm, forceDefaults = false) {
      if (!startMm || !endMm) return [];
      if (!Array.isArray(cable.bendPoints)) cable.bendPoints = [];
      if (!Array.isArray(cable.controlPoints)) cable.controlPoints = [];
      const anchors = getCableAnchorsMm(cable, startMm, endMm);
      const segmentCount = Math.max(anchors.length - 1, 1);
      const handles = new Array(segmentCount * 2);
      for (let seg = 0; seg < segmentCount; seg++) {
        const [def1, def2] = defaultHandlesForSegmentMm(anchors[seg], anchors[seg + 1]);
        const existing1 = !forceDefaults ? cable.controlPoints[seg * 2] : null;
        const existing2 = !forceDefaults ? cable.controlPoints[seg * 2 + 1] : null;
        handles[seg * 2] = existing1 ? cloneCablePointMm(existing1) : def1;
        handles[seg * 2 + 1] = existing2 ? cloneCablePointMm(existing2) : def2;
      }
      cable.controlPoints = handles;
      return anchors;
    }

    function resetCableHandlesForCable(cable, startMm, endMm) {
      ensureCableControlPointsForCable(cable, startMm, endMm, true);
    }

    function cubicPointVec(t, p0, p1, p2, p3) {
      const it = 1 - t;
      const it2 = it * it;
      const t2 = t * t;
      const a = it2 * it;
      const b = 3 * it2 * t;
      const c = 3 * it * t2;
      const d = t * t2;
      return new THREE.Vector3(
        a * p0.x + b * p1.x + c * p2.x + d * p3.x,
        a * p0.y + b * p1.y + c * p2.y + d * p3.y,
        a * p0.z + b * p1.z + c * p2.z + d * p3.z
      );
    }

    function computeCableLengthMm(points) {
      if (!Array.isArray(points) || points.length < 2) return 0;
      let total = 0;
      for (let i = 1; i < points.length; i++) {
        total += points[i - 1].distanceTo(points[i]);
      }
      return Math.round(m2mm(total));
    }

    function buildCables() {
      clearGroup(cableGroup);
      const cables = Array.isArray(layout.cables) ? layout.cables : [];
      const next = [];
      cables.forEach(cable => {
        const startMm = resolveCableSocketMm(cable.source);
        const endMm = resolveCableSocketMm(cable.target);
        if (!startMm || !endMm) {
          return;
        }
        const anchors = ensureCableControlPointsForCable(cable, startMm, endMm);
        if (!anchors || anchors.length < 2) return;
        const segments = anchors.length - 1;
        const points = [];
        for (let seg = 0; seg < segments; seg++) {
          const segStartMm = anchors[seg];
          const segEndMm = anchors[seg + 1];
          const cp1Mm = cable.controlPoints[seg * 2];
          const cp2Mm = cable.controlPoints[seg * 2 + 1];
          if (!cp1Mm || !cp2Mm) return;
          const startWorld = cablePointMmToWorld(segStartMm);
          const endWorld = cablePointMmToWorld(segEndMm);
          const cp1World = cablePointMmToWorld(cp1Mm);
          const cp2World = cablePointMmToWorld(cp2Mm);
          if (seg === 0) {
            points.push(startWorld.clone());
          }
          for (let i = 1; i <= CABLE_SAMPLE_SEGMENTS; i++) {
            const t = i / CABLE_SAMPLE_SEGMENTS;
            points.push(cubicPointVec(t, startWorld, cp1World, cp2World, endWorld));
          }
        }
        if (points.length < 2) return;
        const curve = new THREE.CatmullRomCurve3(points);
        const tubularSegments = Math.max(points.length * 2, segments * CABLE_SAMPLE_SEGMENTS);
        const geometry = new THREE.TubeGeometry(curve, tubularSegments, DEFAULT_CABLE_RADIUS_M, 8, false);
        const rawColor = cableColorForType(cable.cableType);
        const { color, opacity } = parseCableColor(rawColor);
        const material = new THREE.MeshStandardMaterial({ color, roughness: 0.35, metalness: 0.08 });
        if (opacity < 1) {
          material.transparent = true;
          material.opacity = opacity;
        }
        if (cable.status === 'over_limit') {
          material.emissive = new THREE.Color(0xff6b6b);
          material.emissiveIntensity = 0.35;
        }
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.cableId = cable.id;
        cableGroup.add(mesh);
        const lengthMm = computeCableLengthMm(points);
        cable.length_mm = lengthMm;
        const meta = cableCatalogData && cableCatalogData.cableTypes ? cableCatalogData.cableTypes[cable.cableType] : null;
        const maxLength = meta && meta.maxLength_mm ? meta.maxLength_mm : 3048;
        cable.status = lengthMm > maxLength ? 'over_limit' : 'within_limit';
        next.push(cable);
      });
      layout.cables = next;
    }

    async function refreshCableMeshes() {
      if (!cableCatalogData) {
        try {
          await ensureCableCatalog();
        } catch (err) {
          console.error('Failed to load cable catalog', err);
          return;
        }
      }
      buildWallItems();
      buildCables();
    }

    function coerceLayoutPayload(raw) {
      if (!raw || typeof raw !== 'object') return null;
      if (raw.layout && typeof raw.layout === 'object') return raw.layout;
      return raw;
    }

    function parseLayoutText(rawText) {
      if (typeof rawText !== 'string') {
        throw new Error('layout-file-empty');
      }
      const sanitized = rawText
        .replace(/^\uFEFF/, '')
        .replace(/\u0000/g, '')
        .trim();
      if (!sanitized) {
        throw new Error('layout-file-empty');
      }
      try {
        return coerceLayoutPayload(JSON.parse(sanitized));
      } catch (err) {
        const error = new Error('layout-file-invalid');
        error.cause = err;
        error.raw = sanitized.slice(0, 1200);
        throw error;
      }
    }

    function persistLayoutLocal(data) {
      try {
        if (window.localStorage) {
          window.localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(data));
        }
      } catch (err) {
        console.warn('Failed to persist layout locally', err);
      }
    }

    function loadLayoutLocal() {
      try {
        if (!window.localStorage) return null;
        const raw = window.localStorage.getItem(LAYOUT_STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (err) {
        console.warn('Failed to load layout from local storage', err);
        return null;
      }
    }

    async function saveLayoutRemote(data) {
      try {
        const resp = await fetch('/api/layout', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        if (!resp.ok) throw new Error(await resp.text());
        return true;
      } catch (err) {
        console.warn('Failed to save layout to server', err);
        return false;
      }
    }

    async function loadLayoutRemote() {
      try {
        const resp = await fetch('/api/layout', {
          method: 'GET',
          headers: { Accept: 'application/json' },
          cache: 'no-store'
        });
        if (!resp.ok) {
          if (resp.status === 404) return null;
          throw new Error(await resp.text());
        }
        const text = await resp.text();
        if (!text) return null;
        const payload = JSON.parse(text);
        if (payload && typeof payload === 'object' && payload.layout !== undefined) {
          return payload.layout;
        }
        if (payload && typeof payload === 'object') {
          return payload;
        }
        return null;
      } catch (err) {
        console.warn('Failed to load layout from server', err);
        return null;
      }
    }

    async function restorePersistedLayout(options = {}) {
      const { preferRemote = false } = options;
      const order = preferRemote ? ['remote', 'local'] : ['local', 'remote'];
      for (const source of order) {
        if (source === 'local') {
          const local = loadLayoutLocal();
          if (local) return { data: local, source: 'local' };
        } else {
          const remote = await loadLayoutRemote();
          if (remote) return { data: remote, source: 'server' };
        }
      }
      return null;
    }

    function snapshotLayout() {
      ensureLayoutIds();
      return {
        room: {
          W: toNumber(layout.room.Wmm, 6000),
          L: toNumber(layout.room.Lmm, 8000)
        },
        floor_items: (layout.floor_items || []).map(item => {
          const meta = FLOOR_ITEM_META[item.type] || FLOOR_ITEM_META.floorBox;
          const snapshot = {
            id: item.id,
            type: item.type,
            x: toNumber(item.x, layout.room.Wmm / 2),
            y: toNumber(item.y, layout.room.Lmm / 2),
            w: toNumber(item.w, meta.wmm),
            l: toNumber(item.l, meta.lmm),
            rotation: toNumber(item.rotation, 0)
          };
          if (item.assetRef) snapshot.assetRef = item.assetRef;
          if (item.elevation_mm !== undefined) {
            snapshot.elevation_mm = toNumber(item.elevation_mm, 0);
          }
          return snapshot;
        }),
        wall_items: (layout.wall_items || []).map(item => ({
          id: item.id,
          type: item.type,
          wall: item.wall,
          s: toNumber(item.s, 0),
          h: toNumber(item.h, 0)
        })),
        custom_walls: (layout.custom_walls || []).map(wall => ({
          id: wall.id,
          name: wall.name,
          x1: toNumber(wall.x1, 0),
          y1: toNumber(wall.y1, 0),
          x2: toNumber(wall.x2, 0),
          y2: toNumber(wall.y2, 0),
          thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM)
        })),
        doors: (layout.doors || []).map(door => ({
          id: door.id,
          wall: door.wall,
          offset: toNumber(door.offset, 0),
          width: toNumber(door.width, 900),
          thickness: toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM)
        })),
        cables: (layout.cables || []).map(exportCableSnapshot)
      };
    }

    function persistLatest(options = {}) {
      const { local = true, remote = true } = options;
      const snapshot = snapshotLayout();
      if (local) persistLayoutLocal(snapshot);
      if (remote) saveLayoutRemote(snapshot);
    }

    function ensureLayoutIds() {
      layout.custom_walls = (layout.custom_walls || []).map(normalizeCustomWall);
      layout.doors = (layout.doors || []).map(normalizeDoor);
      layout.floor_items = (layout.floor_items || []).map(normalizeFloorItem);
      layout.wall_items = (layout.wall_items || []).map(normalizeWallItem);
      layout.cables = (layout.cables || []).map(normalizeCable);
    }

    async function ingestLayout(data, persistOptions = {}) {
      if (data.room) {
        const roomW = data.room.W !== undefined ? data.room.W : data.room.Wmm;
        const roomL = data.room.L !== undefined ? data.room.L : data.room.Lmm;
        layout.room.Wmm = toNumber(roomW, layout.room.Wmm);
        layout.room.Lmm = toNumber(roomL, layout.room.Lmm);
      }
      if (Array.isArray(data.floor_items)) {
        layout.floor_items = data.floor_items.map(normalizeFloorItem);
      } else if (Array.isArray(data.items)) {
        const floor = data.items.filter(it => it.type !== 'socket').map(normalizeFloorItem);
        const wallItems = data.items.filter(it => it.type === 'socket').map(normalizeWallItem);
        layout.floor_items = floor;
        layout.wall_items = wallItems;
      }
      if (Array.isArray(data.wall_items)) {
        layout.wall_items = data.wall_items.map(normalizeWallItem);
      }
      if (Array.isArray(data.custom_walls)) {
        layout.custom_walls = data.custom_walls.map(normalizeCustomWall);
      }
      if (Array.isArray(data.doors)) {
        layout.doors = data.doors.map(normalizeDoor);
      }
      if (Array.isArray(data.cables)) {
        layout.cables = data.cables.map(normalizeCable).filter(Boolean);
      }
      ensureLayoutIds();
      applyLayout();
      selectObject(null);
      await refreshCableMeshes();
      await ensureAssetFromLayout(persistOptions);
      persistLatest(persistOptions);
      if (supportsPointerLock) {
        setWalkStatus('Layout imported. Click “Enter Walk Mode” to explore.', 'neutral');
      } else {
        setWalkStatus(POINTER_LOCK_UNSUPPORTED_MESSAGE, 'warn');
      }
    }

    function mmPointToWorld(xMm, yMm) {
      const x = mm2m(xMm - layout.room.Wmm / 2);
      const z = mm2m(yMm - layout.room.Lmm / 2);
      return new THREE.Vector3(x, 0, z);
    }

    function worldToLayoutFloor(vector) {
      const xMm = m2mm(vector.x) + layout.room.Wmm / 2;
      const yMm = m2mm(vector.z) + layout.room.Lmm / 2;
      return {
        x: Math.round(clamp(xMm, 0, layout.room.Wmm)),
        y: Math.round(clamp(yMm, 0, layout.room.Lmm))
      };
    }

    function findAssetLayoutIndex() {
      const items = layout.floor_items || [];
      return items.findIndex(item => item && item.type === ASSET_FLOOR_ITEM_TYPE && item.assetRef === SAMPLE_ASSET_REF);
    }

    function getAssetLayoutEntry() {
      const idx = findAssetLayoutIndex();
      return idx >= 0 ? layout.floor_items[idx] : null;
    }

    function syncAssetLayoutFromAnchor(options = {}) {
      if (!assetLoaded) return;
      const { persist = true, persistOptions = {} } = options;
      if (!Array.isArray(layout.floor_items)) {
        layout.floor_items = [];
      }
      const position = assetAnchor.position.clone();
      const { x, y } = worldToLayoutFloor(position);
      const rotationDeg = Math.round(THREE.MathUtils.radToDeg(assetAnchor.rotation.y || 0));
      const snapshot = {
        id: SAMPLE_ASSET_ID,
        type: ASSET_FLOOR_ITEM_TYPE,
        assetRef: SAMPLE_ASSET_REF,
        x,
        y,
        w: Math.round(m2mm(assetSize.x)),
        l: Math.round(m2mm(assetSize.z)),
        rotation: rotationDeg,
        elevation_mm: Math.round(m2mm(position.y))
      };
      const idx = findAssetLayoutIndex();
      if (idx >= 0) {
        layout.floor_items[idx] = { ...layout.floor_items[idx], ...snapshot };
      } else {
        layout.floor_items.push(snapshot);
      }
      if (persist) {
        persistLatest(persistOptions);
      }
    }

    function applyAssetLayoutEntry(entry, options = {}) {
      if (!assetLoaded || !entry) return;
      const { persist = true, persistOptions = {} } = options;
      const world = mmPointToWorld(
        toNumber(entry.x, layout.room.Wmm / 2),
        toNumber(entry.y, layout.room.Lmm / 2)
      );
      const elevation = entry.elevation_mm !== undefined
        ? mm2m(toNumber(entry.elevation_mm, 0))
        : assetAnchor.userData.baseY !== undefined
          ? assetAnchor.userData.baseY
          : assetAnchor.position.y;
      assetAnchor.position.set(world.x, elevation, world.z);
      assetAnchor.rotation.y = THREE.MathUtils.degToRad(toNumber(entry.rotation, 0));
      assetAnchor.userData.baseY = elevation;
      assetAnchor.userData.minY = assetAnchor.userData.minY !== undefined
        ? Math.min(assetAnchor.userData.minY, elevation)
        : elevation;
      clampAsset(assetAnchor);
      assetAnchor.updateMatrixWorld(true);
      syncAssetLayoutFromAnchor({ persist, persistOptions });
    }

    async function ensureAssetFromLayout(persistOptions = {}) {
      const entry = getAssetLayoutEntry();
      if (!entry) return;
      if (!assetLoaded) {
        try {
          await loadSampleAsset({ fromLayout: entry, persistOptions });
        } catch (err) {
          console.error('Failed to load sample asset from layout', err);
        }
      } else {
        applyAssetLayoutEntry(entry, { persist: false });
      }
    }

    function disposeMaterial(material) {
      if (!material) return;
      if (Array.isArray(material)) {
        material.forEach(disposeMaterial);
        return;
      }
      if (material.map && typeof material.map.dispose === 'function') {
        material.map.dispose();
      }
      if (material.alphaMap && typeof material.alphaMap.dispose === 'function') {
        material.alphaMap.dispose();
      }
      if (typeof material.dispose === 'function') {
        material.dispose();
      }
    }

    function clearGroup(group) {
      for (let i = group.children.length - 1; i >= 0; i -= 1) {
        const child = group.children[i];
        group.remove(child);
        if (child.geometry && typeof child.geometry.dispose === 'function') {
          child.geometry.dispose();
        }
        if (child.material) {
          disposeMaterial(child.material);
        }
      }
    }

    function buildFloorAndBounds() {
      clearGroup(floorGroup);
      const floorW = mm2m(layout.room.Wmm);
      const floorL = mm2m(layout.room.Lmm);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xf1f3f9, roughness: 0.9, metalness: 0.05 });
      const floorGeo = new THREE.PlaneGeometry(floorW, floorL, 1, 1);
      const floorMesh = new THREE.Mesh(floorGeo, floorMat);
      floorMesh.rotation.x = -Math.PI / 2;
      floorMesh.position.set(0, 0, 0);
      floorGroup.add(floorMesh);

      const grid = new THREE.GridHelper(Math.max(floorW, floorL) + 2, Math.round(Math.max(floorW, floorL)));
      grid.material.opacity = 0.25;
      grid.material.transparent = true;
      grid.position.y = 0.002;
      floorGroup.add(grid);

      buildScaleMarkers(floorW, floorL);

      const minX = -floorW / 2 + 0.25;
      const maxX = floorW / 2 - 0.25;
      const minZ = -floorL / 2 + 0.25;
      const maxZ = floorL / 2 - 0.25;
      walkBounds = { minX, maxX, minZ, maxZ, minY: 0.1, maxY: mm2m(ROOM_HEIGHT_MM) - 0.2 };
      const midHeight = (walkBounds.maxY + walkBounds.minY) / 2;
      orbitTarget.set(0, midHeight, 0);
    }

    function buildScaleMarkers(floorW, floorL) {
      clearGroup(scaleMarkerGroup);
      const meter = 1;
      const baseColor = 0x1f2937;
      const markerMat = new THREE.LineBasicMaterial({ color: baseColor, linewidth: 1, transparent: true, opacity: 0.9 });

      const verticalBaseX = -floorW / 2 - 0.45;
      const verticalBaseZ = -floorL / 2 + 0.45;
      const verticalGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(verticalBaseX, 0, verticalBaseZ),
        new THREE.Vector3(verticalBaseX, meter, verticalBaseZ)
      ]);
      const verticalLine = new THREE.Line(verticalGeom, markerMat.clone());
      scaleMarkerGroup.add(verticalLine);

      const verticalTicksGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(verticalBaseX - 0.08, 0, verticalBaseZ),
        new THREE.Vector3(verticalBaseX + 0.08, 0, verticalBaseZ),
        new THREE.Vector3(verticalBaseX - 0.08, meter, verticalBaseZ),
        new THREE.Vector3(verticalBaseX + 0.08, meter, verticalBaseZ)
      ]);
      const verticalTicks = new THREE.LineSegments(verticalTicksGeom, markerMat.clone());
      scaleMarkerGroup.add(verticalTicks);

      const horizontalBaseX = -floorW / 2 + 0.45;
      const horizontalBaseZ = -floorL / 2 - 0.45;
      const horizontalGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(horizontalBaseX, 0.02, horizontalBaseZ),
        new THREE.Vector3(horizontalBaseX + meter, 0.02, horizontalBaseZ)
      ]);
      const horizontalLine = new THREE.Line(horizontalGeom, markerMat.clone());
      scaleMarkerGroup.add(horizontalLine);

      const horizontalTicksGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(horizontalBaseX, 0.02, horizontalBaseZ - 0.08),
        new THREE.Vector3(horizontalBaseX, 0.02, horizontalBaseZ + 0.08),
        new THREE.Vector3(horizontalBaseX + meter, 0.02, horizontalBaseZ - 0.08),
        new THREE.Vector3(horizontalBaseX + meter, 0.02, horizontalBaseZ + 0.08)
      ]);
      const horizontalTicks = new THREE.LineSegments(horizontalTicksGeom, markerMat.clone());
      scaleMarkerGroup.add(horizontalTicks);

      const verticalLabel = createLabelSprite('1 m');
      verticalLabel.center.set(0.5, 0);
      verticalLabel.position.set(verticalBaseX, meter + 0.05, verticalBaseZ);
      verticalLabel.scale.set(0.8, 0.35, 1);
      verticalLabel.material.depthTest = false;
      verticalLabel.renderOrder = 10;
      scaleMarkerGroup.add(verticalLabel);

      const horizontalLabel = createLabelSprite('1 m');
      horizontalLabel.center.set(0, 0.5);
      horizontalLabel.position.set(horizontalBaseX + meter + 0.05, 0.08, horizontalBaseZ);
      horizontalLabel.scale.set(0.8, 0.35, 1);
      horizontalLabel.material.depthTest = false;
      horizontalLabel.renderOrder = 10;
      scaleMarkerGroup.add(horizontalLabel);
    }

    function createLabelSprite(text) {
      const canvas = document.createElement('canvas');
      const width = 256;
      const height = 128;
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, width, height);
      ctx.font = 'bold 96px "Inter", "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.lineWidth = 16;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.strokeText(text, width / 2, height / 2);
      ctx.fillStyle = 'rgba(15, 23, 42, 0.95)';
      ctx.fillText(text, width / 2, height / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      return sprite;
    }

    function buildWalls() {
      clearGroup(wallGroup);
      const height = mm2m(ROOM_HEIGHT_MM);

      const defaultMat = new THREE.MeshStandardMaterial({ color: 0xd4d8e5, roughness: 0.55, metalness: 0.05 });
      baseWallDefinitions().forEach(def => {
        const geom = enrichWallGeometry(def);
        if (!geom) return;
        const thickness = mm2m(geom.thickness || DEFAULT_WALL_THICKNESS_MM);
        const length = mm2m(geom.length);
        const box = new THREE.BoxGeometry(length, height, thickness);
        const mesh = new THREE.Mesh(box, defaultMat.clone());
        const centerMm = pointAlongWall(geom, geom.length / 2);
        const offsetMm = {
          x: centerMm.x + geom.normal.x * (geom.thickness / 2),
          y: centerMm.y + geom.normal.y * (geom.thickness / 2)
        };
        const world = mmPointToWorld(offsetMm.x, offsetMm.y);
        mesh.position.set(world.x, height / 2, world.z);
        const angle = Math.atan2(geom.tangent.y, geom.tangent.x);
        mesh.rotation.y = -angle;
        wallGroup.add(mesh);
      });

      const customMat = new THREE.MeshStandardMaterial({ color: 0xb49a7a, roughness: 0.6, metalness: 0.08 });
      (layout.custom_walls || []).forEach(def => {
        const geom = getWallGeometry(`custom:${def.id}`);
        if (!geom) return;
        const thickness = mm2m(geom.thickness || DEFAULT_WALL_THICKNESS_MM);
        const length = mm2m(geom.length);
        const box = new THREE.BoxGeometry(length, height, thickness);
        const mesh = new THREE.Mesh(box, customMat.clone());
        const centerMm = pointAlongWall(geom, geom.length / 2);
        const offsetMm = {
          x: centerMm.x + geom.normal.x * (geom.thickness / 2),
          y: centerMm.y + geom.normal.y * (geom.thickness / 2)
        };
        const world = mmPointToWorld(offsetMm.x, offsetMm.y);
        mesh.position.set(world.x, height / 2, world.z);
        const angle = Math.atan2(geom.tangent.y, geom.tangent.x);
        mesh.rotation.y = -angle;
        wallGroup.add(mesh);
      });
    }

    function buildDoors() {
      clearGroup(doorGroup);
      const height = mm2m(DOOR_HEIGHT_MM);
      const mat = new THREE.MeshStandardMaterial({ color: 0x3b8d46, roughness: 0.4, metalness: 0.05 });
      (layout.doors || []).forEach(door => {
        const geom = getWallGeometry(door.wall);
        if (!geom) return;
        const widthMm = toNumber(door.width, 900);
        const width = mm2m(widthMm);
        const wallThicknessMm = geom.thickness || DEFAULT_WALL_THICKNESS_MM;
        const baseThicknessMm = Math.max(toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM), wallThicknessMm);
        const thicknessMm = baseThicknessMm + DOOR_VISUAL_EXTRA_THICKNESS_MM;
        const thickness = mm2m(thicknessMm);
        const box = new THREE.BoxGeometry(width, height, thickness);
        const mesh = new THREE.Mesh(box, mat.clone());
        const centerOffset = toNumber(door.offset, 0) + widthMm / 2;
        const centerMm = pointAlongWall(geom, centerOffset);
        const clearance = Math.min(DOOR_INTERIOR_CLEARANCE_MM, wallThicknessMm / 4);
        const centerDistance = thicknessMm / 2 - clearance;
        const offsetMm = {
          x: centerMm.x + geom.normal.x * centerDistance,
          y: centerMm.y + geom.normal.y * centerDistance
        };
        const world = mmPointToWorld(offsetMm.x, offsetMm.y);
        mesh.position.set(world.x, height / 2, world.z);
        const angle = Math.atan2(geom.tangent.y, geom.tangent.x);
        mesh.rotation.y = -angle;
        doorGroup.add(mesh);
      });
    }

    function buildWallItems() {
      clearGroup(wallItemGroup);
      const items = Array.isArray(layout.wall_items) ? layout.wall_items : [];
      const assetsCatalog = cableCatalogData && cableCatalogData.assets ? cableCatalogData.assets : {};
      items.forEach(item => {
        const geom = getWallGeometry(item.wall);
        if (!geom) return;
        const type = typeof item.type === 'string' ? item.type : 'socket';
        const meta = WALL_ITEM_META[type] || WALL_ITEM_META.socket;
        const assetKey = meta.assetKey || 'wall_socket';
        const assetDef = assetsCatalog[assetKey] || {};
        const bbox = assetDef.boundingBox_mm || meta.sizeMm || WALL_ITEM_DEFAULT_SIZE_MM;
        const widthMm = Math.max(toNumber(item.w, bbox.w || WALL_ITEM_DEFAULT_SIZE_MM.width), 40);
        const heightSource = bbox.h || WALL_ITEM_DEFAULT_SIZE_MM.height;
        const heightMm = Math.max(toNumber(item.height_mm, heightSource), 40);
        const baseDepth = bbox.l || WALL_ITEM_DEFAULT_SIZE_MM.depth;
        const rawDepth = toNumber(item.h, meta.defaultDepthMm !== undefined ? meta.defaultDepthMm : baseDepth);
        const depthMagnitudeMm = Math.max(Math.abs(rawDepth), 30);
        const direction = rawDepth < 0 ? -1 : 1;
        const extrudeMm = depthMagnitudeMm + WALL_ITEM_EXTRA_DEPTH_MM;
        const clearance = Math.min(WALL_ITEM_SURFACE_CLEARANCE_MM, depthMagnitudeMm / 2);
        const centerDistance = direction === 1
          ? extrudeMm / 2 - clearance
          : -(extrudeMm / 2 - clearance);
        const offset = clamp(toNumber(item.s, 0), 0, geom.length);
        const baseMm = pointAlongWall(geom, offset);
        const centerMm = {
          x: baseMm.x + geom.normal.x * centerDistance,
          y: baseMm.y + geom.normal.y * centerDistance
        };
        const world = mmPointToWorld(centerMm.x, centerMm.y);
        const width = mm2m(widthMm);
        const height = mm2m(heightMm);
        const depth = mm2m(extrudeMm);
        const fallbackMount = meta.mountHeightMm !== undefined ? meta.mountHeightMm : DEFAULT_WALL_MOUNT_HEIGHT_MM;
        const mountHeight = clamp(toNumber(item.mountHeight_mm, fallbackMount), 0, ROOM_HEIGHT_MM);
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({
          color: meta.color || 0xf9a825,
          roughness: 0.45,
          metalness: 0.12
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(world.x, mm2m(mountHeight), world.z);
        mesh.rotation.y = -Math.atan2(geom.tangent.y, geom.tangent.x);
        mesh.userData.wallItemId = item.id;
        wallItemGroup.add(mesh);
      });
    }

    function buildItems() {
      clearGroup(itemGroup);
      (layout.floor_items || []).forEach(item => {
        if (item.type === ASSET_FLOOR_ITEM_TYPE) {
          return;
        }
        const meta = FLOOR_ITEM_META[item.type] || FLOOR_ITEM_META.floorBox;
        const world = mmPointToWorld(
          toNumber(item.x, layout.room.Wmm / 2),
          toNumber(item.y, layout.room.Lmm / 2)
        );

        if (meta.kind === 'ceilingThermostat') {
          const dropMm = clamp(
            toNumber(item.drop_mm ?? item.h, meta.dropMm ?? 350),
            120,
            ROOM_HEIGHT_MM - 200
          );
          const sensorHeightMm = Math.max(meta.heightMm || meta.wmm || 200, 120);
          const rodLengthMm = Math.max(dropMm - sensorHeightMm / 2, 120);
          const group = new THREE.Group();
          const rodGeometry = new THREE.CylinderGeometry(mm2m(20), mm2m(20), mm2m(rodLengthMm), 12);
          const rodMaterial = new THREE.MeshStandardMaterial({
            color: 0x94a3b8,
            roughness: 0.3,
            metalness: 0.6
          });
          const rod = new THREE.Mesh(rodGeometry, rodMaterial);
          rod.position.y = -mm2m(rodLengthMm / 2);
          group.add(rod);

          const radiusMm = Math.max(meta.wmm ?? 240, 180) / 2;
          const puckHeightMm = Math.max(meta.heightMm ?? 120, 80);
          const puckGeometry = new THREE.CylinderGeometry(mm2m(radiusMm), mm2m(radiusMm * 0.9), mm2m(puckHeightMm), 24);
          const puckMaterial = new THREE.MeshStandardMaterial({
            color: meta.color,
            roughness: 0.4,
            metalness: 0.2
          });
          const puck = new THREE.Mesh(puckGeometry, puckMaterial);
          puck.position.y = -mm2m(rodLengthMm);
          group.add(puck);

          group.position.set(world.x, mm2m(ROOM_HEIGHT_MM), world.z);
          group.userData.floorItemId = item.id;
          itemGroup.add(group);
          return;
        }

        const w = mm2m(toNumber(item.w, meta.wmm));
        const l = mm2m(toNumber(item.l, meta.lmm));
        const h = meta.height !== undefined ? meta.height : 1.0;
        let geometry;
        if (meta.kind === 'cylinder') {
          const radius = Math.max(w, l) / 2;
          geometry = new THREE.CylinderGeometry(radius, radius * 0.95, h, 24);
        } else {
          geometry = new THREE.BoxGeometry(w, h, l);
        }
        const material = new THREE.MeshStandardMaterial({ color: meta.color, roughness: 0.45, metalness: 0.1 });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(world.x, h / 2, world.z);
        const rot = THREE.MathUtils.degToRad(toNumber(item.rotation, 0));
        if (rot) mesh.rotation.y = -rot;
        mesh.userData.floorItemId = item.id;
        itemGroup.add(mesh);
      });
    }

    function updateRoomInfo() {
      const Wm = (layout.room.Wmm / 1000).toFixed(2);
      const Lm = (layout.room.Lmm / 1000).toFixed(2);
      const heightM = (ROOM_HEIGHT_MM / 1000).toFixed(2);
      const customCount = layout.custom_walls && layout.custom_walls.length ? layout.custom_walls.length : 0;
      const doorCount = layout.doors && layout.doors.length ? layout.doors.length : 0;
      const itemCount = layout.floor_items && layout.floor_items.length ? layout.floor_items.length : 0;
      roomInfo.innerHTML = `Room: <strong>${Wm}m × ${Lm}m</strong> &middot; Height ${heightM}m<br>` +
        `${customCount} custom wall${customCount === 1 ? '' : 's'}, ${doorCount} door${doorCount === 1 ? '' : 's'}, ${itemCount} floor item${itemCount === 1 ? '' : 's'}`;
    }

    function applyLayout() {
      ensureLayoutIds();
      buildFloorAndBounds();
      buildWalls();
      buildDoors();
      buildWallItems();
      buildItems();
      void refreshCableMeshes();
      repositionAssetIfNeeded();
      updateRoomInfo();
      resetWalkPosition();
      pointerControls.unlock();
      resetMovementState();
      updateWalkUi();
    }

    function resetWalkPosition() {
      const cameraHolder = pointerControls.getObject();
      setHandMode(false, { silent: true });
      resetMovementState();
      cameraHolder.position.set(walkBounds.minX + 0.6, HUMAN_EYE_HEIGHT_M, walkBounds.minZ + 1.2);
      cameraHolder.rotation.set(0, 0, 0);
      camera.position.set(0, 0, 0);
      camera.rotation.set(0, 0, 0);
      updateWalkUi();
    }

    function clampCamera() {
      const pos = pointerControls.getObject().position;
      pos.x = clamp(pos.x, walkBounds.minX, walkBounds.maxX);
      pos.z = clamp(pos.z, walkBounds.minZ, walkBounds.maxZ);
      pos.y = clamp(pos.y, walkBounds.minY, walkBounds.maxY);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const movement = movementController.step({
        delta,
        pointerLocked: pointerControls.isLocked,
      });
      velocity.set(movement.velocity.x, movement.velocity.y, movement.velocity.z);
      direction.set(movement.direction.x, movement.direction.y, movement.direction.z);

      if (pointerControls.isLocked && velocity.lengthSq() > 0) {
        pointerControls.moveRight(-velocity.x * delta);
        pointerControls.moveForward(-velocity.z * delta);
        pointerControls.getObject().position.y += velocity.y * delta;
      }
      if (pointerControls.isLocked) {
        clampCamera();
      }
      renderer.render(scene, camera);
    }

    function onKeyDown(event) {
      if (event.key === HAND_MODE_TOGGLE_KEY) {
        if (!event.repeat) {
          setHandMode(!handMode);
        }
        event.preventDefault();
        return;
      }

      maybePreventNavigationKey(event);

      if (handMode) {
        if (adjustSelectedObjectFromHandMode(event)) {
          event.preventDefault();
        }
        return;
      }

      if (!pointerControls.isLocked) return;

      switch (event.code) {
        case 'KeyW':
          moveState.forward = true;
          break;
        case 'KeyS':
          moveState.back = true;
          break;
        case 'KeyA':
          moveState.left = true;
          break;
        case 'KeyD':
          moveState.right = true;
          break;
        case 'Space':
          moveState.up = true;
          event.preventDefault();
          break;
        case 'ShiftLeft':
        case 'ShiftRight':
          moveState.down = true;
          event.preventDefault();
          break;
      }
    }
    function onKeyUp(event) {
      maybePreventNavigationKey(event);
      if (handMode) {
        if (event.code === 'Space' || event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
          event.preventDefault();
        }
        return;
      }

      if (!pointerControls.isLocked) return;

      switch (event.code) {
        case 'KeyW':
          moveState.forward = false;
          break;
        case 'KeyS':
          moveState.back = false;
          break;
        case 'KeyA':
          moveState.left = false;
          break;
        case 'KeyD':
          moveState.right = false;
          break;
        case 'Space':
          moveState.up = false;
          event.preventDefault();
          break;
        case 'ShiftLeft':
        case 'ShiftRight':
          moveState.down = false;
          event.preventDefault();
          break;
      }
    }

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    pointerControls.addEventListener('lock', () => {
      viewportInteracting = true;
      hideWalkOverlay();
      if (handMode) {
        setHandMode(false, { silent: true });
      }
      if (walkOverlayHideTimer) {
        clearTimeout(walkOverlayHideTimer);
        walkOverlayHideTimer = null;
      }
      resetMovementState();
      updateWalkUi();
      setWalkStatus('Walk mode active — use WASD and your mouse to move. Press Esc to exit.', 'success');
    });
    pointerControls.addEventListener('unlock', () => {
      viewportInteracting = handMode;
      resetMovementState();
      updateWalkUi();
      if (handMode) {
        hideWalkOverlay();
        setWalkStatus('Hand Mode active — drag gizmos or tap WASDQE/Space/Shift to adjust the selected object.', 'info');
      } else {
        showWalkOverlay();
        scheduleWalkOverlayAutoHide();
        setWalkStatus('Walk mode exited. Click “Enter Walk Mode” to continue exploring.', 'neutral');
      }
    });

    document.addEventListener('pointerlockerror', event => {
      console.warn('Pointer lock request failed', event);
      viewportInteracting = true;
      showWalkOverlay();
      scheduleWalkOverlayAutoHide();
      resetMovementState();
      updateWalkUi();
      setWalkStatus('Pointer lock was blocked. Click inside the viewport first or open this demo in a standalone tab.', 'warn');
    });

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        resetMovementState();
      }
    });

    transformControls.addEventListener('dragging-changed', event => {
      if (event.value) {
        pointerControls.unlock();
        setHandMode(true, { silent: true });
      } else {
        scheduleWalkOverlayAutoHide();
      }
    });

    transformControls.addEventListener('objectChange', () => {
      if (!selectedObject) return;
      const minY = selectedObject.userData && selectedObject.userData.minY !== undefined
        ? selectedObject.userData.minY
        : 0;
      selectedObject.position.y = Math.max(minY, selectedObject.position.y);
      clampAsset(selectedObject);
      selectedObject.userData.baseY = selectedObject.position.y;
      if (selectedObject === assetAnchor) {
        syncAssetLayoutFromAnchor();
      }
    });

    function clampAsset(object) {
      const radius = Math.max(assetSize.x, assetSize.z) / 2;
      object.position.x = clamp(object.position.x, walkBounds.minX + radius, walkBounds.maxX - radius);
      object.position.z = clamp(object.position.z, walkBounds.minZ + radius, walkBounds.maxZ - radius);
      const minY = object.userData && object.userData.minY !== undefined ? object.userData.minY : 0;
      const maxY = walkBounds.maxY - Math.max(0, assetSize.y / 2);
      object.position.y = clamp(object.position.y, minY, maxY);
    }

    function deriveAssetScale(sizeVec) {
      const rawMax = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
      if (!Number.isFinite(rawMax) || rawMax <= 0) {
        return { scale: 1, note: 'Using fallback scale; asset bounding box unavailable.' };
      }

      const heuristics = [
        { threshold: 5000, scale: 0.001, note: 'Converted from millimeters to meters based on bounding box size.' },
        { threshold: 500, scale: 0.01, note: 'Converted from centimeters to meters based on bounding box size.' },
        { threshold: 50, scale: 0.1, note: 'Converted from decimeters to meters based on bounding box size.' }
      ];

      for (const rule of heuristics) {
        if (rawMax >= rule.threshold) {
          return rule;
        }
      }

      if (rawMax < 0.5) {
        const target = 1;
        const scale = clamp(target / Math.max(rawMax, 0.01), 1, 200);
        return { scale, note: 'Auto-scaled small asset to improve visibility inside the room bounds.' };
      }

      return { scale: 1, note: 'Using original model units.' };
    }

    function describeAssetDimensions(sizeVec) {
      const dims = ['x', 'y', 'z'].map(axis => {
        const value = sizeVec[axis];
        if (!Number.isFinite(value)) return '—';
        return value >= 10 ? value.toFixed(1) : value.toFixed(2);
      });
      return `${dims[0]}m × ${dims[1]}m × ${dims[2]}m`;
    }

    function updateAssetButtonsState() {
      if (focusAssetBtn) {
        focusAssetBtn.disabled = !assetLoaded;
      }
      if (resetAssetViewBtn) {
        resetAssetViewBtn.disabled = !assetLoaded;
      }
    }

    function frameAssetView(options = {}) {
      if (!assetLoaded) return;
      pointerControls.unlock();
      setHandMode(false, { silent: true });
      resetMovementState();
      const radius = Math.max(assetSize.x, assetSize.z);
      const height = Math.max(assetSize.y, HUMAN_EYE_HEIGHT_M);
      const distanceMultiplier = clamp(options.distanceMultiplier !== undefined ? options.distanceMultiplier : 2.2, 1.2, 6);
      const elevationMultiplier = clamp(options.elevationMultiplier !== undefined ? options.elevationMultiplier : 0.8, 0.2, 3);
      const azimuthOffset = clamp(options.azimuthOffset !== undefined ? options.azimuthOffset : 0, -radius * 0.75, radius * 0.75);
      const target = assetAnchor.position.clone();
      const distance = Math.max(radius * distanceMultiplier + 0.5, 2.5);
      const offset = new THREE.Vector3(azimuthOffset, height * elevationMultiplier, distance);
      const holder = pointerControls.getObject();
      holder.position.copy(target.clone().add(offset));
      holder.lookAt(target);
      clampCamera();
      camera.position.set(0, 0, 0);
      camera.rotation.set(0, 0, 0);
      updateWalkUi();
      scheduleWalkOverlayAutoHide();
    }

    function resetAssetView() {
      if (!assetLoaded) return;
      frameAssetView({ distanceMultiplier: 2.8, elevationMultiplier: 0.85 });
      setWalkStatus('Camera reset to frame the loaded asset. Enter walk mode to explore again.', 'info');
    }

    function repositionAssetIfNeeded() {
      if (!assetLoaded) return;
      const radius = Math.max(assetSize.x, assetSize.z) / 2;
      const targetX = clamp(0, walkBounds.minX + radius, walkBounds.maxX - radius);
      const targetZ = clamp(0, walkBounds.minZ + radius, walkBounds.maxZ - radius);
      const baseY = assetAnchor.userData && assetAnchor.userData.baseY !== undefined
        ? assetAnchor.userData.baseY
        : assetAnchor.position.y;
      assetAnchor.position.set(targetX, baseY, targetZ);
      clampAsset(assetAnchor);
    }

    function selectObject(object) {
      if (selectedObject === object) return;
      selectedObject = object;
      if (object) {
        transformControls.attach(object);
      } else {
        transformControls.detach();
      }
      updateAssetButtonsState();
    }

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const orbitTarget = new THREE.Vector3(0, HUMAN_EYE_HEIGHT_M, 0);
    let orbitState = null;

    function onPointerDown(event) {
      if (pointerControls.isLocked) return;
      if (event.altKey) return;
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(selectable, true);
      if (hits.length) {
        selectObject(assetAnchor);
      } else {
        selectObject(null);
      }
      scheduleWalkOverlayAutoHide();
    }

    function beginOrbit(event) {
      const holder = pointerControls.getObject();
      const offset = holder.position.clone().sub(orbitTarget);
      const spherical = new THREE.Spherical();
      spherical.setFromVector3(offset);
      orbitState = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        spherical
      };
      if (renderer.domElement.setPointerCapture) {
        renderer.domElement.setPointerCapture(event.pointerId);
      }
    }

    function updateOrbit(event) {
      if (!orbitState) return;
      const deltaX = event.clientX - orbitState.startX;
      const deltaY = event.clientY - orbitState.startY;
      const spherical = orbitState.spherical.clone();
      spherical.theta -= deltaX * 0.005;
      spherical.phi = clamp(spherical.phi + deltaY * 0.003, 0.1, Math.PI - 0.1);
      const radius = Math.max(1.2, spherical.radius);
      spherical.radius = radius;
      const offset = new THREE.Vector3().setFromSpherical(spherical);
      const holder = pointerControls.getObject();
      holder.position.copy(orbitTarget.clone().add(offset));
      holder.lookAt(orbitTarget);
      camera.position.set(0, 0, 0);
      camera.rotation.set(0, 0, 0);
      orbitState.startX = event.clientX;
      orbitState.startY = event.clientY;
      orbitState.spherical = spherical;
    }

    function endOrbit(event) {
      if (!orbitState || orbitState.pointerId !== event.pointerId) return;
      if (renderer.domElement.releasePointerCapture) {
        try {
          renderer.domElement.releasePointerCapture(event.pointerId);
        } catch (err) {}
      }
      orbitState = null;
    }

    function onViewportPointerDown(event) {
      viewportInteracting = true;
      if (pointerControls.isLocked) return;
      if (event.altKey) {
        beginOrbit(event);
        event.preventDefault();
        return;
      }
      onPointerDown(event);
    }

    renderer.domElement.addEventListener('pointerdown', onViewportPointerDown);
    renderer.domElement.addEventListener('pointermove', event => {
      if (orbitState) {
        updateOrbit(event);
      }
    });
    renderer.domElement.addEventListener('pointerup', endOrbit);
    renderer.domElement.addEventListener('pointercancel', endOrbit);

    document.addEventListener('pointerdown', event => {
      viewportInteracting = isViewportNode(event.target);
    }, true);

    function resetLayout(persistOptions = {}) {
      pointerControls.unlock();
      const preset = DEFAULT_ROOM_PRESET();
      layout.room.Wmm = preset.room.W;
      layout.room.Lmm = preset.room.L;
      layout.floor_items = (preset.floor_items || []).map(normalizeFloorItem);
      layout.wall_items = (preset.wall_items || []).map(normalizeWallItem);
      layout.custom_walls = (preset.custom_walls || []).map(normalizeCustomWall);
      layout.doors = (preset.doors || []).map(normalizeDoor);
      layout.cables = (preset.cables || []).map(normalizeCable);
      applyLayout();
      if (assetLoaded) {
        syncAssetLayoutFromAnchor({ persist: false, persistOptions });
      }
      selectObject(null);
      persistLatest(persistOptions);
      if (supportsPointerLock) {
        setWalkStatus('Default layout loaded. Click “Enter Walk Mode” to explore.', 'neutral');
      } else {
        setWalkStatus(POINTER_LOCK_UNSUPPORTED_MESSAGE, 'warn');
      }
    }

    function focusOnAsset() {
      if (!assetLoaded) return;
      frameAssetView({ distanceMultiplier: 2.2, elevationMultiplier: 0.9 });
      setWalkStatus('Framed the loaded asset. Enter walk mode to continue exploring.', 'info');
    }

    enterWalkBtn.addEventListener('click', () => {
      if (!supportsPointerLock) {
        setWalkStatus(POINTER_LOCK_UNSUPPORTED_MESSAGE, 'warn');
        return;
      }
      viewportInteracting = true;
      if (renderer.domElement && typeof renderer.domElement.focus === 'function') {
        try {
          renderer.domElement.focus();
        } catch (err) {
          console.warn('Unable to focus renderer element before pointer lock', err);
        }
      }
      setWalkStatus('Requesting pointer lock…');
      pointerControls.lock();
    });

    resetWalkBtn.addEventListener('click', () => {
      pointerControls.unlock();
      resetWalkPosition();
      setWalkStatus('Walk position reset. Click “Enter Walk Mode” to re-enter.', 'neutral');
    });

    resetLayoutBtn.addEventListener('click', () => {
      resetLayout();
    });

    focusAssetBtn.addEventListener('click', () => focusOnAsset());
    if (resetAssetViewBtn) {
      resetAssetViewBtn.addEventListener('click', () => resetAssetView());
    }

    if (layoutImport) {
      layoutImport.addEventListener('change', async event => {
        const files = event.target && event.target.files;
        const file = files && files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const data = parseLayoutText(text);
          if (!data) throw new Error('layout-file-empty');
          await ingestLayout(data);
        } catch (err) {
          console.error('Failed to parse layout JSON', err);
          if (err && err.cause) {
            console.error('Inner error:', err.cause);
          }
          const code = err && err.message;
          const message = code === 'layout-file-empty'
            ? 'The selected file was empty.'
            : 'Unable to read layout file. Please export again from the 2D survey.';
          alert(message);
        } finally {
          layoutImport.value = '';
        }
      });
    }

    if (loadGltfBtn) {
      loadGltfBtn.addEventListener('click', () => {
        loadSampleAsset().catch(err => {
          console.error('Failed to load sample GLTF asset', err);
        });
      });
    }

    initializeTranslationSnapControls();

    const loader = new GLTFLoader();
    setAssetStatus('No GLTF asset loaded. Click “Load Sample GLTF Asset” to import.', 'neutral');
    updateAssetButtonsState();

    function loadSampleAsset(options = {}) {
      const { fromLayout = null, persistOptions = {} } = options;
      if (!loadGltfBtn) {
        return Promise.resolve(false);
      }
      loadGltfBtn.disabled = true;
      setAssetStatus('Loading sample GLTF asset…', 'info');
      return new Promise((resolve, reject) => {
        loader.load(
          './assets/dozenSidedStack-Body.glb',
          gltf => {
            const root = gltf.scene || (Array.isArray(gltf.scenes) ? gltf.scenes[0] : null);
            if (!root) {
              console.error('GLTF load succeeded but no scene graph was found.', gltf);
              alert('Unable to load the sample GLTF scene. See console for details.');
              loadGltfBtn.disabled = false;
              setAssetStatus('GLTF load succeeded but no scene graph was found.', 'warn');
              resolve(false);
              return;
            }

            root.traverse(node => {
              if (node.isMesh) {
                node.castShadow = false;
                node.receiveShadow = true;
              }
            });

            const bbox = new THREE.Box3().setFromObject(root);
            const center = new THREE.Vector3();
            const size = new THREE.Vector3();
            bbox.getCenter(center);
            bbox.getSize(size);

            const { scale, note } = deriveAssetScale(size);
            root.position.sub(center);
            root.scale.setScalar(scale);
            assetSize = size.clone().multiplyScalar(scale);
            assetAnchor.clear();
            assetAnchor.add(root);
            assetAnchor.visible = true;
            const baseY = assetSize.y / 2;
            assetAnchor.position.set(0, baseY, 0);
            assetAnchor.userData.baseY = baseY;
            assetAnchor.userData.minY = baseY;
            assetAnchor.userData.scale = scale;
            assetAnchor.userData.scaleNote = note;
            assetAnchor.userData.assetRef = SAMPLE_ASSET_REF;
            assetAnchor.userData.assetId = SAMPLE_ASSET_ID;
            selectable.splice(0, selectable.length, assetAnchor);
            assetLoaded = true;
            selectObject(assetAnchor);
            updateAssetButtonsState();
            loadGltfBtn.disabled = false;
            loadGltfBtn.textContent = 'Reload Sample GLTF Asset';
            repositionAssetIfNeeded();
            assetAnchor.updateMatrixWorld(true);
            const dimensionSummary = describeAssetDimensions(assetSize);
            if (fromLayout) {
              applyAssetLayoutEntry(fromLayout, { persist: false, persistOptions });
            } else {
              syncAssetLayoutFromAnchor({ persist: true, persistOptions });
            }
            setAssetStatus(`Loaded GLTF asset (${dimensionSummary}, scale ×${scale.toFixed(scale >= 1 ? 2 : 3)}). ${note}`, 'success');
            console.info('Loaded GLTF asset', {
              dimensions: dimensionSummary,
              scale,
              note,
            });
            resetAssetView();
            resolve(true);
          },
          undefined,
          error => {
            console.error('Failed to load GLTF asset', error);
            alert('Unable to load the sample GLTF file. See console for details.');
            setAssetStatus('Unable to load the sample GLTF file. See console for details.', 'warn');
            loadGltfBtn.disabled = false;
            updateAssetButtonsState();
            reject(error);
          }
        );
      });
    }

    let pendingStorageSync = null;

    async function ingestLayoutFromSerialized(raw, options = {}) {
      try {
        const parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;
        const data = coerceLayoutPayload(parsed);
        if (data) {
          await ingestLayout(data, options);
        }
      } catch (err) {
        console.warn('Failed to ingest layout from storage event', err);
      }
    }

    function handleLayoutStorageEvent(event) {
      if (!event || event.key !== LAYOUT_STORAGE_KEY) return;
      if (event.storageArea && event.storageArea !== window.localStorage) return;
      if (!event.newValue) return;
      if (pendingStorageSync) {
        clearTimeout(pendingStorageSync);
      }
      pendingStorageSync = window.setTimeout(() => {
        pendingStorageSync = null;
        ingestLayoutFromSerialized(event.newValue, { local: false, remote: false });
      }, 80);
    }

    function onWindowResize() {
      updateRendererSize();
    }

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('storage', handleLayoutStorageEvent);

    resetLayout({ local: false, remote: false });
    updateRendererSize();
    scheduleWalkOverlayAutoHide();
    animate();

    (async () => {
      const restored = await restorePersistedLayout({ preferRemote: true });
      if (restored && restored.data) {
        const persistOptions = restored.source === 'server'
          ? { local: true, remote: false }
          : { local: true, remote: true };
        await ingestLayout(restored.data, persistOptions);
      }
    })();
  </script>
</body>
</html>
