<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive 3D Room — First-Person Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../shared/styles/glass_light_theme.css" />
  <link rel="stylesheet" href="../shared/styles/glass_dark_theme.css" />
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: 100vh;
      background: var(--room-ui-bg);
      color: var(--room-ui-text);
      position: relative;
      overflow-x: hidden;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 18% 18%, rgba(96, 165, 250, 0.2), transparent 45%),
                  radial-gradient(circle at 82% 12%, rgba(129, 140, 248, 0.24), transparent 52%);
      opacity: 0.82;
      pointer-events: none;
      z-index: -2;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      gap: 16px;
      border-bottom: 1px solid var(--room-ui-border);
      background: var(--room-ui-surface);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header nav {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    header .subtitle {
      font-size: 13px;
      color: var(--room-ui-muted-strong);
      margin-top: 2px;
    }
    .nav-link {
      color: var(--room-ui-link);
      text-decoration: none;
      font-weight: 600;
      padding: 6px 10px;
      border-radius: 6px;
      transition: background 120ms ease, color 120ms ease;
    }
    .nav-link:hover {
      background: rgba(37, 99, 235, 0.12);
    }
    .nav-link.active {
      background: rgba(37, 99, 235, 0.18);
    }
    main {
      display: grid;
      grid-template-columns: minmax(260px, 340px) 1fr;
      min-height: 0;
      position: relative;
      z-index: 0;
    }
    aside {
      padding: 16px;
      display: grid;
      gap: 16px;
      align-content: start;
      border-right: 1px solid var(--room-ui-border-soft);
      background: var(--room-ui-surface);
    }
    aside h2 {
      margin: 0;
      font-size: 18px;
    }
    aside p {
      margin: 0;
      color: var(--room-ui-muted-strong);
      font-size: 14px;
      line-height: 1.5;
    }
    aside .controls {
      display: grid;
      gap: 8px;
    }
    .controls .control-status {
      font-size: 13px;
      color: var(--room-ui-muted);
      margin: 4px 0 0;
      min-height: 1.2em;
    }
    .controls .control-status[data-tone="warn"] {
      color: #facc15;
    }
    .controls .control-status[data-tone="success"] {
      color: #34d399;
    }
    label {
      display: grid;
      gap: 6px;
      font-weight: 600;
      font-size: 14px;
    }
    input[type="file"] {
      font: inherit;
    }
    button {
      appearance: none;
      font: inherit;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid var(--room-ui-button-border);
      background: linear-gradient(180deg, var(--room-ui-button-bg-top), var(--room-ui-button-bg-bottom));
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px var(--room-ui-shadow);
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .viewport {
      position: relative;
      background: radial-gradient(circle at top, var(--room-ui-viewport-radial), transparent 55%), var(--room-ui-viewport-bg);
      display: flex;
      align-items: stretch;
      justify-content: center;
      min-height: 0;
    }
    #rendererHost {
      flex: 1 1 auto;
      position: relative;
    }
    #rendererHost canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      transition: opacity 160ms ease;
    }
    .overlay.hidden {
      opacity: 0;
    }
    .overlay .card {
      pointer-events: auto;
      background: var(--room-ui-overlay-bg);
      color: var(--room-ui-overlay-text);
      padding: 18px 20px;
      border-radius: 12px;
      max-width: 320px;
      text-align: center;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 40px var(--room-ui-overlay-shadow);
    }
    .overlay h3 {
      margin: 0 0 8px;
      font-size: 18px;
    }
    .overlay p {
      margin: 0;
      font-size: 14px;
      line-height: 1.5;
    }
    .info-box {
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--room-ui-info-border);
      background: var(--room-ui-info-bg);
      font-size: 13px;
      line-height: 1.5;
      color: var(--room-ui-muted-strong);
    }
    .info-box ul {
      margin: 8px 0 0;
      padding-left: 18px;
    }
    .info-box li {
      margin: 4px 0;
    }
    .legend {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--room-ui-legend-text);
    }
    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(15,23,42,0.2);
    }
  </style>
</head>
<body data-room-theme="glass-dark">
  <header>
    <div>
      <strong>3D Room Viewer — First-Person Prototype</strong>
      <div class="subtitle">Walk inside the imported room layout, experiment with the FreeCAD <em>dozenSidedStack</em> sample, and preview placement in 3D.</div>
    </div>
    <nav>
      <a class="nav-link" href="../index.html">Home</a>
      <a class="nav-link" href="../room_survey_min/room_survey_min_v1.html">2D Survey</a>
      <a class="nav-link" href="interactive_3d_room_v1.html">Orbit Viewer</a>
      <a class="nav-link active" href="interactive_3d_room_fps_demo.html">First-Person Demo</a>
      <a class="nav-link" href="../test_objects/mwe_viewer.html">MWE Viewer</a>
    </nav>
  </header>
  <main>
    <aside>
      <div>
        <h2>Workflow</h2>
        <p>Import the JSON exported from the 2D survey, then use first-person controls to explore. The FreeCAD <em>dozenSidedStack</em> sample is included to prove we can load GLTF assets.</p>
      </div>
      <div class="controls">
        <label>Import 2D Layout JSON
          <input id="layoutImport" type="file" accept="application/json" />
        </label>
        <button id="resetLayout">Reset to Default Room</button>
        <button id="load-gltf">Load Sample GLTF Asset</button>
        <button id="focusAsset" disabled>Focus on Sample Asset</button>
      </div>
      <div class="controls">
        <button id="enter-walk">Enter Walk Mode</button>
        <button id="resetWalk">Reset Walk Position</button>
        <p class="control-status" id="walkStatus" aria-live="polite"></p>
      </div>
      <div class="info-box" id="roomInfo"></div>
      <div class="info-box">
        <strong>Controls</strong>
        <ul>
          <li>Click <strong>Enter Walk Mode</strong> to lock the pointer, then use <strong>WASD</strong>, the mouse, <strong>Space</strong> to fly up, and <strong>Shift</strong> to fly down.</li>
          <li>Press <strong>Ctrl</strong> to toggle <strong>Hand Mode</strong>: movement pauses so you can drag gizmos or tap <strong>WASD</strong>/<strong>Space</strong>/<strong>Shift</strong>/<strong>Q</strong>/<strong>E</strong> to nudge or rotate the selected object.</li>
          <li>Hold <strong>Alt</strong> and drag in the viewport (while not walking) to orbit the camera and frame the room before entering.</li>
          <li>Select the sample asset to reveal the move gizmo, then drag the arrows to reposition it anywhere in the room.</li>
        </ul>
      </div>
      <div class="legend">
        <span><span class="swatch" style="background:var(--room-ui-legend-wall)"></span> Walls (default thickness 200&nbsp;mm)</span>
        <span><span class="swatch" style="background:var(--room-ui-legend-custom)"></span> Custom walls</span>
        <span><span class="swatch" style="background:var(--room-ui-legend-door)"></span> Doors (2.1&nbsp;m tall)</span>
        <span><span class="swatch" style="background:var(--room-ui-legend-floor)"></span> Floor items from survey</span>
        <span><span class="swatch" style="background:var(--room-ui-legend-asset)"></span> Loaded GLTF asset</span>
      </div>
    </aside>
    <section class="viewport">
      <div id="rendererHost"></div>
      <div class="overlay" id="walkOverlay">
        <div class="card">
          <h3>Click “Enter Walk Mode”</h3>
          <p>Use <strong>WASD</strong> to move, <strong>mouse</strong> to look, <strong>Space</strong> to rise, and <strong>Shift</strong> to descend. Press <strong>Ctrl</strong> for Hand Mode when you want to adjust objects, and <strong>Alt</strong>+drag (while idle) to orbit.</p>
        </div>
      </div>
    </section>
  </main>

  <script type="module">
    import * as THREE from '../shared/vendor/three/three.module.js';
    import { PointerLockControls } from '../shared/vendor/three/PointerLockControls.js';
    import { TransformControls } from '../shared/vendor/three/TransformControls.js';
    import { GLTFLoader } from '../shared/vendor/three/GLTFLoader.js';

    const mm2m = value => value / 1000;
    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const toNumber = (value, fallback = 0) => {
      const num = Number(value);
      return Number.isFinite(num) ? num : fallback;
    };

    const ROOM_HEIGHT_MM = 2438.4; // 8 ft
    const DEFAULT_WALL_THICKNESS_MM = 200;
    const DOOR_DEFAULT_THICKNESS_MM = 80;
    const DOOR_HEIGHT_MM = 2100;

    const FLOOR_ITEM_META = {
      floorBox: { label: 'Floor Box', wmm: 600, lmm: 600, color: 0x2e6fba, height: 0.5 },
      microscope: { label: 'Microscope', wmm: 2200, lmm: 1800, color: 0x8c5dd8, height: 2.0 },
      table: { label: 'Table', wmm: 1800, lmm: 900, color: 0x3956b5, height: 0.9 },
      pump: { label: 'Pump', wmm: 1200, lmm: 600, color: 0xeb7127, height: 0.8 }
    };

    const HAND_MODE_TOGGLE_KEY = 'Control';
    const HAND_MODE_TRANSLATE_STEP = 0.1;
    const HAND_MODE_VERTICAL_STEP = 0.05;
    const HAND_MODE_ROTATE_STEP = THREE.MathUtils.degToRad(5);
    const WALK_OVERLAY_AUTO_HIDE_MS = 1800;

    const DEFAULT_ROOM_PRESET = () => ({
      room: { W: 6000, L: 8000 },
      floor_items: [
        { type: 'microscope', x: 2200, y: 5200, rotation: 0 },
        { type: 'table', x: 3800, y: 5200, rotation: 0 },
        { type: 'pump', x: 4200, y: 3400, rotation: 0 },
        { type: 'floorBox', x: 3000, y: 3600, rotation: 0 }
      ],
      wall_items: [
        { type: 'socket', wall: 'base:1', s: 1500, h: 300 },
        { type: 'socket', wall: 'base:3', s: 4500, h: 300 }
      ],
      custom_walls: [],
      doors: []
    });

    const layout = {
      room: { Wmm: 6000, Lmm: 8000 },
      floor_items: [],
      wall_items: [],
      custom_walls: [],
      doors: []
    };

    const LAYOUT_STORAGE_KEY = 'room-fps-viewer.latest-layout';

    const rendererHost = document.getElementById('rendererHost');
    const walkOverlay = document.getElementById('walkOverlay');
    const enterWalkBtn = document.getElementById('enter-walk');
    const resetWalkBtn = document.getElementById('resetWalk');
    const layoutImport = document.getElementById('layoutImport');
    const resetLayoutBtn = document.getElementById('resetLayout');
    const loadGltfBtn = document.getElementById('load-gltf');
    const focusAssetBtn = document.getElementById('focusAsset');
    const roomInfo = document.getElementById('roomInfo');
    const walkStatus = document.getElementById('walkStatus');
    const viewportSection = document.querySelector('.viewport');
    const NAVIGATION_KEYS = new Set(['Space', 'ShiftLeft', 'ShiftRight']);
    const INTERACTIVE_TAGS = new Set(['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON']);

    let handMode = false;
    document.body.dataset.handMode = 'off';
    let walkOverlayHideTimer = null;
    let viewportInteracting = false;

    const supportsPointerLock = typeof document !== 'undefined' && 'pointerLockElement' in document;
    const POINTER_LOCK_UNSUPPORTED_MESSAGE = 'Pointer lock is unavailable in this browser. Try a desktop Chromium or Firefox build.';

    function resolveThemeColor(variable, fallback) {
      const styles = getComputedStyle(document.body);
      const value = styles.getPropertyValue(variable);
      return value ? value.trim() : fallback;
    }

    const scene = new THREE.Scene();
    let sceneBgColor = resolveThemeColor('--room-ui-bg', '#0b1120');
    try {
      scene.background = new THREE.Color(sceneBgColor);
    } catch (err) {
      console.warn('Failed to apply theme background color, falling back to default.', err);
      scene.background = new THREE.Color('#0b1120');
    }

    const camera = new THREE.PerspectiveCamera(65, 1, 0.1, 100);
    camera.position.set(0, 1.6, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = false;
    renderer.setClearColor(scene.background);
    rendererHost.appendChild(renderer.domElement);
    renderer.domElement.tabIndex = -1;

    const pointerControls = new PointerLockControls(camera, renderer.domElement);
    const transformControls = new TransformControls(camera, renderer.domElement);
    transformControls.setMode('translate');
    transformControls.showY = true;
    transformControls.setTranslationSnap(0.05);
    scene.add(transformControls);
    scene.add(pointerControls.getObject());

    const ambient = new THREE.AmbientLight(0xf2f5ff, 0.8);
    scene.add(ambient);
    const keyLight = new THREE.DirectionalLight(0xffffff, 0.65);
    keyLight.position.set(4, 6, 3);
    scene.add(keyLight);
    const fillLight = new THREE.DirectionalLight(0xcad6ff, 0.25);
    fillLight.position.set(-5, 3, -2);
    scene.add(fillLight);

    const floorGroup = new THREE.Group();
    const wallGroup = new THREE.Group();
    const doorGroup = new THREE.Group();
    const itemGroup = new THREE.Group();
    const assetAnchor = new THREE.Group();
    assetAnchor.visible = false;
    assetAnchor.name = 'SampleAssetAnchor';
    scene.add(floorGroup);
    scene.add(wallGroup);
    scene.add(doorGroup);
    scene.add(itemGroup);
    scene.add(assetAnchor);

    const selectable = [];
    const clock = new THREE.Clock();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const moveState = { forward: false, back: false, left: false, right: false, up: false, down: false };
    let walkBounds = { minX: -3, maxX: 3, minZ: -4, maxZ: 4, minY: 0.1, maxY: 3.5 };
    let assetLoaded = false;
    let assetSize = new THREE.Vector3(1, 1, 1);
    let selectedObject = null;

    function resetMovementState() {
      moveState.forward = false;
      moveState.back = false;
      moveState.left = false;
      moveState.right = false;
      moveState.up = false;
      moveState.down = false;
      velocity.set(0, 0, 0);
      direction.set(0, 0, 0);
    }

    function setWalkStatus(message, tone = 'neutral') {
      if (!walkStatus) return;
      walkStatus.textContent = message;
      walkStatus.dataset.tone = tone;
    }

    function showWalkOverlay() {
      if (!walkOverlay) return;
      walkOverlay.classList.remove('hidden');
    }

    function hideWalkOverlay() {
      if (!walkOverlay) return;
      walkOverlay.classList.add('hidden');
      if (walkOverlayHideTimer) {
        clearTimeout(walkOverlayHideTimer);
        walkOverlayHideTimer = null;
      }
    }

    function scheduleWalkOverlayAutoHide() {
      if (!walkOverlay) return;
      if (walkOverlayHideTimer) {
        clearTimeout(walkOverlayHideTimer);
      }
      walkOverlayHideTimer = window.setTimeout(() => {
        hideWalkOverlay();
      }, WALK_OVERLAY_AUTO_HIDE_MS);
    }

    function isEditableTarget(target) {
      if (!(target instanceof HTMLElement)) return false;
      if (target.isContentEditable) return true;
      if (INTERACTIVE_TAGS.has(target.tagName)) return true;
      return Boolean(
        target.closest('input, textarea, select, [contenteditable="true"]')
      );
    }

    function isViewportNode(node) {
      return viewportSection instanceof HTMLElement && node instanceof Node
        ? viewportSection.contains(node)
        : false;
    }

    function shouldTrapNavigationKey(event) {
      if (pointerControls.isLocked || handMode) return true;
      if (!viewportInteracting) return false;
      const target = event.target;
      if (isViewportNode(target)) return true;
      return target === document.body || target === document.documentElement;
    }

    function maybePreventNavigationKey(event) {
      if (!NAVIGATION_KEYS.has(event.code)) return false;
      if (event.defaultPrevented) return false;
      if (isEditableTarget(event.target)) return false;
      if (!shouldTrapNavigationKey(event)) return false;
      event.preventDefault();
      return true;
    }

    function updateWalkUi() {
      const locked = pointerControls.isLocked;
      if (enterWalkBtn) enterWalkBtn.disabled = locked || !supportsPointerLock || handMode;
      if (resetWalkBtn) resetWalkBtn.disabled = false;
    }

    function setHandMode(active, options = {}) {
      const { silent = false, showOverlay = false } = options;
      if (handMode === active) {
        if (!handMode) {
          if (showOverlay) {
            scheduleWalkOverlayAutoHide();
          } else {
            hideWalkOverlay();
          }
        }
        return;
      }
      handMode = active;
      viewportInteracting = handMode;
      document.body.dataset.handMode = handMode ? 'on' : 'off';
      if (handMode) {
        if (pointerControls.isLocked) {
          pointerControls.unlock();
        }
        resetMovementState();
        if (showOverlay) {
          showWalkOverlay();
          scheduleWalkOverlayAutoHide();
        } else {
          hideWalkOverlay();
        }
        if (!silent) {
          setWalkStatus('Hand Mode active — drag gizmos or tap WASDQE/Space/Shift to adjust the selected object.', 'info');
        }
      } else {
        if (!silent) {
          setWalkStatus('Hand Mode off. Click “Enter Walk Mode” to explore.', 'neutral');
        }
        if (showOverlay) {
          scheduleWalkOverlayAutoHide();
        } else {
          hideWalkOverlay();
        }
      }
      updateWalkUi();
    }

    function adjustSelectedObjectFromHandMode(event) {
      if (!handMode || !selectedObject) return false;
      const fastMultiplier = event.altKey ? 5 : 1;
      const step = HAND_MODE_TRANSLATE_STEP * fastMultiplier;
      const verticalStep = HAND_MODE_VERTICAL_STEP * fastMultiplier;
      const rotateStep = HAND_MODE_ROTATE_STEP * fastMultiplier;
      let handled = false;
      switch (event.code) {
        case 'KeyW':
          selectedObject.position.z -= step;
          handled = true;
          break;
        case 'KeyS':
          selectedObject.position.z += step;
          handled = true;
          break;
        case 'KeyA':
          selectedObject.position.x -= step;
          handled = true;
          break;
        case 'KeyD':
          selectedObject.position.x += step;
          handled = true;
          break;
        case 'Space':
          selectedObject.position.y += verticalStep;
          handled = true;
          break;
        case 'ShiftLeft':
        case 'ShiftRight':
          selectedObject.position.y -= verticalStep;
          handled = true;
          break;
        case 'KeyQ':
          selectedObject.rotation.y += rotateStep;
          handled = true;
          break;
        case 'KeyE':
          selectedObject.rotation.y -= rotateStep;
          handled = true;
          break;
      }
      if (handled) {
        clampAsset(selectedObject);
        selectedObject.userData.baseY = selectedObject.position.y;
        scheduleWalkOverlayAutoHide();
      }
      return handled;
    }

    function updateRendererSize() {
      const { clientWidth, clientHeight } = rendererHost;
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / Math.max(1, clientHeight);
      camera.updateProjectionMatrix();
    }

    function baseWallDefinitions() {
      const W = layout.room.Wmm;
      const L = layout.room.Lmm;
      const t = DEFAULT_WALL_THICKNESS_MM;
      return [
        { ref: 'base:1', label: 'Wall 1 (y=0)', start: { x: 0, y: 0 }, end: { x: W, y: 0 }, thickness: t },
        { ref: 'base:2', label: 'Wall 2 (x=W)', start: { x: W, y: 0 }, end: { x: W, y: L }, thickness: t },
        { ref: 'base:3', label: 'Wall 3 (y=L)', start: { x: W, y: L }, end: { x: 0, y: L }, thickness: t },
        { ref: 'base:4', label: 'Wall 4 (x=0)', start: { x: 0, y: L }, end: { x: 0, y: 0 }, thickness: t }
      ];
    }

    function enrichWallGeometry(wall) {
      const dx = wall.end.x - wall.start.x;
      const dy = wall.end.y - wall.start.y;
      const length = Math.hypot(dx, dy);
      if (length < 1e-6) return null;
      const tangent = { x: dx / length, y: dy / length };
      const normal = { x: -tangent.y, y: tangent.x };
      return { ...wall, length, tangent, normal };
    }

    function getCustomWall(ref) {
      const id = ref.split(':')[1];
      return layout.custom_walls.find(w => String(w.id) === id);
    }

    function getWallGeometry(ref) {
      if (ref === undefined || ref === null) return null;
      let normalized = ref;
      if (typeof normalized === 'number') normalized = `base:${normalized}`;
      normalized = String(normalized);
      if (/^\d$/.test(normalized)) normalized = `base:${normalized}`;
      if (normalized.startsWith('base:')) {
        const wall = baseWallDefinitions().find(w => w.ref === normalized);
        return wall ? enrichWallGeometry(wall) : null;
      }
      if (normalized.startsWith('custom:')) {
        const wall = getCustomWall(normalized);
        if (!wall) return null;
        return enrichWallGeometry({
          ref: normalized,
          label: wall.name || 'Custom Wall',
          start: { x: toNumber(wall.x1, 0), y: toNumber(wall.y1, 0) },
          end: { x: toNumber(wall.x2, 0), y: toNumber(wall.y2, 0) },
          thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM) }
        );
      }
      return null;
    }

    function pointAlongWall(geom, offsetMm) {
      const distance = clamp(offsetMm, 0, geom.length);
      return {
        x: geom.start.x + geom.tangent.x * distance,
        y: geom.start.y + geom.tangent.y * distance
      };
    }

    function normalizeFloorItem(item) {
      const type = item.type || 'floorBox';
      const meta = FLOOR_ITEM_META[type] || FLOOR_ITEM_META.floorBox;
      return {
        ...item,
        type,
        id: item.id,
        x: toNumber(item.x, layout.room.Wmm / 2),
        y: toNumber(item.y, layout.room.Lmm / 2),
        w: toNumber(item.w !== undefined ? item.w : item.size, meta.wmm),
        l: toNumber(item.l !== undefined ? item.l : item.size, meta.lmm),
        rotation: toNumber(item.rotation, 0)
      };
    }

    function normalizeWallItem(item) {
      let wallRef = item.wall;
      if (typeof wallRef === 'number') wallRef = `base:${wallRef}`;
      if (typeof wallRef === 'string' && /^\d$/.test(wallRef)) wallRef = `base:${wallRef}`;
      return {
        ...item,
        wall: wallRef || 'base:1',
        s: toNumber(item.s, 0),
        h: toNumber(item.h, 0)
      };
    }

    function normalizeCustomWall(wall, idx) {
      return {
        ...wall,
        id: wall.id !== undefined ? String(wall.id) : `cw_${idx}`,
        x1: toNumber(wall.x1, 0),
        y1: toNumber(wall.y1, 0),
        x2: toNumber(wall.x2, 0),
        y2: toNumber(wall.y2, 0),
        thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM),
        name: wall.name
      };
    }

    function normalizeDoor(door, idx) {
      let wallRef = door.wall;
      if (typeof wallRef === 'number') wallRef = `base:${wallRef}`;
      if (typeof wallRef === 'string' && /^\d$/.test(wallRef)) wallRef = `base:${wallRef}`;
      return {
        ...door,
        id: door.id !== undefined ? String(door.id) : `door_${idx}`,
        wall: wallRef || 'base:1',
        offset: toNumber(door.offset, 0),
        width: toNumber(door.width, 900),
        thickness: toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM)
      };
    }

    function coerceLayoutPayload(raw) {
      if (!raw || typeof raw !== 'object') return null;
      if (raw.layout && typeof raw.layout === 'object') return raw.layout;
      return raw;
    }

    function parseLayoutText(rawText) {
      if (typeof rawText !== 'string') {
        throw new Error('layout-file-empty');
      }
      const sanitized = rawText
        .replace(/^\uFEFF/, '')
        .replace(/\u0000/g, '')
        .trim();
      if (!sanitized) {
        throw new Error('layout-file-empty');
      }
      try {
        return coerceLayoutPayload(JSON.parse(sanitized));
      } catch (err) {
        const error = new Error('layout-file-invalid');
        error.cause = err;
        error.raw = sanitized.slice(0, 1200);
        throw error;
      }
    }

    function persistLayoutLocal(data) {
      try {
        if (window.localStorage) {
          window.localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(data));
        }
      } catch (err) {
        console.warn('Failed to persist layout locally', err);
      }
    }

    function loadLayoutLocal() {
      try {
        if (!window.localStorage) return null;
        const raw = window.localStorage.getItem(LAYOUT_STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (err) {
        console.warn('Failed to load layout from local storage', err);
        return null;
      }
    }

    async function saveLayoutRemote(data) {
      try {
        const resp = await fetch('/api/layout', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        if (!resp.ok) throw new Error(await resp.text());
        return true;
      } catch (err) {
        console.warn('Failed to save layout to server', err);
        return false;
      }
    }

    async function loadLayoutRemote() {
      try {
        const resp = await fetch('/api/layout', {
          method: 'GET',
          headers: { Accept: 'application/json' },
          cache: 'no-store'
        });
        if (!resp.ok) {
          if (resp.status === 404) return null;
          throw new Error(await resp.text());
        }
        const text = await resp.text();
        if (!text) return null;
        const payload = JSON.parse(text);
        if (payload && typeof payload === 'object' && payload.layout !== undefined) {
          return payload.layout;
        }
        if (payload && typeof payload === 'object') {
          return payload;
        }
        return null;
      } catch (err) {
        console.warn('Failed to load layout from server', err);
        return null;
      }
    }

    async function restorePersistedLayout(options = {}) {
      const { preferRemote = false } = options;
      const order = preferRemote ? ['remote', 'local'] : ['local', 'remote'];
      for (const source of order) {
        if (source === 'local') {
          const local = loadLayoutLocal();
          if (local) return { data: local, source: 'local' };
        } else {
          const remote = await loadLayoutRemote();
          if (remote) return { data: remote, source: 'server' };
        }
      }
      return null;
    }

    function snapshotLayout() {
      ensureLayoutIds();
      return {
        room: {
          W: toNumber(layout.room.Wmm, 6000),
          L: toNumber(layout.room.Lmm, 8000)
        },
        floor_items: (layout.floor_items || []).map(item => {
          const meta = FLOOR_ITEM_META[item.type] || FLOOR_ITEM_META.floorBox;
          return {
            id: item.id,
            type: item.type,
            x: toNumber(item.x, layout.room.Wmm / 2),
            y: toNumber(item.y, layout.room.Lmm / 2),
            w: toNumber(item.w, meta.wmm),
            l: toNumber(item.l, meta.lmm),
            rotation: toNumber(item.rotation, 0)
          };
        }),
        wall_items: (layout.wall_items || []).map(item => ({
          id: item.id,
          type: item.type,
          wall: item.wall,
          s: toNumber(item.s, 0),
          h: toNumber(item.h, 0)
        })),
        custom_walls: (layout.custom_walls || []).map(wall => ({
          id: wall.id,
          name: wall.name,
          x1: toNumber(wall.x1, 0),
          y1: toNumber(wall.y1, 0),
          x2: toNumber(wall.x2, 0),
          y2: toNumber(wall.y2, 0),
          thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM)
        })),
        doors: (layout.doors || []).map(door => ({
          id: door.id,
          wall: door.wall,
          offset: toNumber(door.offset, 0),
          width: toNumber(door.width, 900),
          thickness: toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM)
        }))
      };
    }

    function persistLatest(options = {}) {
      const { local = true, remote = true } = options;
      const snapshot = snapshotLayout();
      if (local) persistLayoutLocal(snapshot);
      if (remote) saveLayoutRemote(snapshot);
    }

    function ensureLayoutIds() {
      layout.custom_walls = (layout.custom_walls || []).map(normalizeCustomWall);
      layout.doors = (layout.doors || []).map(normalizeDoor);
      layout.floor_items = (layout.floor_items || []).map(normalizeFloorItem);
      layout.wall_items = (layout.wall_items || []).map(normalizeWallItem);
    }

    function ingestLayout(data, persistOptions = {}) {
      if (data.room) {
        const roomW = data.room.W !== undefined ? data.room.W : data.room.Wmm;
        const roomL = data.room.L !== undefined ? data.room.L : data.room.Lmm;
        layout.room.Wmm = toNumber(roomW, layout.room.Wmm);
        layout.room.Lmm = toNumber(roomL, layout.room.Lmm);
      }
      if (Array.isArray(data.floor_items)) {
        layout.floor_items = data.floor_items.map(normalizeFloorItem);
      } else if (Array.isArray(data.items)) {
        const floor = data.items.filter(it => it.type !== 'socket').map(normalizeFloorItem);
        const wallItems = data.items.filter(it => it.type === 'socket').map(normalizeWallItem);
        layout.floor_items = floor;
        layout.wall_items = wallItems;
      }
      if (Array.isArray(data.wall_items)) {
        layout.wall_items = data.wall_items.map(normalizeWallItem);
      }
      if (Array.isArray(data.custom_walls)) {
        layout.custom_walls = data.custom_walls.map(normalizeCustomWall);
      }
      if (Array.isArray(data.doors)) {
        layout.doors = data.doors.map(normalizeDoor);
      }
      ensureLayoutIds();
      applyLayout();
      selectObject(null);
      persistLatest(persistOptions);
      if (supportsPointerLock) {
        setWalkStatus('Layout imported. Click “Enter Walk Mode” to explore.', 'neutral');
      } else {
        setWalkStatus(POINTER_LOCK_UNSUPPORTED_MESSAGE, 'warn');
      }
    }

    function mmPointToWorld(xMm, yMm) {
      const x = mm2m(xMm - layout.room.Wmm / 2);
      const z = mm2m(yMm - layout.room.Lmm / 2);
      return new THREE.Vector3(x, 0, z);
    }

    function clearGroup(group) {
      for (let i = group.children.length - 1; i >= 0; i -= 1) {
        const child = group.children[i];
        group.remove(child);
        if (child.geometry && typeof child.geometry.dispose === 'function') {
          child.geometry.dispose();
        }
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(m => {
              if (m && typeof m.dispose === 'function') m.dispose();
            });
          } else if (typeof child.material.dispose === 'function') {
            child.material.dispose();
          }
        }
      }
    }

    function buildFloorAndBounds() {
      clearGroup(floorGroup);
      const floorW = mm2m(layout.room.Wmm);
      const floorL = mm2m(layout.room.Lmm);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xf1f3f9, roughness: 0.9, metalness: 0.05 });
      const floorGeo = new THREE.PlaneGeometry(floorW, floorL, 1, 1);
      const floorMesh = new THREE.Mesh(floorGeo, floorMat);
      floorMesh.rotation.x = -Math.PI / 2;
      floorMesh.position.set(0, 0, 0);
      floorGroup.add(floorMesh);

      const grid = new THREE.GridHelper(Math.max(floorW, floorL) + 2, Math.round(Math.max(floorW, floorL)));
      grid.material.opacity = 0.25;
      grid.material.transparent = true;
      grid.position.y = 0.002;
      floorGroup.add(grid);

      const minX = -floorW / 2 + 0.25;
      const maxX = floorW / 2 - 0.25;
      const minZ = -floorL / 2 + 0.25;
      const maxZ = floorL / 2 - 0.25;
      walkBounds = { minX, maxX, minZ, maxZ, minY: 0.1, maxY: mm2m(ROOM_HEIGHT_MM) - 0.2 };
      const midHeight = (walkBounds.maxY + walkBounds.minY) / 2;
      orbitTarget.set(0, midHeight, 0);
    }

    function buildWalls() {
      clearGroup(wallGroup);
      const height = mm2m(ROOM_HEIGHT_MM);

      const defaultMat = new THREE.MeshStandardMaterial({ color: 0xd4d8e5, roughness: 0.55, metalness: 0.05 });
      baseWallDefinitions().forEach(def => {
        const geom = enrichWallGeometry(def);
        if (!geom) return;
        const thickness = mm2m(geom.thickness || DEFAULT_WALL_THICKNESS_MM);
        const length = mm2m(geom.length);
        const box = new THREE.BoxGeometry(length, height, thickness);
        const mesh = new THREE.Mesh(box, defaultMat.clone());
        const centerMm = pointAlongWall(geom, geom.length / 2);
        const offsetMm = {
          x: centerMm.x + geom.normal.x * (geom.thickness / 2),
          y: centerMm.y + geom.normal.y * (geom.thickness / 2)
        };
        const world = mmPointToWorld(offsetMm.x, offsetMm.y);
        mesh.position.set(world.x, height / 2, world.z);
        const angle = Math.atan2(geom.tangent.y, geom.tangent.x);
        mesh.rotation.y = -angle;
        wallGroup.add(mesh);
      });

      const customMat = new THREE.MeshStandardMaterial({ color: 0xb49a7a, roughness: 0.6, metalness: 0.08 });
      (layout.custom_walls || []).forEach(def => {
        const geom = getWallGeometry(`custom:${def.id}`);
        if (!geom) return;
        const thickness = mm2m(geom.thickness || DEFAULT_WALL_THICKNESS_MM);
        const length = mm2m(geom.length);
        const box = new THREE.BoxGeometry(length, height, thickness);
        const mesh = new THREE.Mesh(box, customMat.clone());
        const centerMm = pointAlongWall(geom, geom.length / 2);
        const offsetMm = {
          x: centerMm.x + geom.normal.x * (geom.thickness / 2),
          y: centerMm.y + geom.normal.y * (geom.thickness / 2)
        };
        const world = mmPointToWorld(offsetMm.x, offsetMm.y);
        mesh.position.set(world.x, height / 2, world.z);
        const angle = Math.atan2(geom.tangent.y, geom.tangent.x);
        mesh.rotation.y = -angle;
        wallGroup.add(mesh);
      });
    }

    function buildDoors() {
      clearGroup(doorGroup);
      const height = mm2m(DOOR_HEIGHT_MM);
      const mat = new THREE.MeshStandardMaterial({ color: 0x3b8d46, roughness: 0.4, metalness: 0.05 });
      (layout.doors || []).forEach(door => {
        const geom = getWallGeometry(door.wall);
        if (!geom) return;
        const widthMm = toNumber(door.width, 900);
        const width = mm2m(widthMm);
        const thicknessMm = toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM);
        const thickness = mm2m(thicknessMm);
        const box = new THREE.BoxGeometry(width, height, thickness);
        const mesh = new THREE.Mesh(box, mat.clone());
        const centerOffset = toNumber(door.offset, 0) + widthMm / 2;
        const centerMm = pointAlongWall(geom, centerOffset);
        const offsetMm = {
          x: centerMm.x + geom.normal.x * (thicknessMm / 2),
          y: centerMm.y + geom.normal.y * (thicknessMm / 2)
        };
        const world = mmPointToWorld(offsetMm.x, offsetMm.y);
        mesh.position.set(world.x, height / 2, world.z);
        const angle = Math.atan2(geom.tangent.y, geom.tangent.x);
        mesh.rotation.y = -angle;
        doorGroup.add(mesh);
      });
    }

    function buildItems() {
      clearGroup(itemGroup);
      (layout.floor_items || []).forEach(item => {
        const meta = FLOOR_ITEM_META[item.type] || FLOOR_ITEM_META.floorBox;
        const w = mm2m(toNumber(item.w, meta.wmm));
        const l = mm2m(toNumber(item.l, meta.lmm));
        const h = meta.height !== undefined ? meta.height : 1.0;
        const geometry = new THREE.BoxGeometry(w, h, l);
        const material = new THREE.MeshStandardMaterial({ color: meta.color, roughness: 0.45, metalness: 0.1 });
        const mesh = new THREE.Mesh(geometry, material);
        const world = mmPointToWorld(toNumber(item.x, layout.room.Wmm / 2), toNumber(item.y, layout.room.Lmm / 2));
        mesh.position.set(world.x, h / 2, world.z);
        const rot = THREE.MathUtils.degToRad(toNumber(item.rotation, 0));
        if (rot) mesh.rotation.y = -rot;
        itemGroup.add(mesh);
      });
    }

    function updateRoomInfo() {
      const Wm = (layout.room.Wmm / 1000).toFixed(2);
      const Lm = (layout.room.Lmm / 1000).toFixed(2);
      const heightM = (ROOM_HEIGHT_MM / 1000).toFixed(2);
      const customCount = layout.custom_walls && layout.custom_walls.length ? layout.custom_walls.length : 0;
      const doorCount = layout.doors && layout.doors.length ? layout.doors.length : 0;
      const itemCount = layout.floor_items && layout.floor_items.length ? layout.floor_items.length : 0;
      roomInfo.innerHTML = `Room: <strong>${Wm}m × ${Lm}m</strong> &middot; Height ${heightM}m<br>` +
        `${customCount} custom wall${customCount === 1 ? '' : 's'}, ${doorCount} door${doorCount === 1 ? '' : 's'}, ${itemCount} floor item${itemCount === 1 ? '' : 's'}`;
    }

    function applyLayout() {
      ensureLayoutIds();
      buildFloorAndBounds();
      buildWalls();
      buildDoors();
      buildItems();
      repositionAssetIfNeeded();
      updateRoomInfo();
      resetWalkPosition();
      pointerControls.unlock();
      resetMovementState();
      updateWalkUi();
    }

    function resetWalkPosition() {
      const cameraHolder = pointerControls.getObject();
      setHandMode(false, { silent: true });
      resetMovementState();
      cameraHolder.position.set(walkBounds.minX + 0.6, 1.6, walkBounds.minZ + 1.2);
      cameraHolder.rotation.set(0, 0, 0);
      camera.position.set(0, 0, 0);
      camera.rotation.set(0, 0, 0);
      updateWalkUi();
    }

    function clampCamera() {
      const pos = pointerControls.getObject().position;
      pos.x = clamp(pos.x, walkBounds.minX, walkBounds.maxX);
      pos.z = clamp(pos.z, walkBounds.minZ, walkBounds.maxZ);
      pos.y = clamp(pos.y, walkBounds.minY, walkBounds.maxY);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (pointerControls.isLocked) {
        const speed = 3.5;
        velocity.x -= velocity.x * 10 * delta;
        velocity.y -= velocity.y * 10 * delta;
        velocity.z -= velocity.z * 10 * delta;

        direction.z = Number(moveState.forward) - Number(moveState.back);
        direction.x = Number(moveState.right) - Number(moveState.left);
        direction.y = Number(moveState.up) - Number(moveState.down);
        direction.normalize();

        if (moveState.forward || moveState.back) velocity.z -= direction.z * speed * delta;
        if (moveState.left || moveState.right) velocity.x -= direction.x * speed * delta;
        if (moveState.up || moveState.down) velocity.y += direction.y * speed * delta;

        pointerControls.moveRight(-velocity.x * delta);
        pointerControls.moveForward(-velocity.z * delta);
        pointerControls.getObject().position.y += velocity.y * delta;
        clampCamera();
      }
      renderer.render(scene, camera);
    }

    function onKeyDown(event) {
      if (event.key === HAND_MODE_TOGGLE_KEY) {
        if (!event.repeat) {
          setHandMode(!handMode);
        }
        event.preventDefault();
        return;
      }

      maybePreventNavigationKey(event);

      if (handMode) {
        if (adjustSelectedObjectFromHandMode(event)) {
          event.preventDefault();
        }
        return;
      }

      if (!pointerControls.isLocked) return;

      switch (event.code) {
        case 'KeyW':
          moveState.forward = true;
          break;
        case 'KeyS':
          moveState.back = true;
          break;
        case 'KeyA':
          moveState.left = true;
          break;
        case 'KeyD':
          moveState.right = true;
          break;
        case 'Space':
          moveState.up = true;
          event.preventDefault();
          break;
        case 'ShiftLeft':
        case 'ShiftRight':
          moveState.down = true;
          event.preventDefault();
          break;
      }
    }
    function onKeyUp(event) {
      maybePreventNavigationKey(event);
      if (handMode) {
        if (event.code === 'Space' || event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
          event.preventDefault();
        }
        return;
      }

      if (!pointerControls.isLocked) return;

      switch (event.code) {
        case 'KeyW':
          moveState.forward = false;
          break;
        case 'KeyS':
          moveState.back = false;
          break;
        case 'KeyA':
          moveState.left = false;
          break;
        case 'KeyD':
          moveState.right = false;
          break;
        case 'Space':
          moveState.up = false;
          event.preventDefault();
          break;
        case 'ShiftLeft':
        case 'ShiftRight':
          moveState.down = false;
          event.preventDefault();
          break;
      }
    }

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    pointerControls.addEventListener('lock', () => {
      viewportInteracting = true;
      hideWalkOverlay();
      if (handMode) {
        setHandMode(false, { silent: true });
      }
      if (walkOverlayHideTimer) {
        clearTimeout(walkOverlayHideTimer);
        walkOverlayHideTimer = null;
      }
      resetMovementState();
      updateWalkUi();
      setWalkStatus('Walk mode active — use WASD and your mouse to move. Press Esc to exit.', 'success');
    });
    pointerControls.addEventListener('unlock', () => {
      viewportInteracting = handMode;
      resetMovementState();
      updateWalkUi();
      if (handMode) {
        hideWalkOverlay();
        setWalkStatus('Hand Mode active — drag gizmos or tap WASDQE/Space/Shift to adjust the selected object.', 'info');
      } else {
        showWalkOverlay();
        scheduleWalkOverlayAutoHide();
        setWalkStatus('Walk mode exited. Click “Enter Walk Mode” to continue exploring.', 'neutral');
      }
    });

    document.addEventListener('pointerlockerror', event => {
      console.warn('Pointer lock request failed', event);
      viewportInteracting = true;
      showWalkOverlay();
      scheduleWalkOverlayAutoHide();
      resetMovementState();
      updateWalkUi();
      setWalkStatus('Pointer lock was blocked. Click inside the viewport first or open this demo in a standalone tab.', 'warn');
    });

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        resetMovementState();
      }
    });

    transformControls.addEventListener('dragging-changed', event => {
      if (event.value) {
        pointerControls.unlock();
        setHandMode(true, { silent: true });
      } else {
        scheduleWalkOverlayAutoHide();
      }
    });

    transformControls.addEventListener('objectChange', () => {
      if (!selectedObject) return;
      const minY = selectedObject.userData && selectedObject.userData.minY !== undefined
        ? selectedObject.userData.minY
        : 0;
      selectedObject.position.y = Math.max(minY, selectedObject.position.y);
      clampAsset(selectedObject);
      selectedObject.userData.baseY = selectedObject.position.y;
    });

    function clampAsset(object) {
      const radius = Math.max(assetSize.x, assetSize.z) / 2;
      object.position.x = clamp(object.position.x, walkBounds.minX + radius, walkBounds.maxX - radius);
      object.position.z = clamp(object.position.z, walkBounds.minZ + radius, walkBounds.maxZ - radius);
      const minY = object.userData && object.userData.minY !== undefined ? object.userData.minY : 0;
      const maxY = walkBounds.maxY - Math.max(0, assetSize.y / 2);
      object.position.y = clamp(object.position.y, minY, maxY);
    }

    function repositionAssetIfNeeded() {
      if (!assetLoaded) return;
      const radius = Math.max(assetSize.x, assetSize.z) / 2;
      const targetX = clamp(0, walkBounds.minX + radius, walkBounds.maxX - radius);
      const targetZ = clamp(0, walkBounds.minZ + radius, walkBounds.maxZ - radius);
      const baseY = assetAnchor.userData && assetAnchor.userData.baseY !== undefined
        ? assetAnchor.userData.baseY
        : assetAnchor.position.y;
      assetAnchor.position.set(targetX, baseY, targetZ);
      clampAsset(assetAnchor);
    }

    function selectObject(object) {
      if (selectedObject === object) return;
      selectedObject = object;
      if (object) {
        transformControls.attach(object);
      } else {
        transformControls.detach();
      }
      focusAssetBtn.disabled = !assetLoaded;
    }

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const orbitTarget = new THREE.Vector3(0, 1.6, 0);
    let orbitState = null;

    function onPointerDown(event) {
      if (pointerControls.isLocked) return;
      if (event.altKey) return;
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(selectable, true);
      if (hits.length) {
        selectObject(assetAnchor);
      } else {
        selectObject(null);
      }
      scheduleWalkOverlayAutoHide();
    }

    function beginOrbit(event) {
      const holder = pointerControls.getObject();
      const offset = holder.position.clone().sub(orbitTarget);
      const spherical = new THREE.Spherical();
      spherical.setFromVector3(offset);
      orbitState = {
        pointerId: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        spherical
      };
      if (renderer.domElement.setPointerCapture) {
        renderer.domElement.setPointerCapture(event.pointerId);
      }
    }

    function updateOrbit(event) {
      if (!orbitState) return;
      const deltaX = event.clientX - orbitState.startX;
      const deltaY = event.clientY - orbitState.startY;
      const spherical = orbitState.spherical.clone();
      spherical.theta -= deltaX * 0.005;
      spherical.phi = clamp(spherical.phi + deltaY * 0.003, 0.1, Math.PI - 0.1);
      const radius = Math.max(1.2, spherical.radius);
      spherical.radius = radius;
      const offset = new THREE.Vector3().setFromSpherical(spherical);
      const holder = pointerControls.getObject();
      holder.position.copy(orbitTarget.clone().add(offset));
      holder.lookAt(orbitTarget);
      camera.position.set(0, 0, 0);
      camera.rotation.set(0, 0, 0);
      orbitState.startX = event.clientX;
      orbitState.startY = event.clientY;
      orbitState.spherical = spherical;
    }

    function endOrbit(event) {
      if (!orbitState || orbitState.pointerId !== event.pointerId) return;
      if (renderer.domElement.releasePointerCapture) {
        try {
          renderer.domElement.releasePointerCapture(event.pointerId);
        } catch (err) {}
      }
      orbitState = null;
    }

    function onViewportPointerDown(event) {
      viewportInteracting = true;
      if (pointerControls.isLocked) return;
      if (event.altKey) {
        beginOrbit(event);
        event.preventDefault();
        return;
      }
      onPointerDown(event);
    }

    renderer.domElement.addEventListener('pointerdown', onViewportPointerDown);
    renderer.domElement.addEventListener('pointermove', event => {
      if (orbitState) {
        updateOrbit(event);
      }
    });
    renderer.domElement.addEventListener('pointerup', endOrbit);
    renderer.domElement.addEventListener('pointercancel', endOrbit);

    document.addEventListener('pointerdown', event => {
      viewportInteracting = isViewportNode(event.target);
    }, true);

    function resetLayout(persistOptions = {}) {
      pointerControls.unlock();
      const preset = DEFAULT_ROOM_PRESET();
      layout.room.Wmm = preset.room.W;
      layout.room.Lmm = preset.room.L;
      layout.floor_items = (preset.floor_items || []).map(normalizeFloorItem);
      layout.wall_items = (preset.wall_items || []).map(normalizeWallItem);
      layout.custom_walls = (preset.custom_walls || []).map(normalizeCustomWall);
      layout.doors = (preset.doors || []).map(normalizeDoor);
      applyLayout();
      selectObject(null);
      persistLatest(persistOptions);
      if (supportsPointerLock) {
        setWalkStatus('Default layout loaded. Click “Enter Walk Mode” to explore.', 'neutral');
      } else {
        setWalkStatus(POINTER_LOCK_UNSUPPORTED_MESSAGE, 'warn');
      }
    }

    function focusOnAsset() {
      if (!assetLoaded) return;
      pointerControls.unlock();
      const radius = Math.max(assetSize.x, assetSize.z);
      const target = assetAnchor.position.clone();
      const offset = new THREE.Vector3(0, radius * 1.2 + assetSize.y, radius * 1.8 + 1.5);
      const holder = pointerControls.getObject();
      holder.position.copy(target.clone().add(offset));
      holder.lookAt(target);
      camera.position.set(0, 0, 0);
      camera.rotation.set(0, 0, 0);
    }

    enterWalkBtn.addEventListener('click', () => {
      if (!supportsPointerLock) {
        setWalkStatus(POINTER_LOCK_UNSUPPORTED_MESSAGE, 'warn');
        return;
      }
      viewportInteracting = true;
      if (renderer.domElement && typeof renderer.domElement.focus === 'function') {
        try {
          renderer.domElement.focus();
        } catch (err) {
          console.warn('Unable to focus renderer element before pointer lock', err);
        }
      }
      setWalkStatus('Requesting pointer lock…');
      pointerControls.lock();
    });

    resetWalkBtn.addEventListener('click', () => {
      pointerControls.unlock();
      resetWalkPosition();
      setWalkStatus('Walk position reset. Click “Enter Walk Mode” to re-enter.', 'neutral');
    });

    resetLayoutBtn.addEventListener('click', () => {
      resetLayout();
    });

    focusAssetBtn.addEventListener('click', () => focusOnAsset());

    if (layoutImport) {
      layoutImport.addEventListener('change', async event => {
        const files = event.target && event.target.files;
        const file = files && files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const data = parseLayoutText(text);
          if (!data) throw new Error('layout-file-empty');
          ingestLayout(data);
        } catch (err) {
          console.error('Failed to parse layout JSON', err);
          if (err && err.cause) {
            console.error('Inner error:', err.cause);
          }
          const code = err && err.message;
          const message = code === 'layout-file-empty'
            ? 'The selected file was empty.'
            : 'Unable to read layout file. Please export again from the 2D survey.';
          alert(message);
        } finally {
          layoutImport.value = '';
        }
      });
    }

    if (loadGltfBtn) {
      loadGltfBtn.addEventListener('click', () => {
        loadSampleAsset();
      });
    }

    const loader = new GLTFLoader();

    function loadSampleAsset() {
      if (!loadGltfBtn) return;
      loadGltfBtn.disabled = true;
      loader.load(
        './assets/dozenSidedStack-Body.gltf',
        gltf => {
          const root = gltf.scene || (Array.isArray(gltf.scenes) ? gltf.scenes[0] : null);
          if (!root) {
            console.error('GLTF load succeeded but no scene graph was found.', gltf);
            alert('Unable to load the sample GLTF scene. See console for details.');
            loadGltfBtn.disabled = false;
            return;
          }

          root.traverse(node => {
            if (node.isMesh) {
              node.castShadow = false;
              node.receiveShadow = true;
            }
          });

          const bbox = new THREE.Box3().setFromObject(root);
          const center = new THREE.Vector3();
          const size = new THREE.Vector3();
          bbox.getCenter(center);
          bbox.getSize(size);
          root.position.sub(center);
          const scale = 0.001; // FreeCAD export uses millimeters
          root.scale.setScalar(scale);
          assetSize = size.clone().multiplyScalar(scale);
          assetAnchor.clear();
          assetAnchor.add(root);
          assetAnchor.visible = true;
          const baseY = assetSize.y / 2;
          assetAnchor.position.set(0, baseY, 0);
          assetAnchor.userData.baseY = baseY;
          assetAnchor.userData.minY = baseY;
          selectable.splice(0, selectable.length, assetAnchor);
          assetLoaded = true;
          selectObject(assetAnchor);
          loadGltfBtn.disabled = false;
          loadGltfBtn.textContent = 'Reload Sample GLTF Asset';
          repositionAssetIfNeeded();
        },
        undefined,
        error => {
          console.error('Failed to load GLTF asset', error);
          alert('Unable to load the sample GLTF file. See console for details.');
          loadGltfBtn.disabled = false;
        }
      );
    }

    function onWindowResize() {
      updateRendererSize();
    }

    window.addEventListener('resize', onWindowResize);

    resetLayout({ local: false, remote: false });
    updateRendererSize();
    scheduleWalkOverlayAutoHide();
    animate();

    (async () => {
      const restored = await restorePersistedLayout({ preferRemote: true });
      if (restored && restored.data) {
        const persistOptions = restored.source === 'server'
          ? { local: true, remote: false }
          : { local: true, remote: true };
        ingestLayout(restored.data, persistOptions);
      }
    })();
  </script>
</body>
</html>
