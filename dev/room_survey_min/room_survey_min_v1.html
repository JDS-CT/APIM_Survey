<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Prototype version 1 (baseline implementation used as source for future iterations) -->
  <meta charset="utf-8" />
  <title>Room Survey (SVG Drag + Snap) â€” v1 Baseline</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../shared/styles/glass_light_theme.css" />
  <link rel="stylesheet" href="../shared/styles/glass_dark_theme.css" />
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      background: var(--room-ui-bg);
      color: var(--room-ui-text);
      min-height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr;
      position: relative;
      overflow-x: hidden;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 18% 18%, rgba(96, 165, 250, 0.2), transparent 45%),
                  radial-gradient(circle at 82% 14%, rgba(129, 140, 248, 0.24), transparent 52%);
      opacity: 0.82;
      pointer-events: none;
      z-index: -2;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 20px;
      gap: 16px;
      border-bottom: 1px solid var(--room-ui-border);
      background: var(--room-ui-surface);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header .subtitle {
      font-size: 13px;
      color: var(--room-ui-muted-strong);
      margin-top: 2px;
    }
    nav {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .nav-link {
      text-decoration: none;
      font-weight: 600;
      color: var(--room-ui-link);
      padding: 6px 10px;
      border-radius: 6px;
      transition: background 120ms ease, color 120ms ease;
    }
    .nav-link:hover {
      background: rgba(37, 99, 235, 0.12);
    }
    .nav-link.active {
      background: rgba(37, 99, 235, 0.18);
    }
    main {
      display: grid;
      grid-template-columns: minmax(280px, 360px) 1fr;
      gap: 20px;
      padding: 24px;
      align-items: start;
    }
    aside {
      display: grid;
      gap: 20px;
    }
    .panel {
      background: var(--room-ui-surface);
      border-radius: 14px;
      padding: 18px;
      border: 1px solid var(--room-ui-border-soft);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.08);
      display: grid;
      gap: 12px;
    }
    .stage-panel {
      padding: 0;
      overflow: hidden;
    }
    .stage-panel-inner {
      padding: 18px;
      display: grid;
      gap: 12px;
    }
    .orientation-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .orientation-tab {
      appearance: none;
      font: inherit;
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--room-ui-border-soft);
      background: var(--room-ui-surface);
      color: inherit;
      cursor: pointer;
      transition: background 120ms ease, border-color 120ms ease, color 120ms ease, box-shadow 120ms ease;
    }
    .orientation-tab:hover {
      border-color: rgba(59, 130, 246, 0.6);
      color: var(--room-ui-link);
    }
    .orientation-tab[data-active="true"] {
      background: rgba(59, 130, 246, 0.18);
      border-color: rgba(59, 130, 246, 0.45);
      color: var(--room-ui-link);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.25);
    }
    .orientation-tab:focus-visible {
      outline: 2px solid rgba(96, 165, 250, 0.65);
      outline-offset: 2px;
    }
    .orientation-tab.orientation-action {
      border-style: dashed;
    }
    .row {
      display: flex;
      gap: 14px;
      align-items: center;
      flex-wrap: wrap;
    }
    label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      font-weight: 600;
      color: var(--room-ui-muted-strong);
    }
    label input,
    label select {
      font: inherit;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--room-ui-border);
      background: rgba(255, 255, 255, 0.92);
      min-width: 7em;
      color: inherit;
    }
    input[type="number"] {
      width: 7em;
    }
    .btn {
      appearance: none;
      font: inherit;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--room-ui-button-border);
      background: linear-gradient(180deg, var(--room-ui-button-bg-top), var(--room-ui-button-bg-bottom));
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px var(--room-ui-shadow);
    }
    .legend {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--room-ui-muted-strong);
    }
    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 8px;
      vertical-align: middle;
    }
    .hud {
      font-size: 13px;
      color: var(--room-ui-muted-strong);
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .note {
      font-size: 13px;
      color: var(--room-ui-muted);
    }
    .wall-choice {
      min-width: 220px;
    }
    .handle { fill: #fff; stroke: #333; stroke-width: 1.5; cursor: pointer; }
    .custom-wall-line { cursor: move; }
    #roomRect.floor-selected { stroke: #1976d2; stroke-width: 3; }
    .wall-label { font-size: 12px; font-weight: 600; fill: #111; pointer-events: none; }
    .selected-door { stroke: #26a69a !important; }
    .selected-wall-item rect { stroke: #1976d2 !important; }
    .selected-wall-item line { stroke: #1976d2 !important; }
    .selected-floor-item rect { stroke: #1976d2 !important; stroke-width: 3 !important; }
    body[data-mode="basic"] .custom-only { display: none !important; }
    body[data-mode="custom"] .basic-only { display: none !important; }
    body[data-mode="basic"] .wall-choice { display: none !important; }
    #stage {
      width: 100%;
      height: auto;
      max-width: 900px;
      border: 1px solid var(--room-ui-border);
      background: rgba(255, 255, 255, 0.8);
      display: block;
    }
    .workspace {
      display: grid;
      gap: 20px;
    }
    .export-panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
    }
    #wallElevationLayer,
    #scaleOverlay {
      pointer-events: none;
    }
    #scaleOverlay text {
      font-size: 12px;
      font-weight: 600;
      fill: #0f172a;
      paint-order: stroke;
      stroke: rgba(255, 255, 255, 0.65);
      stroke-width: 2px;
    }
    .scale-bar-line { stroke: #0f172a; stroke-width: 2; }
    .scale-bar-tick { stroke: #0f172a; stroke-width: 2; }
    .scale-bar-label { dominant-baseline: hanging; }
    svg[data-orientation="ceiling"] #floorItems { opacity: 0.35; }
    svg[data-orientation="wall"] #grid,
    svg[data-orientation="wall"] #origin,
    svg[data-orientation="wall"] #originLabel,
    svg[data-orientation="wall"] #baseWallsOverlay,
    svg[data-orientation="wall"] #wallLabels,
    svg[data-orientation="wall"] #selectionOverlay,
    svg[data-orientation="wall"] #customWalls,
    svg[data-orientation="wall"] #doorsLayer,
    svg[data-orientation="wall"] #floorItems,
    svg[data-orientation="wall"] #wallItems {
      display: none;
    }
    #wallElevationLayer { display: none; }
    svg[data-orientation="wall"] #wallElevationLayer { display: block; }
    svg[data-orientation="wall"] #roomRect {
      fill: rgba(148, 163, 184, 0.12);
      stroke: rgba(30, 41, 59, 0.55);
      stroke-width: 2;
    }
    .wall-elevation-backdrop {
      fill: rgba(226, 232, 240, 0.4);
      stroke: rgba(71, 85, 105, 0.4);
      stroke-width: 1;
    }
    .wall-elevation-backdrop[data-selected="true"] {
      stroke: #2563eb;
      stroke-width: 2;
    }
    .wall-elevation-axis { stroke: rgba(15, 23, 42, 0.55); stroke-width: 2; }
    .wall-elevation-axis[data-kind="ceiling"] { stroke-dasharray: 8 6; opacity: 0.7; }
    .wall-elevation-door {
      fill: rgba(37, 99, 235, 0.15);
      stroke: #1e88e5;
      stroke-width: 2;
    }
    .wall-elevation-door[data-selected="true"] { stroke-width: 3; }
    .wall-elevation-item rect {
      fill-opacity: 0.9;
      stroke-width: 2;
    }
    .wall-elevation-item[data-selected="true"] rect {
      stroke: #1976d2;
      stroke-width: 3;
    }
    .wall-elevation-item text {
      font-size: 11px;
      fill: #0f172a;
      paint-order: stroke;
      stroke: rgba(255, 255, 255, 0.6);
      stroke-width: 3px;
    }
    .wall-elevation-height {
      stroke: rgba(15, 23, 42, 0.45);
      stroke-dasharray: 4 4;
      stroke-width: 2;
    }
  </style>
</head>
<body data-room-theme="glass-dark">
  <header>
    <div>
      <strong>Room Survey (Top-Down)</strong>
      <div class="subtitle">Plan microscope placement, adjust walls, and export layouts for 3D review.</div>
    </div>
    <nav>
      <a class="nav-link" href="../index.html">Home</a>
      <a class="nav-link active" href="room_survey_min_v1.html">2D Survey</a>
      <a class="nav-link" href="../interactive_3d_room/interactive_3d_room_fps_demo.html">First-Person Demo</a>
    </nav>
  </header>
  <main>
    <aside>
      <div class="panel">
        <div class="row" id="primaryControls">
          <label class="toggle">Room type
            <select id="roomType">
              <option value="basic">Basic (Rectangular)</option>
              <option value="custom">Custom Layout</option>
            </select>
          </label>
          <label class="dim">Width W (mm) <input id="W" type="number" value="6000" min="1000"></label>
          <label class="dim">Length L (mm) <input id="L" type="number" value="8000" min="1000"></label>
          <label class="custom-only">Snap (mm) <input id="snap" type="number" value="100" min="10" step="10" title="Grid snap step in millimeters"></label>
          <label class="toggle custom-only"><input id="imperial" type="checkbox"> Show imperial (in) &amp; use 150&nbsp;mm snap</label>
          <button class="btn" id="apply">Apply</button>
        </div>
        <div class="row basic-only" id="basicAddRow">
          <label>
            Add item:
            <select id="basicAddType">
              <option value="microscope">Microscope</option>
              <option value="table">Table</option>
              <option value="pump">Vacuum Pump</option>
            </select>
          </label>
          <button class="btn" id="basicAdd">Add</button>
        </div>
        <div class="row custom-only" id="customAddRow">
          <label>
            Add:
            <select id="addType">
              <option value="floorBox">Floor Box</option>
              <option value="microscope">Microscope</option>
              <option value="table">Table</option>
              <option value="pump">Vacuum Pump</option>
              <option value="socket">Wall Socket (Power)</option>
              <option value="gas_socket">Gas Socket</option>
              <option value="feedthrough">Wall Feedthrough</option>
            </select>
          </label>
          <label class="wall-choice">
            Wall for wall item:
            <select id="wallSel"></select>
          </label>
          <button class="btn" id="add">Add</button>
        </div>
        <div class="row custom-only" id="structureRow">
          <button class="btn" id="addWall">Draw Wall</button>
          <button class="btn" id="addDoor">Add Door to Selected Wall</button>
          <span class="note">Select a wall or floor to attach items. Drag wall end dots to reshape custom walls.</span>
        </div>
        <div class="note">Switch to the custom layout to draw new walls, add doors, and place sockets on specific runs.</div>
      </div>
      <div class="panel legend">
        <div><span class="dot" style="background:#1e88e5"></span>Floor Box</div>
        <div><span class="dot" style="background:#f9a825"></span>Wall Socket (Power)</div>
        <div><span class="dot" style="background:#22c55e"></span>Gas Socket</div>
        <div><span class="dot" style="background:#0ea5e9"></span>Feedthrough</div>
        <div><span class="dot" style="background:#8e24aa"></span>Microscope</div>
        <div><span class="dot" style="background:#3949ab"></span>Table</div>
        <div><span class="dot" style="background:#ef6c00"></span>Vacuum Pump</div>
      </div>
    </aside>
    <section class="workspace">
      <div class="panel stage-panel">
        <div class="stage-panel-inner">
          <div class="orientation-tabs" id="orientationTabs" role="group" aria-label="Surface orientation">
            <button type="button" class="orientation-tab" data-orientation="floor" data-active="true" aria-pressed="true">Floor</button>
            <button type="button" class="orientation-tab" data-orientation="wall:base:1" aria-pressed="false">Wall 1</button>
            <button type="button" class="orientation-tab" data-orientation="wall:base:2" aria-pressed="false">Wall 2</button>
            <button type="button" class="orientation-tab" data-orientation="wall:base:3" aria-pressed="false">Wall 3</button>
            <button type="button" class="orientation-tab" data-orientation="wall:base:4" aria-pressed="false">Wall 4</button>
            <button type="button" class="orientation-tab" data-orientation="ceiling" aria-pressed="false">Ceiling</button>
            <button type="button" class="orientation-tab orientation-action" id="viewSelectedWall" aria-pressed="false">View Selected</button>
          </div>
          <svg id="stage" width="900" height="640" viewBox="0 0 900 640">
            <!-- Room rectangle (scaled to fit) -->
            <g id="roomGroup">
              <rect id="roomRect" x="50" y="50" width="700" height="500" fill="none" stroke="#333" stroke-width="2"/>
              <!-- Origin marker (rear-left corner) -->
              <circle id="origin" cx="50" cy="550" r="5" fill="#d33"></circle>
              <text id="originLabel" x="60" y="545" font-size="12">Origin (0,0)</text>
              <!-- grid group -->
              <g id="grid"></g>
            </g>

            <!-- Draggable items -->
            <g id="baseWallsOverlay"></g>
            <g id="wallLabels"></g>
            <g id="selectionOverlay"></g>
            <g id="customWalls"></g>
            <g id="doorsLayer"></g>
            <g id="floorItems"></g>
            <g id="wallItems"></g>
            <g id="wallElevationLayer"></g>
            <g id="scaleOverlay"></g>
          </svg>
        </div>
      </div>
      <div class="panel export-panel" id="exportRow">
        <button class="btn" id="export">Export JSON</button>
        <span class="hud" id="hud"></span>
      </div>
    </section>
  </main>

  <script src="../shared/scripts/cable_catalog_defaults.js"></script>
  <script>

const bodyEl = document.body;
const svg = document.getElementById('stage');
const roomTypeSel = document.getElementById('roomType');
const Winput = document.getElementById('W');
const Linput = document.getElementById('L');
const snapInput = document.getElementById('snap');
const imperialChk = document.getElementById('imperial');
const applyBtn = document.getElementById('apply');
const basicAddBtn = document.getElementById('basicAdd');
const basicAddType = document.getElementById('basicAddType');
const addBtn = document.getElementById('add');
const addType = document.getElementById('addType');
const wallSel = document.getElementById('wallSel');
const addWallBtn = document.getElementById('addWall');
const addDoorBtn = document.getElementById('addDoor');
const exportBtn = document.getElementById('export');
const hud = document.getElementById('hud');
const orientationTabsEl = document.getElementById('orientationTabs');
const viewSelectedWallBtn = document.getElementById('viewSelectedWall');
const orientationButtons = orientationTabsEl
  ? Array.from(orientationTabsEl.querySelectorAll('[data-orientation]'))
  : [];

const roomRect = document.getElementById('roomRect');
const originDot = document.getElementById('origin');
const originLabel = document.getElementById('originLabel');
const gridG = document.getElementById('grid');
const baseWallsG = document.getElementById('baseWallsOverlay');
const wallLabelsG = document.getElementById('wallLabels');
const selectionG = document.getElementById('selectionOverlay');
const customWallsG = document.getElementById('customWalls');
const doorsG = document.getElementById('doorsLayer');
const floorItemsG = document.getElementById('floorItems');
const wallItemsG = document.getElementById('wallItems');
const wallElevationLayer = document.getElementById('wallElevationLayer');
const scaleOverlayG = document.getElementById('scaleOverlay');

const LAYOUT_STORAGE_KEY = 'apim-room.latest-layout';
const LAYOUT_PERSIST_DELAY_MS = 240;

const FLOOR_ITEM_DEFS = {
  floorBox: { label: 'Floor Box', w: 600, l: 600, fill: '#1e88e5', stroke: '#1e88e5' },
  microscope: { label: 'Microscope', w: 2200, l: 1800, fill: '#8e24aa', stroke: '#5e35b1' },
  table: { label: 'Table', w: 1800, l: 900, fill: '#3949ab', stroke: '#1a237e' },
  pump: { label: 'Vacuum Pump', w: 1200, l: 600, fill: '#ef6c00', stroke: '#e65100' },
  gltfAsset: { label: 'GLTF Asset', w: 2000, l: 2000, fill: '#8b5cf6', stroke: '#6d28d9' }
};

const ALL_DEFAULT_CABLE_TYPES = (window.DEFAULT_CABLE_CATALOG && window.DEFAULT_CABLE_CATALOG.cableTypes)
  ? Object.keys(window.DEFAULT_CABLE_CATALOG.cableTypes)
  : ['power', 'ground', 'air', 'n2', 'vacuum', 'water', 'ethernet'];

const WALL_ITEM_DEFS = {
  socket: {
    label: 'Wall Socket',
    idPrefix: 'socket',
    fill: '#f9a825',
    stroke: '#aa7a00',
    assetKey: 'wall_socket',
    defaultDepth: 300,
    mountHeightMm: 1200,
    depthDirections: [1],
    fallbackSockets: [
      {
        id: 'wall_outlet_duplex',
        label: 'Duplex Outlet',
        anchor: { u: 0.5, v: 0.5, w: 0.5 },
        allowedCableTypes: ['power', 'ground'],
        surface: 'wall',
        offsetDirection: 1
      }
    ]
  },
  gas_socket: {
    label: 'Gas Socket',
    idPrefix: 'gas',
    fill: '#22c55e',
    stroke: '#15803d',
    assetKey: 'wall_gas_socket',
    defaultDepth: 300,
    mountHeightMm: 1400,
    depthDirections: [1],
    fallbackSockets: [
      {
        id: 'wall_gas_outlet',
        label: 'Gas Outlet',
        anchor: { u: 0.5, v: 0.5, w: 0.5 },
        allowedCableTypes: ['air', 'n2', 'vacuum'],
        surface: 'wall',
        offsetDirection: 1
      }
    ]
  },
  feedthrough: {
    label: 'Feedthrough',
    idPrefix: 'feed',
    fill: '#0ea5e9',
    stroke: '#0369a1',
    assetKey: 'wall_feedthrough',
    defaultDepth: 200,
    mountHeightMm: 1300,
    depthDirections: [1, -1],
    fallbackSockets: [
      {
        id: 'feedthrough_room',
        label: 'Feedthrough (Room Side)',
        anchor: { u: 0.5, v: 0.5, w: 0.5 },
        allowedCableTypes: ALL_DEFAULT_CABLE_TYPES,
        surface: 'wall',
        offsetDirection: 1
      },
      {
        id: 'feedthrough_service',
        label: 'Feedthrough (Service Side)',
        anchor: { u: 0.5, v: 0.5, w: 0.5 },
        allowedCableTypes: ALL_DEFAULT_CABLE_TYPES,
        surface: 'wall',
        offsetDirection: -1
      }
    ]
  }
};

const DEFAULT_ROOM_PRESET = () => ({
  room: { W: 6000, L: 8000 },
  floor_items: [
    { id: 'floor_1', type: 'microscope', x: 2200, y: 5200, rotation: 0 },
    { id: 'floor_2', type: 'table', x: 3800, y: 5200, rotation: 0 },
    { id: 'floor_3', type: 'pump', x: 4200, y: 3400, rotation: 0 },
    { id: 'floor_4', type: 'floorBox', x: 3000, y: 3600, rotation: 0 }
  ],
  wall_items: [
    { id: 'socket_5', type: 'socket', wall: 'base:1', s: 1500, h: 300 },
    { id: 'socket_6', type: 'socket', wall: 'base:3', s: 4500, h: 300 }
  ],
  cables: [
    {
      id: 'cable_7',
      cableType: 'power',
      source: { kind: 'floor', assetId: 'floor_1', socketId: 'microscope_power' },
      target: { kind: 'wall', assetId: 'socket_5', socketId: 'wall_outlet_duplex' }
    }
  ]
});

const BASE_WALL_THICKNESS = 200;
const DOOR_DEFAULT_WIDTH = 900;
const DOOR_DEFAULT_THICKNESS = 80;
const DOOR_ELEVATION_HEIGHT_MM = 2100;
const SCALE_OVERLAY_CONFIG = { enabled: true };

let idCounter = 1;
let suppressPersist = false;
let pendingPersist = null;
let persistTimer = null;
let flushingPersist = false;
let lastPersistedSerialized = null;

function genId(prefix = 'id') { return `${prefix}_${idCounter++}`; }

const state = {
  mode: 'basic',
  Wmm: 6000,
  Lmm: 8000,
  scale: 1,
  snap: 100,
  imperial: false,
  floorItems: [],
  wallItems: [],
  customWalls: [],
  doors: [],
  cables: [],
  selectedSurface: { type: 'floor' },
  orientation: { type: 'floor' },
  view: {
    type: 'floor',
    widthMm: 6000,
    heightMm: 8000,
    originX: 50,
    originY: 50,
    wallGeom: null
  }
};

let hudTransient = null;
let drawWallState = null;
function showHud(message) { hudTransient = message; }

function toNumber(value, fallback = 0) {
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function isEditingFormControl(el) {
  if (!el) return false;
  if (el.isContentEditable) return true;
  const tag = el.tagName;
  if (!tag) return false;
  return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
}

function applyDefaultPreset() {
  const preset = DEFAULT_ROOM_PRESET();
  state.Wmm = preset.room.W;
  state.Lmm = preset.room.L;
  state.floorItems = (preset.floor_items || [])
    .map(item => {
      const normalized = normalizeFloorItemFromLayout(item);
      if (!normalized) return null;
      return {
        ...normalized,
        x: snapValue(normalized.x),
        y: snapValue(normalized.y)
      };
    })
    .filter(Boolean);
  state.wallItems = (preset.wall_items || [])
    .map(item => normalizeWallItemFromLayout(item))
    .filter(Boolean);
  state.customWalls = [];
  state.doors = [];
  state.cables = (preset.cables || [])
    .map(entry => normalizeCableFromLayout(entry))
    .filter(Boolean);
  state.selectedSurface = { type: 'floor' };
  Winput.value = state.Wmm;
  Linput.value = state.Lmm;
  snapInput.value = state.snap;
  syncIdCounterFromLayout();
}


function normalizeFloorItemFromLayout(item) {
  if (!item || typeof item !== 'object') return null;
  const type = item.type || 'floorBox';
  const def = FLOOR_ITEM_DEFS[type] || FLOOR_ITEM_DEFS.floorBox;
  const id = item.id !== undefined ? String(item.id) : genId('floor');
  return {
    id,
    type,
    x: toNumber(item.x, 0),
    y: toNumber(item.y, 0),
    w: toNumber(item.w ?? item.size ?? def.w, def.w),
    l: toNumber(item.l ?? item.size ?? def.l, def.l),
    rotation: toNumber(item.rotation, 0),
    assetRef: typeof item.assetRef === 'string' ? item.assetRef : undefined,
    elevation_mm: item.elevation_mm !== undefined ? toNumber(item.elevation_mm, 0) : undefined
  };
}

function normalizeWallItemFromLayout(item) {
  if (!item || typeof item !== 'object') return null;
  const type = item.type || 'socket';
  const def = WALL_ITEM_DEFS[type] || WALL_ITEM_DEFS.socket;
  const id = item.id !== undefined ? String(item.id) : genId(def.idPrefix || 'wallItem');
  let wallRef = item.wall;
  if (typeof wallRef === 'number') wallRef = `base:${wallRef}`;
  if (typeof wallRef === 'string' && /^\d$/.test(wallRef)) wallRef = `base:${wallRef}`;
  const depth = item.h !== undefined ? item.h : def.defaultDepth;
  const mountHeightSource =
    item.mount_height_mm !== undefined ? item.mount_height_mm
    : item.mountHeight_mm !== undefined ? item.mountHeight_mm
    : item.mount_height !== undefined ? item.mount_height
    : item.mountHeight !== undefined ? item.mountHeight
      : undefined;
  const fallbackMount = def.mountHeightMm !== undefined ? def.mountHeightMm : 1200;
  const normalized = {
    id,
    type,
    wall: wallRef || 'base:1',
    s: toNumber(item.s, 0),
    h: toNumber(depth, def.defaultDepth)
  };
  if (mountHeightSource !== undefined) {
    normalized.mountHeight_mm = toNumber(mountHeightSource, fallbackMount);
  } else if (def.mountHeightMm !== undefined) {
    normalized.mountHeight_mm = def.mountHeightMm;
  }
  return normalized;
}

function normalizeCustomWallFromLayout(wall) {
  if (!wall || typeof wall !== 'object') return null;
  const id = wall.id !== undefined ? String(wall.id) : genId('cw');
  return {
    id,
    name: wall.name,
    x1: toNumber(wall.x1, 0),
    y1: toNumber(wall.y1, 0),
    x2: toNumber(wall.x2, 0),
    y2: toNumber(wall.y2, 0),
    thickness: toNumber(wall.thickness, BASE_WALL_THICKNESS)
  };
}

function normalizeDoorFromLayout(door) {
  if (!door || typeof door !== 'object') return null;
  const id = door.id !== undefined ? String(door.id) : genId('door');
  let wallRef = door.wall;
  if (typeof wallRef === 'number') wallRef = `base:${wallRef}`;
  if (typeof wallRef === 'string' && /^\d$/.test(wallRef)) wallRef = `base:${wallRef}`;
  return {
    id,
    wall: wallRef || 'base:1',
    offset: toNumber(door.offset, 0),
    width: toNumber(door.width, DOOR_DEFAULT_WIDTH),
    thickness: toNumber(door.thickness, DOOR_DEFAULT_THICKNESS)
  };
}

function snapshotSelectedSurface(surface) {
  if (!surface || typeof surface !== 'object') return { type: 'floor' };
  if (surface.type === 'wall' && surface.ref) return { type: 'wall', ref: surface.ref };
  if ((surface.type === 'floorItem' || surface.type === 'wallItem' || surface.type === 'door') && surface.id) {
    return { type: surface.type, id: surface.id };
  }
  if (surface.type === 'floor') return { type: 'floor' };
  return { type: 'floor' };
}

function normalizeSelectedSurface(surface) {
  if (!surface || typeof surface !== 'object') return { type: 'floor' };
  if (surface.type === 'wall' && surface.ref) return { type: 'wall', ref: surface.ref };
  if ((surface.type === 'floorItem' || surface.type === 'wallItem' || surface.type === 'door') && surface.id) {
    return { type: surface.type, id: surface.id };
  }
  if (surface.type === 'floor') return { type: 'floor' };
  return { type: 'floor' };
}

function snapshotLayout() {
  return {
    units: 'mm',
    room: { W: Math.round(state.Wmm), L: Math.round(state.Lmm) },
    snap_mm: Math.round(state.snap),
    imperial_display: !!state.imperial,
    mode: state.mode,
    floor_items: state.floorItems.map(item => {
      const snapshot = {
        id: item.id,
        type: item.type,
        x: Math.round(item.x),
        y: Math.round(item.y),
        w: Math.round(item.w),
        l: Math.round(item.l),
        rotation: Math.round(item.rotation || 0)
      };
      if (item.assetRef) snapshot.assetRef = item.assetRef;
      if (item.elevation_mm !== undefined) {
        snapshot.elevation_mm = Math.round(item.elevation_mm);
      }
      return snapshot;
    }),
    wall_items: state.wallItems.map(item => {
      const snapshot = {
        id: item.id,
        type: item.type,
        wall: item.wall,
        s: Math.round(item.s || 0),
        h: Math.round(item.h || 0)
      };
      if (item.mountHeight_mm !== undefined) {
        snapshot.mount_height_mm = Math.round(item.mountHeight_mm);
      }
      return snapshot;
    }),
    custom_walls: state.customWalls.map(wall => ({
      id: wall.id,
      name: wall.name,
      x1: Math.round(wall.x1),
      y1: Math.round(wall.y1),
      x2: Math.round(wall.x2),
      y2: Math.round(wall.y2),
      thickness: Math.round(wall.thickness || BASE_WALL_THICKNESS)
    })),
    doors: state.doors.map(door => ({
      id: door.id,
      wall: door.wall,
      offset: Math.round(door.offset || 0),
      width: Math.round(door.width || DOOR_DEFAULT_WIDTH),
      thickness: Math.round(door.thickness || DOOR_DEFAULT_THICKNESS)
    })),
    selected_surface: snapshotSelectedSurface(state.selectedSurface)
  };
}

function persistLayoutLocal(payload) {
  try {
    if (window.localStorage) {
      window.localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(payload));
    }
  } catch (err) {
    console.warn('Failed to persist layout locally', err);
  }
}

function loadLayoutLocal() {
  try {
    if (!window.localStorage) return null;
    const raw = window.localStorage.getItem(LAYOUT_STORAGE_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch (err) {
    console.warn('Failed to load layout from local storage', err);
    return null;
  }
}

async function saveLayoutRemote(payload) {
  try {
    const resp = await fetch('/api/layout', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!resp.ok) throw new Error(await resp.text());
    return true;
  } catch (err) {
    console.warn('Failed to save layout to server', err);
    return false;
  }
}

async function loadLayoutRemote() {
  try {
    const resp = await fetch('/api/layout', {
      method: 'GET',
      headers: { Accept: 'application/json' },
      cache: 'no-store'
    });
    if (!resp.ok) {
      if (resp.status === 404) return null;
      throw new Error(await resp.text());
    }
    const text = await resp.text();
    if (!text) return null;
    const payload = JSON.parse(text);
    if (payload && typeof payload === 'object') {
      if (payload.layout !== undefined) return payload.layout;
      return payload;
    }
    return null;
  } catch (err) {
    console.warn('Failed to load layout from server', err);
    return null;
  }
}

async function restorePersistedLayout({ preferRemote = true } = {}) {
  const order = preferRemote ? ['remote', 'local'] : ['local', 'remote'];
  for (const source of order) {
    if (source === 'remote') {
      const remote = await loadLayoutRemote();
      if (remote) return { data: remote, source: 'server' };
    } else {
      const local = loadLayoutLocal();
      if (local) return { data: local, source: 'local' };
    }
  }
  return null;
}

function schedulePersist(snapshot) {
  if (suppressPersist) return;
  const serialized = JSON.stringify(snapshot);
  if (serialized === lastPersistedSerialized && !pendingPersist) return;
  pendingPersist = {
    snapshot: JSON.parse(JSON.stringify(snapshot)),
    serialized
  };
  if (persistTimer) return;
  persistTimer = setTimeout(() => {
    persistTimer = null;
    void flushPersistQueue();
  }, LAYOUT_PERSIST_DELAY_MS);
}

async function flushPersistQueue() {
  if (flushingPersist) return;
  flushingPersist = true;
  try {
    while (pendingPersist) {
      const current = pendingPersist;
      pendingPersist = null;
      persistLayoutLocal(current.snapshot);
      const ok = await saveLayoutRemote(current.snapshot);
      if (!ok) {
        console.warn('Unable to sync layout to server; will retry on next change.');
      }
      lastPersistedSerialized = current.serialized;
    }
  } finally {
    flushingPersist = false;
    if (pendingPersist && !persistTimer) {
      persistTimer = setTimeout(() => {
        persistTimer = null;
        void flushPersistQueue();
      }, LAYOUT_PERSIST_DELAY_MS);
    }
  }
}

function maybePersistLayout() {
  if (suppressPersist) return;
  const snapshot = snapshotLayout();
  schedulePersist(snapshot);
}

function syncIdCounterFromLayout() {
  const ids = [
    ...state.floorItems.map(it => it.id),
    ...state.wallItems.map(it => it.id),
    ...state.customWalls.map(it => it.id),
    ...state.doors.map(it => it.id),
    ...(Array.isArray(state.cables) ? state.cables.map(it => it.id) : [])
  ];
  ids.forEach(id => {
    const match = id ? String(id).match(/_(\d+)$/) : null;
    if (match) {
      const candidate = Number(match[1]);
      if (Number.isFinite(candidate)) {
        idCounter = Math.max(idCounter, candidate + 1);
      }
    }
  });
}

function applyLayout(raw, { skipPersist = false, message } = {}) {
  if (!raw || typeof raw !== 'object') return false;
  const layout = raw.layout && typeof raw.layout === 'object' ? raw.layout : raw;
  suppressPersist = true;
  try {
    if (message) showHud(message);
    if (layout.room) {
      state.Wmm = Math.max(1000, toNumber(layout.room.W ?? layout.room.width, state.Wmm));
      state.Lmm = Math.max(1000, toNumber(layout.room.L ?? layout.room.length, state.Lmm));
    }
    Winput.value = state.Wmm;
    Linput.value = state.Lmm;

    if (layout.snap_mm !== undefined) {
      state.snap = Math.max(10, toNumber(layout.snap_mm, state.snap));
    }
    if (layout.imperial_display !== undefined) {
      state.imperial = !!layout.imperial_display;
    }
    imperialChk.checked = state.imperial;
    if (state.imperial) {
      state.snap = 150;
    }
    snapInput.value = state.snap;

    const floorItems = Array.isArray(layout.floor_items)
      ? layout.floor_items
      : Array.isArray(layout.items)
        ? layout.items.filter(item => item && item.type !== 'socket')
        : [];
    const wallItems = Array.isArray(layout.wall_items)
      ? layout.wall_items
      : Array.isArray(layout.items)
        ? layout.items.filter(item => item && item.type === 'socket')
        : [];

    state.floorItems = floorItems.map(normalizeFloorItemFromLayout).filter(Boolean);
    state.wallItems = wallItems.map(normalizeWallItemFromLayout).filter(Boolean);
    state.customWalls = Array.isArray(layout.custom_walls)
      ? layout.custom_walls.map(normalizeCustomWallFromLayout).filter(Boolean)
      : [];
    state.doors = Array.isArray(layout.doors)
      ? layout.doors.map(normalizeDoorFromLayout).filter(Boolean)
      : [];
    state.cables = normalizeCableArray(layout);

    syncIdCounterFromLayout();
    recomputeScale();
    clampStateToRoom();
    const nextMode = typeof layout.mode === 'string' ? layout.mode : state.mode;
    setMode(nextMode || 'basic');
    const surface = normalizeSelectedSurface(layout.selected_surface);
    setSelectedSurface(surface, { skipRender: true });
  } finally {
    suppressPersist = false;
  }

  const snapshot = snapshotLayout();
  if (skipPersist) {
    persistLayoutLocal(snapshot);
    lastPersistedSerialized = JSON.stringify(snapshot);
  } else {
    schedulePersist(snapshot);
  }
  return true;
}

function mmToIn(mm) { return mm / 25.4; }
function fmtLen(mm) {
  if (!state.imperial) return `${Math.round(mm)} mm`;
  const inches = mmToIn(mm);
  return `${Math.round(mm)} mm (${inches.toFixed(2)} in)`;
}

function snapValue(vmm) {
  const s = state.snap;
  if (!s) return vmm;
  return Math.round(vmm / s) * s;
}

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function snapPoint(pt) {
  return { x: snapValue(pt.x), y: snapValue(pt.y) };
}

function resnapAll() {
  state.floorItems.forEach(item => {
    if (typeof item.x === 'number') item.x = snapValue(item.x);
    if (typeof item.y === 'number') item.y = snapValue(item.y);
  });
  state.wallItems.forEach(item => {
    if (WALL_ITEM_DEFS[item.type]) {
      if (typeof item.s === 'number') item.s = snapValue(item.s);
      if (typeof item.h === 'number') item.h = snapValue(item.h);
      if (typeof item.mountHeight_mm === 'number') {
        item.mountHeight_mm = snapValue(item.mountHeight_mm);
      }
    }
  });
  state.customWalls.forEach(wall => {
    if (typeof wall.x1 === 'number') wall.x1 = snapValue(wall.x1);
    if (typeof wall.y1 === 'number') wall.y1 = snapValue(wall.y1);
    if (typeof wall.x2 === 'number') wall.x2 = snapValue(wall.x2);
    if (typeof wall.y2 === 'number') wall.y2 = snapValue(wall.y2);
  });
  state.doors.forEach(door => {
    if (typeof door.offset === 'number') door.offset = snapValue(door.offset);
    if (typeof door.width === 'number') door.width = snapValue(door.width);
  });
}

function recomputeScale() {
  const maxWpx = 800;
  const maxHpx = 520;
  const type = orientationType();
  if (isWallOrientation()) {
    let geom = getWallGeometry(state.orientation?.ref);
    if (!geom) {
      const fallback = listAllWalls()[0] || null;
      if (fallback) {
        state.orientation = { type: 'wall', ref: fallback.ref };
        geom = fallback;
      }
    }
    if (!geom) {
      state.orientation = { type: 'floor' };
      return recomputeScale();
    }
    const widthMm = Math.max(geom.length, 1);
    const heightMm = DEFAULT_ROOM_HEIGHT_MM;
    const sx = maxWpx / widthMm;
    const sy = maxHpx / heightMm;
    state.scale = Math.max(Math.min(sx, sy), 0.01);
    const wpx = widthMm * state.scale;
    const hpx = heightMm * state.scale;
    const x0 = 50;
    const y0 = 570 - hpx;
    roomRect.setAttribute('width', wpx);
    roomRect.setAttribute('height', hpx);
    roomRect.setAttribute('x', x0);
    roomRect.setAttribute('y', y0);
    originDot.setAttribute('cx', x0);
    originDot.setAttribute('cy', y0 + hpx);
    if (originLabel) {
      originLabel.setAttribute('x', x0 + 10);
      originLabel.setAttribute('y', y0 + hpx - 12);
      originLabel.textContent = 'Floor (0 mm)';
    }
    state.view = {
      type,
      widthMm,
      heightMm,
      originX: x0,
      originY: y0,
      wallGeom: geom
    };
    drawGrid();
    return;
  }

  const widthMm = Math.max(state.Wmm, 1);
  const heightMm = Math.max(state.Lmm, 1);
  const sx = maxWpx / widthMm;
  const sy = maxHpx / heightMm;
  state.scale = Math.max(Math.min(sx, sy), 0.01);
  const wpx = widthMm * state.scale;
  const hpx = heightMm * state.scale;
  const x0 = 50;
  const y0 = 570 - hpx;
  roomRect.setAttribute('width', wpx);
  roomRect.setAttribute('height', hpx);
  roomRect.setAttribute('x', x0);
  roomRect.setAttribute('y', y0);
  originDot.setAttribute('cx', x0);
  originDot.setAttribute('cy', 570);
  if (originLabel) {
    originLabel.setAttribute('x', x0 + 10);
    originLabel.setAttribute('y', 545);
    originLabel.textContent = 'Origin (0,0)';
  }
  state.view = {
    type,
    widthMm,
    heightMm,
    originX: x0,
    originY: y0,
    wallGeom: null
  };
  drawGrid();
}

function drawGrid() {
  if (isWallOrientation()) {
    drawWallGrid();
  } else {
    drawPlanGrid();
  }
}

function drawPlanGrid() {
  gridG.innerHTML = '';
  const step = state.snap;
  if (step <= 0) return;
  const view = state.view;
  const x0 = view ? view.originX : Number(roomRect.getAttribute('x'));
  const y0 = view ? view.originY : Number(roomRect.getAttribute('y'));
  const wpx = Number(roomRect.getAttribute('width'));
  const hpx = Number(roomRect.getAttribute('height'));
  for (let xmm = 0; xmm <= state.Wmm; xmm += step) {
    const x = x0 + xmm * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x);
    line.setAttribute('y1', y0);
    line.setAttribute('x2', x);
    line.setAttribute('y2', y0 + hpx);
    line.setAttribute('stroke', '#ddd');
    line.setAttribute('stroke-width', 1);
    gridG.appendChild(line);
  }
  for (let ymm = 0; ymm <= state.Lmm; ymm += step) {
    const y = y0 + (state.Lmm - ymm) * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x0);
    line.setAttribute('y1', y);
    line.setAttribute('x2', x0 + wpx);
    line.setAttribute('y2', y);
    line.setAttribute('stroke', '#eee');
    line.setAttribute('stroke-width', 1);
    gridG.appendChild(line);
  }
}

function drawWallGrid() {
  gridG.innerHTML = '';
  const view = state.view;
  if (!view || view.type !== 'wall') return;
  const x0 = view.originX;
  const y0 = view.originY;
  const widthPx = Number(roomRect.getAttribute('width'));
  const heightPx = Number(roomRect.getAttribute('height'));
  const horizontalStep = state.snap > 0 ? state.snap : 100;
  const verticalStep = 300;
  for (let xmm = 0; xmm <= view.widthMm; xmm += horizontalStep) {
    const x = x0 + xmm * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x);
    line.setAttribute('y1', y0);
    line.setAttribute('x2', x);
    line.setAttribute('y2', y0 + heightPx);
    line.setAttribute('stroke', '#d4d4d8');
    line.setAttribute('stroke-width', xmm % (horizontalStep * 5) === 0 ? 1.5 : 1);
    gridG.appendChild(line);
  }
  for (let zmm = 0; zmm <= view.heightMm; zmm += verticalStep) {
    const y = y0 + heightPx - zmm * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x0);
    line.setAttribute('y1', y);
    line.setAttribute('x2', x0 + widthPx);
    line.setAttribute('y2', y);
    line.setAttribute('stroke', '#e2e8f0');
    line.setAttribute('stroke-width', zmm % (verticalStep * 2) === 0 ? 1.5 : 1);
    gridG.appendChild(line);
  }
}

function mmToPx(xmm, ymm) {
  const view = state.view;
  if (!view) return [0, 0];
  if (view.type === 'wall') {
    return wallMmToPx(xmm, ymm);
  }
  const px = view.originX + xmm * state.scale;
  const py = view.originY + (view.heightMm - ymm) * state.scale;
  return [px, py];
}

function wallMmToPx(offsetMm, heightMm) {
  const view = state.view;
  if (!view || view.type !== 'wall') return [0, 0];
  const clampedOffset = clamp(offsetMm, 0, view.widthMm);
  const clampedHeight = clamp(heightMm, 0, view.heightMm);
  const x = view.originX + clampedOffset * state.scale;
  const y = view.originY + (view.heightMm - clampedHeight) * state.scale;
  return [x, y];
}

function svgPoint(evt) {
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX; pt.y = evt.clientY;
  const ctm = svg.getScreenCTM();
  return ctm ? pt.matrixTransform(ctm.inverse()) : pt;
}

function svgPointToRoomMm(pt) {
  const view = state.view;
  if (!view) return { x: 0, y: 0 };
  const x0 = view.originX;
  const y0 = view.originY;
  if (view.type === 'wall') {
    const offset = (pt.x - x0) / state.scale;
    const height = view.heightMm - ((pt.y - y0) / state.scale);
    return { x: offset, y: height };
  }
  const xmm = (pt.x - x0) / state.scale;
  const ymm = view.heightMm - ((pt.y - y0) / state.scale);
  return { x: xmm, y: ymm };
}

function clampPointToRoom(pt) {
  if (isWallOrientation()) {
    const view = state.view;
    if (!view) return pt;
    return {
      x: clamp(pt.x, 0, view.widthMm),
      y: clamp(pt.y, 0, view.heightMm)
    };
  }
  return {
    x: clamp(pt.x, 0, state.Wmm),
    y: clamp(pt.y, 0, state.Lmm)
  };
}

function baseWallDefinitions() {
  const W = state.Wmm;
  const L = state.Lmm;
  return [
    { ref: 'base:1', label: `Wall 1 (y=0)`, start: { x: 0, y: 0 }, end: { x: W, y: 0 }, thickness: BASE_WALL_THICKNESS },
    { ref: 'base:2', label: `Wall 2 (x=W)`, start: { x: W, y: 0 }, end: { x: W, y: L }, thickness: BASE_WALL_THICKNESS },
    { ref: 'base:3', label: `Wall 3 (y=L)`, start: { x: W, y: L }, end: { x: 0, y: L }, thickness: BASE_WALL_THICKNESS },
    { ref: 'base:4', label: `Wall 4 (x=0)`, start: { x: 0, y: L }, end: { x: 0, y: 0 }, thickness: BASE_WALL_THICKNESS }
  ];
}

function getCustomWallById(id) { return state.customWalls.find(w => w.id === id); }

function enrichWallGeometry(wall) {
  const dx = wall.end.x - wall.start.x;
  const dy = wall.end.y - wall.start.y;
  const length = Math.hypot(dx, dy);
  if (length < 1e-6) return null;
  const tangent = { x: dx / length, y: dy / length };
  const normal = { x: -tangent.y, y: tangent.x };
  return { ...wall, length, tangent, normal };
}

function getWallGeometry(ref) {
  if (!ref) return null;
  if (typeof ref === 'number') {
    ref = `base:${ref}`;
  }
  if (/^\d$/.test(ref)) {
    ref = `base:${ref}`;
  }
  if (ref.startsWith('base:')) {
    const wall = baseWallDefinitions().find(w => w.ref === ref);
    return wall ? enrichWallGeometry(wall) : null;
  }
  if (ref.startsWith('custom:')) {
    const id = ref.split(':')[1];
    const wall = getCustomWallById(id);
    if (!wall) return null;
    return enrichWallGeometry({
      ref,
      label: wall.name || `Custom Wall`,
      start: { x: wall.x1, y: wall.y1 },
      end: { x: wall.x2, y: wall.y2 },
      thickness: wall.thickness || BASE_WALL_THICKNESS
    });
  }
  return null;
}

function listAllWalls() {
  const base = baseWallDefinitions();
  const customs = state.customWalls.map((w, i) => ({
    ref: `custom:${w.id}`,
    label: w.name || `Custom Wall ${i + 1}`,
    start: { x: w.x1, y: w.y1 },
    end: { x: w.x2, y: w.y2 },
    thickness: w.thickness || BASE_WALL_THICKNESS
  }));
  return [...base, ...customs].map(enrichWallGeometry).filter(Boolean);
}

function orientationType() {
  return state.orientation && state.orientation.type ? state.orientation.type : 'floor';
}

function isPlanViewActive() {
  const type = orientationType();
  return type === 'floor' || type === 'ceiling';
}

function isWallOrientation() {
  return orientationType() === 'wall';
}

function parseOrientationKey(key) {
  if (!key || typeof key !== 'string') {
    return { type: 'floor' };
  }
  if (key === 'floor') return { type: 'floor' };
  if (key === 'ceiling') return { type: 'ceiling' };
  if (key.startsWith('wall:')) {
    const ref = key.slice(5);
    return { type: 'wall', ref };
  }
  return { type: 'floor' };
}

function orientationKeyFromState(orientation) {
  if (!orientation || typeof orientation !== 'object') return 'floor';
  if (orientation.type === 'floor') return 'floor';
  if (orientation.type === 'ceiling') return 'ceiling';
  if (orientation.type === 'wall') {
    const ref = orientation.ref || '';
    return ref ? `wall:${ref}` : 'wall';
  }
  return 'floor';
}

function describeOrientation(orientation) {
  if (!orientation || typeof orientation !== 'object') {
    return 'Viewing Floor Plan';
  }
  if (orientation.type === 'floor') {
    return 'Viewing Floor Plan';
  }
  if (orientation.type === 'ceiling') {
    return 'Viewing Ceiling Plan';
  }
  if (orientation.type === 'wall') {
    const geom = getWallGeometry(orientation.ref);
    if (geom) {
      return `Viewing ${geom.label}`;
    }
    return 'Viewing Wall Elevation';
  }
  return 'Viewing Floor Plan';
}

function updateOrientationActiveState() {
  const activeKey = orientationKeyFromState(state.orientation);
  if (Array.isArray(orientationButtons) && orientationButtons.length > 0) {
    orientationButtons.forEach(btn => {
      const key = btn.dataset.orientation;
      const isActive = key === activeKey;
      btn.dataset.active = isActive ? 'true' : 'false';
      btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }
  if (viewSelectedWallBtn) {
    const isCustomWall = state.orientation?.type === 'wall'
      && state.orientation?.ref
      && !/^base:(?:1|2|3|4)$/.test(state.orientation.ref);
    viewSelectedWallBtn.dataset.active = isCustomWall ? 'true' : 'false';
    viewSelectedWallBtn.setAttribute('aria-pressed', isCustomWall ? 'true' : 'false');
    const baseLabel = 'View Selected';
    if (isCustomWall) {
      const geom = getWallGeometry(state.orientation.ref);
      const label = geom ? geom.label : 'Custom Wall';
      viewSelectedWallBtn.textContent = `${baseLabel} (${label})`;
    } else {
      viewSelectedWallBtn.textContent = baseLabel;
    }
  }
}

function setOrientation(key, { announce = false, skipRender = false } = {}) {
  state.orientation = parseOrientationKey(key);
  drag = null;
  drawWallState = null;
  recomputeScale();
  if (skipRender) {
    updateOrientationActiveState();
    renderScaleOverlay();
  } else {
    render();
  }
  if (announce && hud) {
    const message = describeOrientation(state.orientation);
    hud.textContent = message;
    hudTransient = message;
  }
}

function pointAlongWall(geom, offset) {
  const dist = clamp(offset, 0, geom.length);
  return {
    x: geom.start.x + geom.tangent.x * dist,
    y: geom.start.y + geom.tangent.y * dist
  };
}

function projectPointOntoWall(geom, point) {
  const px = point.x - geom.start.x;
  const py = point.y - geom.start.y;
  const along = px * geom.tangent.x + py * geom.tangent.y;
  const distance = px * geom.normal.x + py * geom.normal.y;
  const clamped = clamp(along, 0, geom.length);
  return {
    s: clamped,
    rawS: along,
    distance,
    point: {
      x: geom.start.x + geom.tangent.x * clamped,
      y: geom.start.y + geom.tangent.y * clamped
    }
  };
}

function wallShToXY(wallRef, s, depthMm) {
  const geom = getWallGeometry(wallRef);
  if (!geom) return null;
  const offset = clamp(s, 0, geom.length);
  const baseMm = pointAlongWall(geom, offset);
  const magnitude = clamp(Math.abs(depthMm), 0, 4000);
  const direction = depthMm < 0 ? -1 : 1;
  const tipMm = {
    x: baseMm.x + geom.normal.x * magnitude * direction,
    y: baseMm.y + geom.normal.y * magnitude * direction
  };
  const basePx = mmToPx(baseMm.x, baseMm.y);
  const tipPx = mmToPx(tipMm.x, tipMm.y);
  return { base: basePx, tip: tipPx, geom };
}

function updateWallSelect() {
  if (!wallSel) return;
  const prev = wallSel.value;
  wallSel.innerHTML = '';
  const walls = listAllWalls();
  walls.forEach((w, idx) => {
    const opt = document.createElement('option');
    opt.value = w.ref;
    opt.textContent = w.label || `Wall ${idx + 1}`;
    wallSel.appendChild(opt);
  });
  if (walls.length === 0) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'No walls available';
    wallSel.appendChild(opt);
  }
  if (prev && [...wallSel.options].some(o => o.value === prev)) {
    wallSel.value = prev;
  }
}

function setMode(mode) {
  state.mode = mode;
  bodyEl.dataset.mode = mode;
  roomTypeSel.value = mode;
  if (mode === 'basic') {
    state.selectedSurface = { type: 'floor' };
    setOrientation('floor', { skipRender: true });
  }
  if (mode !== 'custom') {
    drawWallState = null;
  }
  updateWallSelect();
  render();
}

function setSelectedSurface(surface, { skipRender = false } = {}) {
  state.selectedSurface = surface;
  if (skipRender) {
    renderSelection();
    hud.textContent = hudTransient || defaultHudMessage();
    hudTransient = null;
  } else {
    render();
  }
}

function clampStateToRoom() {
  state.floorItems.forEach(it => {
    it.x = clamp(it.x, 0, state.Wmm);
    it.y = clamp(it.y, 0, state.Lmm);
  });
  state.customWalls.forEach(w => {
    const start = clampPointToRoom({ x: w.x1, y: w.y1 });
    const end = clampPointToRoom({ x: w.x2, y: w.y2 });
    w.x1 = start.x; w.y1 = start.y;
    w.x2 = end.x; w.y2 = end.y;
  });
  state.wallItems.forEach(it => {
    const geom = getWallGeometry(it.wall);
    if (!geom) return;
    it.s = clamp(it.s, 0, geom.length);
    it.h = clamp(it.h, 0, 4000);
    if (typeof it.mountHeight_mm === 'number') {
      it.mountHeight_mm = clamp(it.mountHeight_mm, 0, DEFAULT_ROOM_HEIGHT_MM);
    }
  });
  state.doors.forEach(door => {
    const geom = getWallGeometry(door.wall);
    if (!geom) return;
    const maxOffset = Math.max(0, geom.length - door.width);
    door.offset = clamp(door.offset, 0, maxOffset);
  });
}

function defaultHudMessage() {
  const snapStr = `Snap: ${state.snap} mm` + (state.imperial ? ` (${mmToIn(state.snap).toFixed(2)} in)` : '');
  let sel = 'Floor';
  const surface = state.selectedSurface;
  if (surface?.type === 'wall') {
    const geom = getWallGeometry(surface.ref);
    sel = geom ? geom.label : 'Wall';
  } else if (surface?.type === 'floorItem') {
    const item = state.floorItems.find(f => f.id === surface.id);
    const def = item ? FLOOR_ITEM_DEFS[item.type] || FLOOR_ITEM_DEFS.floorBox : null;
    sel = def ? def.label : 'Floor item';
  } else if (surface?.type === 'wallItem') {
    const item = state.wallItems.find(w => w.id === surface.id);
    if (item) {
      const def = WALL_ITEM_DEFS[item.type] || WALL_ITEM_DEFS.socket;
      const geom = getWallGeometry(item.wall);
      const label = def.label || 'Wall item';
      sel = geom ? `${label} on ${geom.label}` : label;
    } else {
      sel = 'Wall item';
    }
  } else if (surface?.type === 'door') {
    const door = state.doors.find(d => d.id === surface.id);
    const geom = door ? getWallGeometry(door.wall) : null;
    sel = geom ? `Door on ${geom.label}` : 'Door';
  }
  return `${snapStr} | Selected: ${sel}`;
}

function render() {
  updateWallSelect();
  const type = orientationType();
  if (svg) {
    svg.dataset.orientation = type;
    svg.setAttribute('data-orientation', type);
  }
  if (isWallOrientation()) {
    renderWallOrientation();
  } else {
    renderPlanOrientation();
  }
  updateOrientationActiveState();
  renderScaleOverlay();
  hud.textContent = hudTransient || defaultHudMessage();
  hudTransient = null;
  maybePersistLayout();
}

function renderPlanOrientation() {
  if (wallElevationLayer) {
    wallElevationLayer.innerHTML = '';
  }
  renderBaseWallsOverlay();
  renderWallLabels();
  renderCustomWalls();
  renderDoors();
  renderWallItems();
  renderFloorItems();
  renderSelection();
}

function renderWallOrientation() {
  if (!wallElevationLayer) return;
  wallElevationLayer.innerHTML = '';
  delete svg.dataset.ceilingView;
  const view = state.view;
  const geom = view && view.wallGeom ? view.wallGeom : null;
  const widthPx = Number(roomRect.getAttribute('width')) || 0;
  const heightPx = Number(roomRect.getAttribute('height')) || 0;
  const x0 = view ? view.originX : Number(roomRect.getAttribute('x'));
  const y0 = view ? view.originY : Number(roomRect.getAttribute('y'));

  if (!geom) {
    const fallback = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    fallback.setAttribute('x', x0 + widthPx / 2);
    fallback.setAttribute('y', y0 + heightPx / 2);
    fallback.setAttribute('text-anchor', 'middle');
    fallback.setAttribute('font-size', 16);
    fallback.setAttribute('fill', '#0f172a');
    fallback.textContent = 'Select a wall to preview elevation.';
    wallElevationLayer.appendChild(fallback);
    return;
  }

  const backdrop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  backdrop.setAttribute('x', x0);
  backdrop.setAttribute('y', y0);
  backdrop.setAttribute('width', widthPx);
  backdrop.setAttribute('height', heightPx);
  backdrop.classList.add('wall-elevation-backdrop');
  if (state.selectedSurface?.type === 'wall' && state.selectedSurface.ref === geom.ref) {
    backdrop.dataset.selected = 'true';
  }
  wallElevationLayer.appendChild(backdrop);

  const floorLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  floorLine.setAttribute('x1', x0);
  floorLine.setAttribute('y1', y0 + heightPx);
  floorLine.setAttribute('x2', x0 + widthPx);
  floorLine.setAttribute('y2', y0 + heightPx);
  floorLine.classList.add('wall-elevation-axis');
  floorLine.dataset.kind = 'floor';
  wallElevationLayer.appendChild(floorLine);

  const ceilingLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  ceilingLine.setAttribute('x1', x0);
  ceilingLine.setAttribute('y1', y0);
  ceilingLine.setAttribute('x2', x0 + widthPx);
  ceilingLine.setAttribute('y2', y0);
  ceilingLine.classList.add('wall-elevation-axis');
  ceilingLine.dataset.kind = 'ceiling';
  wallElevationLayer.appendChild(ceilingLine);

  const wallLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  wallLabel.setAttribute('x', x0 + widthPx / 2);
  wallLabel.setAttribute('y', Math.max(28, y0 - 10));
  wallLabel.setAttribute('text-anchor', 'middle');
  wallLabel.setAttribute('font-size', 16);
  wallLabel.setAttribute('font-weight', '600');
  wallLabel.setAttribute('fill', '#0f172a');
  wallLabel.textContent = geom.label || 'Wall Elevation';
  wallElevationLayer.appendChild(wallLabel);

  const ceilingLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  ceilingLabel.setAttribute('x', x0 + widthPx + 8);
  ceilingLabel.setAttribute('y', y0 + 14);
  ceilingLabel.setAttribute('font-size', 11);
  ceilingLabel.setAttribute('fill', '#334155');
  ceilingLabel.textContent = fmtLen(view.heightMm || DEFAULT_ROOM_HEIGHT_MM);
  wallElevationLayer.appendChild(ceilingLabel);

  const doorHeightMm = Math.min(DOOR_ELEVATION_HEIGHT_MM, view.heightMm || DEFAULT_ROOM_HEIGHT_MM);
  state.doors
    .filter(door => door.wall === geom.ref)
    .forEach(door => {
      const maxOffset = Math.max(0, geom.length - door.width);
      const offset = clamp(door.offset, 0, maxOffset);
      const doorWidthPx = Math.min(door.width, view.widthMm) * state.scale;
      const doorX = x0 + offset * state.scale;
      const doorY = y0 + heightPx - doorHeightMm * state.scale;
      const doorRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      doorRect.setAttribute('x', doorX);
      doorRect.setAttribute('y', doorY);
      doorRect.setAttribute('width', doorWidthPx);
      doorRect.setAttribute('height', doorHeightMm * state.scale);
      doorRect.classList.add('wall-elevation-door');
      if (state.selectedSurface?.type === 'door' && state.selectedSurface.id === door.id) {
        doorRect.dataset.selected = 'true';
      }
      wallElevationLayer.appendChild(doorRect);

      const doorLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      doorLabel.setAttribute('x', doorX + doorWidthPx / 2);
      doorLabel.setAttribute('y', Math.max(y0 + 16, doorY - 8));
      doorLabel.setAttribute('text-anchor', 'middle');
      doorLabel.setAttribute('font-size', 11);
      doorLabel.setAttribute('fill', '#1f2937');
      doorLabel.textContent = `Door Â· ${fmtLen(door.width)}`;
      wallElevationLayer.appendChild(doorLabel);
    });

  const items = state.wallItems.filter(it => it.wall === geom.ref);
  items.forEach(item => {
    const def = WALL_ITEM_DEFS[item.type] || WALL_ITEM_DEFS.socket;
    const mountHeight = clamp(
      typeof item.mountHeight_mm === 'number'
        ? item.mountHeight_mm
        : def.mountHeightMm !== undefined
          ? def.mountHeightMm
          : 1200,
      0,
      view.heightMm || DEFAULT_ROOM_HEIGHT_MM
    );
    const basePt = wallMmToPx(item.s, 0);
    const mountPt = wallMmToPx(item.s, mountHeight);
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.classList.add('wall-elevation-item');
    const isSelected = state.selectedSurface?.type === 'wallItem' && state.selectedSurface.id === item.id;
    if (isSelected) {
      group.dataset.selected = 'true';
    }

    const stem = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    stem.setAttribute('x1', basePt[0]);
    stem.setAttribute('y1', basePt[1]);
    stem.setAttribute('x2', mountPt[0]);
    stem.setAttribute('y2', mountPt[1]);
    stem.classList.add('wall-elevation-height');
    group.appendChild(stem);

    const size = 32;
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', mountPt[0] - size / 2);
    rect.setAttribute('y', mountPt[1] - size / 2);
    rect.setAttribute('width', size);
    rect.setAttribute('height', size);
    rect.setAttribute('rx', 6);
    rect.setAttribute('fill', def.fill);
    rect.setAttribute('stroke', def.stroke);
    group.appendChild(rect);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', mountPt[0]);
    label.setAttribute('y', mountPt[1] + size / 2 + 14);
    label.setAttribute('text-anchor', 'middle');
    label.textContent = def.label;
    group.appendChild(label);

    const heightLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    heightLabel.setAttribute('x', mountPt[0] + size / 2 + 6);
    heightLabel.setAttribute('y', mountPt[1] - size / 2);
    heightLabel.setAttribute('font-size', 11);
    heightLabel.setAttribute('fill', '#1e293b');
    heightLabel.textContent = fmtLen(mountHeight);
    group.appendChild(heightLabel);

    wallElevationLayer.appendChild(group);
  });

  if (items.length === 0 && state.doors.every(door => door.wall !== geom.ref)) {
    const hint = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    hint.setAttribute('x', x0 + widthPx / 2);
    hint.setAttribute('y', y0 + heightPx / 2);
    hint.setAttribute('text-anchor', 'middle');
    hint.setAttribute('font-size', 13);
    hint.setAttribute('fill', '#475569');
    hint.textContent = 'No wall items on this elevation yet.';
    wallElevationLayer.appendChild(hint);
  }
}

function renderScaleOverlay() {
  if (!scaleOverlayG) return;
  if (!SCALE_OVERLAY_CONFIG.enabled) return;
  scaleOverlayG.innerHTML = '';
  const view = state.view;
  if (!view) return;
  if (isWallOrientation()) {
    renderWallScaleOverlay(view);
  } else {
    renderPlanScaleOverlay(view);
  }
}

function renderPlanScaleOverlay(view) {
  const horizontalMm = chooseScaleLengthMm(view.widthMm, state.scale, { snapHint: state.snap });
  const verticalMm = chooseScaleLengthMm(view.heightMm, state.scale, { snapHint: state.snap });
  const baselineY = Math.min(610, view.originY + view.heightMm * state.scale + 32);
  const startX = view.originX;
  if (horizontalMm > 0) {
    const widthPx = horizontalMm * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', startX);
    line.setAttribute('y1', baselineY);
    line.setAttribute('x2', startX + widthPx);
    line.setAttribute('y2', baselineY);
    line.classList.add('scale-bar-line');
    scaleOverlayG.appendChild(line);

    const leftTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    leftTick.setAttribute('x1', startX);
    leftTick.setAttribute('y1', baselineY - 6);
    leftTick.setAttribute('x2', startX);
    leftTick.setAttribute('y2', baselineY + 6);
    leftTick.classList.add('scale-bar-tick');
    scaleOverlayG.appendChild(leftTick);

    const rightTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    rightTick.setAttribute('x1', startX + widthPx);
    rightTick.setAttribute('y1', baselineY - 6);
    rightTick.setAttribute('x2', startX + widthPx);
    rightTick.setAttribute('y2', baselineY + 6);
    rightTick.classList.add('scale-bar-tick');
    scaleOverlayG.appendChild(rightTick);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', startX + widthPx / 2);
    label.setAttribute('y', baselineY + 10);
    label.setAttribute('text-anchor', 'middle');
    label.classList.add('scale-bar-label');
    label.textContent = fmtLen(horizontalMm);
    scaleOverlayG.appendChild(label);
  }

  if (verticalMm > 0) {
    const heightPx = verticalMm * state.scale;
    const baseX = Math.max(32, view.originX - 36);
    const bottomY = view.originY + view.heightMm * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', baseX);
    line.setAttribute('y1', bottomY);
    line.setAttribute('x2', baseX);
    line.setAttribute('y2', bottomY - heightPx);
    line.classList.add('scale-bar-line');
    scaleOverlayG.appendChild(line);

    const bottomTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    bottomTick.setAttribute('x1', baseX - 6);
    bottomTick.setAttribute('y1', bottomY);
    bottomTick.setAttribute('x2', baseX + 6);
    bottomTick.setAttribute('y2', bottomY);
    bottomTick.classList.add('scale-bar-tick');
    scaleOverlayG.appendChild(bottomTick);

    const topTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    topTick.setAttribute('x1', baseX - 6);
    topTick.setAttribute('y1', bottomY - heightPx);
    topTick.setAttribute('x2', baseX + 6);
    topTick.setAttribute('y2', bottomY - heightPx);
    topTick.classList.add('scale-bar-tick');
    scaleOverlayG.appendChild(topTick);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', baseX - 8);
    label.setAttribute('y', bottomY - heightPx / 2);
    label.setAttribute('text-anchor', 'end');
    label.setAttribute('dominant-baseline', 'middle');
    label.textContent = fmtLen(verticalMm);
    scaleOverlayG.appendChild(label);
  }
}

function renderWallScaleOverlay(view) {
  const horizontalMm = chooseScaleLengthMm(view.widthMm, state.scale, { snapHint: state.snap });
  const verticalMm = chooseScaleLengthMm(view.heightMm, state.scale, { snapHint: 100 });
  const baselineY = view.originY + view.heightMm * state.scale + 24;
  const startX = view.originX;
  if (horizontalMm > 0) {
    const widthPx = horizontalMm * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', startX);
    line.setAttribute('y1', baselineY);
    line.setAttribute('x2', startX + widthPx);
    line.setAttribute('y2', baselineY);
    line.classList.add('scale-bar-line');
    scaleOverlayG.appendChild(line);

    const leftTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    leftTick.setAttribute('x1', startX);
    leftTick.setAttribute('y1', baselineY - 6);
    leftTick.setAttribute('x2', startX);
    leftTick.setAttribute('y2', baselineY + 6);
    leftTick.classList.add('scale-bar-tick');
    scaleOverlayG.appendChild(leftTick);

    const rightTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    rightTick.setAttribute('x1', startX + widthPx);
    rightTick.setAttribute('y1', baselineY - 6);
    rightTick.setAttribute('x2', startX + widthPx);
    rightTick.setAttribute('y2', baselineY + 6);
    rightTick.classList.add('scale-bar-tick');
    scaleOverlayG.appendChild(rightTick);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', startX + widthPx / 2);
    label.setAttribute('y', baselineY + 12);
    label.setAttribute('text-anchor', 'middle');
    label.textContent = fmtLen(horizontalMm);
    scaleOverlayG.appendChild(label);
  }

  if (verticalMm > 0) {
    const heightPx = verticalMm * state.scale;
    const baseX = Math.max(32, view.originX - 28);
    const bottomY = view.originY + view.heightMm * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', baseX);
    line.setAttribute('y1', bottomY);
    line.setAttribute('x2', baseX);
    line.setAttribute('y2', bottomY - heightPx);
    line.classList.add('scale-bar-line');
    scaleOverlayG.appendChild(line);

    const bottomTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    bottomTick.setAttribute('x1', baseX - 6);
    bottomTick.setAttribute('y1', bottomY);
    bottomTick.setAttribute('x2', baseX + 6);
    bottomTick.setAttribute('y2', bottomY);
    bottomTick.classList.add('scale-bar-tick');
    scaleOverlayG.appendChild(bottomTick);

    const topTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    topTick.setAttribute('x1', baseX - 6);
    topTick.setAttribute('y1', bottomY - heightPx);
    topTick.setAttribute('x2', baseX + 6);
    topTick.setAttribute('y2', bottomY - heightPx);
    topTick.classList.add('scale-bar-tick');
    scaleOverlayG.appendChild(topTick);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', baseX - 8);
    label.setAttribute('y', bottomY - heightPx / 2);
    label.setAttribute('text-anchor', 'end');
    label.setAttribute('dominant-baseline', 'middle');
    label.textContent = fmtLen(verticalMm);
    scaleOverlayG.appendChild(label);
  }
}

function chooseScaleLengthMm(availableMm, scale, { snapHint = 100, minPx = 80, maxPx = 220 } = {}) {
  if (!Number.isFinite(availableMm) || availableMm <= 0) return 0;
  if (!Number.isFinite(scale) || scale <= 0) return 0;
  const snap = Math.max(10, snapHint || 10);
  let length = snap;
  while (length * scale < minPx && length < availableMm) {
    length += snap;
  }
  while (length * scale > maxPx && length > snap) {
    length -= snap;
  }
  if (length > availableMm) length = availableMm;
  if (length * scale < minPx && availableMm * scale >= minPx) {
    length = availableMm;
  }
  return length > 0 ? length : 0;
}

function renderBaseWallsOverlay() {
  baseWallsG.innerHTML = '';
  baseWallDefinitions().forEach(w => {
    const geom = enrichWallGeometry(w);
    if (!geom) return;
    const startPx = mmToPx(geom.start.x, geom.start.y);
    const endPx = mmToPx(geom.end.x, geom.end.y);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', startPx[0]);
    line.setAttribute('y1', startPx[1]);
    line.setAttribute('x2', endPx[0]);
    line.setAttribute('y2', endPx[1]);
    line.setAttribute('stroke', 'transparent');
    line.setAttribute('stroke-width', Math.max(geom.thickness * state.scale, 12));
    line.dataset.wallRef = geom.ref;
    line.addEventListener('pointerdown', evt => {
      if (state.mode !== 'custom') {
        setSelectedSurface({ type: 'wall', ref: geom.ref });
        evt.preventDefault();
        return;
      }
      setSelectedSurface({ type: 'wall', ref: geom.ref });
      evt.preventDefault();
    });
    baseWallsG.appendChild(line);
  });
}

function renderWallLabels() {
  wallLabelsG.innerHTML = '';
  baseWallDefinitions().forEach((w, idx) => {
    const geom = enrichWallGeometry(w);
    if (!geom) return;
    const mid = {
      x: (geom.start.x + geom.end.x) / 2,
      y: (geom.start.y + geom.end.y) / 2
    };
    const offsetMm = (geom.thickness || BASE_WALL_THICKNESS) / 2 + 400;
    const labelPt = {
      x: mid.x - geom.normal.x * offsetMm,
      y: mid.y - geom.normal.y * offsetMm
    };
    const [lx, ly] = mmToPx(labelPt.x, labelPt.y);
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', lx);
    text.setAttribute('y', ly);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('alignment-baseline', 'middle');
    text.classList.add('wall-label');
    text.textContent = w.label || `Wall ${idx + 1}`;
    wallLabelsG.appendChild(text);
  });
}

function renderSelection() {
  selectionG.innerHTML = '';
  const isFloor = state.selectedSurface?.type === 'floor';
  roomRect.classList.toggle('floor-selected', !!isFloor);
  let wallRef = null;
  if (state.selectedSurface?.type === 'wall') {
    wallRef = state.selectedSurface.ref;
  } else if (state.selectedSurface?.type === 'wallItem') {
    const item = state.wallItems.find(w => w.id === state.selectedSurface.id);
    wallRef = item?.wall;
  } else if (state.selectedSurface?.type === 'door') {
    const door = state.doors.find(d => d.id === state.selectedSurface.id);
    wallRef = door?.wall;
  }
  if (wallRef) {
    const geom = getWallGeometry(wallRef);
    if (!geom) return;
    const start = mmToPx(geom.start.x, geom.start.y);
    const end = mmToPx(geom.end.x, geom.end.y);
    const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    highlight.setAttribute('x1', start[0]);
    highlight.setAttribute('y1', start[1]);
    highlight.setAttribute('x2', end[0]);
    highlight.setAttribute('y2', end[1]);
    highlight.setAttribute('stroke', '#1976d2');
    highlight.setAttribute('stroke-width', Math.max(geom.thickness * state.scale + 4, 6));
    highlight.setAttribute('stroke-linecap', 'round');
    selectionG.appendChild(highlight);
  }
}

function renderCustomWalls() {
  customWallsG.innerHTML = '';
  state.customWalls.forEach(wall => {
    const geom = getWallGeometry(`custom:${wall.id}`);
    if (!geom) return;
    const start = mmToPx(geom.start.x, geom.start.y);
    const end = mmToPx(geom.end.x, geom.end.y);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', start[0]);
    line.setAttribute('y1', start[1]);
    line.setAttribute('x2', end[0]);
    line.setAttribute('y2', end[1]);
    line.setAttribute('stroke', '#444');
    line.setAttribute('stroke-width', Math.max(geom.thickness * state.scale, 4));
    line.setAttribute('stroke-linecap', 'round');
    line.classList.add('custom-wall-line');
    line.dataset.wallId = wall.id;
    line.dataset.wallRef = geom.ref;
    line.addEventListener('pointerdown', handleCustomWallLineDown);
    customWallsG.appendChild(line);

    const handleStart = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    handleStart.setAttribute('cx', start[0]);
    handleStart.setAttribute('cy', start[1]);
    handleStart.setAttribute('r', 6);
    handleStart.classList.add('handle');
    handleStart.dataset.wallId = wall.id;
    handleStart.dataset.handle = 'start';
    handleStart.addEventListener('pointerdown', handleWallHandleDown);
    customWallsG.appendChild(handleStart);

    const handleEnd = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    handleEnd.setAttribute('cx', end[0]);
    handleEnd.setAttribute('cy', end[1]);
    handleEnd.setAttribute('r', 6);
    handleEnd.classList.add('handle');
    handleEnd.dataset.wallId = wall.id;
    handleEnd.dataset.handle = 'end';
    handleEnd.addEventListener('pointerdown', handleWallHandleDown);
    customWallsG.appendChild(handleEnd);
  });
}

function renderDoors() {
  doorsG.innerHTML = '';
  state.doors.forEach(door => {
    const geom = getWallGeometry(door.wall);
    if (!geom) return;
    const startMm = pointAlongWall(geom, door.offset);
    const endMm = pointAlongWall(geom, door.offset + door.width);
    const startPx = mmToPx(startMm.x, startMm.y);
    const endPx = mmToPx(endMm.x, endMm.y);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', startPx[0]);
    line.setAttribute('y1', startPx[1]);
    line.setAttribute('x2', endPx[0]);
    line.setAttribute('y2', endPx[1]);
    line.setAttribute('stroke', '#2e7d32');
    line.setAttribute('stroke-width', Math.max((door.thickness || DOOR_DEFAULT_THICKNESS) * state.scale, 4));
    line.setAttribute('stroke-linecap', 'butt');
    line.dataset.doorId = door.id;
    line.addEventListener('pointerdown', handleDoorDragStart);
    if (state.selectedSurface?.type === 'door' && state.selectedSurface.id === door.id) {
      line.classList.add('selected-door');
    }
    doorsG.appendChild(line);
  });
}

function renderWallItems() {
  wallItemsG.innerHTML = '';
  state.wallItems.forEach(it => {
    const def = WALL_ITEM_DEFS[it.type] || WALL_ITEM_DEFS.socket;
    const directions = def.depthDirections && def.depthDirections.length ? def.depthDirections : [1];
    const depthMm = toNumber(it.h, def.defaultDepth);
    const primaryData = wallShToXY(it.wall, it.s, depthMm * directions[0]);
    if (!primaryData) return;
    const base = primaryData.base;
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const wh = 16;
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    marker.setAttribute('x', base[0] - wh / 2);
    marker.setAttribute('y', base[1] - wh / 2);
    marker.setAttribute('width', wh);
    marker.setAttribute('height', wh);
    marker.setAttribute('fill', def.fill);
    marker.setAttribute('stroke', def.stroke);
    marker.dataset.wallItemId = it.id;
    marker.addEventListener('pointerdown', handleSocketAlongDragStart);

    const primaryLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    primaryLine.setAttribute('x1', base[0]);
    primaryLine.setAttribute('y1', base[1]);
    primaryLine.setAttribute('x2', primaryData.tip[0]);
    primaryLine.setAttribute('y2', primaryData.tip[1]);
    primaryLine.setAttribute('stroke', def.fill);
    primaryLine.setAttribute('stroke-width', 2);
    primaryLine.dataset.wallItemId = it.id;
    primaryLine.addEventListener('pointerdown', handleSocketHeightDragStart);

    if (state.selectedSurface?.type === 'wallItem' && state.selectedSurface.id === it.id) {
      g.classList.add('selected-wall-item');
    }

    g.appendChild(primaryLine);

    directions.slice(1).forEach(direction => {
      const alt = wallShToXY(it.wall, it.s, depthMm * direction);
      if (!alt) return;
      const extraLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      extraLine.setAttribute('x1', base[0]);
      extraLine.setAttribute('y1', base[1]);
      extraLine.setAttribute('x2', alt.tip[0]);
      extraLine.setAttribute('y2', alt.tip[1]);
      extraLine.setAttribute('stroke', def.fill);
      extraLine.setAttribute('stroke-width', 2);
      extraLine.setAttribute('stroke-dasharray', '4 4');
      extraLine.style.pointerEvents = 'none';
      g.appendChild(extraLine);
    });

    g.appendChild(marker);
    wallItemsG.appendChild(g);
  });
}

function renderFloorItems() {
  floorItemsG.innerHTML = '';
  state.floorItems.forEach(item => {
    const def = FLOOR_ITEM_DEFS[item.type] || FLOOR_ITEM_DEFS.floorBox;
    const wmm = item.w || def.w;
    const lmm = item.l || def.l;
    const wpx = wmm * state.scale;
    const lpx = lmm * state.scale;
    const [cx, cy] = mmToPx(item.x, item.y);
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.dataset.floorItemId = item.id;
    group.setAttribute('transform', `translate(${cx},${cy}) rotate(${item.rotation || 0})`);
    group.setAttribute('cursor', 'move');
    group.addEventListener('pointerdown', handleFloorDragStart);

    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', -wpx / 2);
    rect.setAttribute('y', -lpx / 2);
    rect.setAttribute('width', wpx);
    rect.setAttribute('height', lpx);
    rect.setAttribute('fill', def.fill);
    rect.setAttribute('fill-opacity', 0.45);
    rect.setAttribute('stroke', def.stroke);
    rect.setAttribute('stroke-width', 2);
    if (state.selectedSurface?.type === 'floorItem' && state.selectedSurface.id === item.id) {
      group.classList.add('selected-floor-item');
    }
    group.appendChild(rect);

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', 0);
    text.setAttribute('y', 4);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('font-size', 12);
    text.setAttribute('fill', '#111');
    text.textContent = def.label;
    group.appendChild(text);

    floorItemsG.appendChild(group);
  });
}

let drag = null;

function handleFloorDragStart(evt) {
  if (!isPlanViewActive()) return;
  const id = evt.currentTarget.dataset.floorItemId;
  const item = state.floorItems.find(f => f.id === id);
  if (!item) return;
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  setSelectedSurface({ type: 'floorItem', id }, { skipRender: true });
  drag = {
    kind: 'floor',
    id,
    offsetX: roomPt.x - item.x,
    offsetY: roomPt.y - item.y,
    captureEl: svg,
    pointerId: evt.pointerId
  };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleSocketAlongDragStart(evt) {
  if (!isPlanViewActive()) return;
  const id = evt.currentTarget.dataset.wallItemId;
  const item = state.wallItems.find(w => w.id === id);
  if (!item) return;
  setSelectedSurface({ type: 'wallItem', id }, { skipRender: true });
  drag = { kind: 'socketS', id, captureEl: svg, pointerId: evt.pointerId };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleSocketHeightDragStart(evt) {
  if (!isPlanViewActive()) return;
  const id = evt.currentTarget.dataset.wallItemId;
  const item = state.wallItems.find(w => w.id === id);
  if (!item) return;
  setSelectedSurface({ type: 'wallItem', id }, { skipRender: true });
  drag = { kind: 'socketH', id, captureEl: svg, pointerId: evt.pointerId };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleCustomWallLineDown(evt) {
  if (!isPlanViewActive()) return;
  const wallId = evt.currentTarget.dataset.wallId;
  const wallRef = evt.currentTarget.dataset.wallRef;
  setSelectedSurface({ type: 'wall', ref: wallRef }, { skipRender: true });
  const wall = getCustomWallById(wallId);
  if (!wall) return;
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  const snapped = snapPoint(roomPt);
  drag = {
    kind: 'wall-move',
    wallId,
    start: snapped,
    orig: { x1: wall.x1, y1: wall.y1, x2: wall.x2, y2: wall.y2 },
    captureEl: svg,
    pointerId: evt.pointerId
  };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleWallHandleDown(evt) {
  if (!isPlanViewActive()) return;
  const wallId = evt.currentTarget.dataset.wallId;
  const handle = evt.currentTarget.dataset.handle;
  const wall = getCustomWallById(wallId);
  if (!wall) return;
  setSelectedSurface({ type: 'wall', ref: `custom:${wallId}` }, { skipRender: true });
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  const snapped = snapPoint(roomPt);
  drag = {
    kind: 'wall-handle',
    wallId,
    handle,
    captureEl: svg,
    pointerId: evt.pointerId
  };
  drag.start = snapped;
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleDoorDragStart(evt) {
  if (!isPlanViewActive()) return;
  const id = evt.currentTarget.dataset.doorId;
  const door = state.doors.find(d => d.id === id);
  if (!door) return;
  setSelectedSurface({ type: 'door', id }, { skipRender: true });
  drag = { kind: 'door', id, captureEl: svg, pointerId: evt.pointerId };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

document.addEventListener('pointermove', evt => {
  if (!drag) return;
  if (!isPlanViewActive()) return;
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  if (drag.kind === 'floor') {
    const item = state.floorItems.find(f => f.id === drag.id);
    if (!item) return;
    const newX = snapValue(roomPt.x - drag.offsetX);
    const newY = snapValue(roomPt.y - drag.offsetY);
    item.x = clamp(newX, 0, state.Wmm);
    item.y = clamp(newY, 0, state.Lmm);
    showHud(`${FLOOR_ITEM_DEFS[item.type]?.label || 'Item'} @ (${fmtLen(item.x)}, ${fmtLen(item.y)})`);
    render();
  } else if (drag.kind === 'socketS') {
    const item = state.wallItems.find(w => w.id === drag.id);
    if (!item) return;
    const geom = getWallGeometry(item.wall);
    if (!geom) return;
    const proj = projectPointOntoWall(geom, roomPt);
    item.s = snapValue(proj.s);
    const def = WALL_ITEM_DEFS[item.type] || WALL_ITEM_DEFS.socket;
    showHud(`${def.label} offset ${fmtLen(item.s)} on ${geom.label}`);
    render();
  } else if (drag.kind === 'socketH') {
    const item = state.wallItems.find(w => w.id === drag.id);
    if (!item) return;
    const geom = getWallGeometry(item.wall);
    if (!geom) return;
    const proj = projectPointOntoWall(geom, roomPt);
    const standoff = clamp(Math.abs(proj.distance), 0, 4000);
    item.h = snapValue(standoff);
    const def = WALL_ITEM_DEFS[item.type] || WALL_ITEM_DEFS.socket;
    showHud(`${def.label} standoff ${fmtLen(item.h)} on ${geom.label}`);
    render();
  } else if (drag.kind === 'wall-move') {
    const wall = getCustomWallById(drag.wallId);
    if (!wall) return;
    const dx = roomPt.x - drag.start.x;
    const dy = roomPt.y - drag.start.y;
    const start = snapPoint({ x: drag.orig.x1 + dx, y: drag.orig.y1 + dy });
    const end = snapPoint({ x: drag.orig.x2 + dx, y: drag.orig.y2 + dy });
    const clampStart = clampPointToRoom(start);
    const clampEnd = clampPointToRoom(end);
    wall.x1 = clampStart.x;
    wall.y1 = clampStart.y;
    wall.x2 = clampEnd.x;
    wall.y2 = clampEnd.y;
    showHud(`Moved ${wall.name || 'custom wall'}`);
    render();
  } else if (drag.kind === 'wall-handle') {
    const wall = getCustomWallById(drag.wallId);
    if (!wall) return;
    const snapped = snapPoint(roomPt);
    const clamped = clampPointToRoom(snapped);
    if (drag.handle === 'start') {
      wall.x1 = clamped.x;
      wall.y1 = clamped.y;
    } else {
      wall.x2 = clamped.x;
      wall.y2 = clamped.y;
    }
    showHud(`Reshaping ${wall.name || 'custom wall'}`);
    render();
  } else if (drag.kind === 'door') {
    const door = state.doors.find(d => d.id === drag.id);
    if (!door) return;
    const geom = getWallGeometry(door.wall);
    if (!geom) return;
    const proj = projectPointOntoWall(geom, roomPt);
    const half = door.width / 2;
    const maxCenter = Math.max(half, geom.length - half);
    const centerSnapped = snapValue(proj.s);
    const center = clamp(centerSnapped, half, maxCenter);
    door.offset = clamp(center - half, 0, Math.max(0, geom.length - door.width));
    showHud(`Door position ${fmtLen(center)} along ${geom.label}`);
    render();
  }
});

document.addEventListener('pointerup', evt => {
  if (drag && drag.captureEl) {
    try {
      drag.captureEl.releasePointerCapture(drag.pointerId ?? evt.pointerId);
    } catch (e) {}
  }
  drag = null;
});

function deleteSelectedItem() {
  const surface = state.selectedSurface;
  if (!surface) return null;
  if (surface.type === 'floorItem') {
    const idx = state.floorItems.findIndex(f => f.id === surface.id);
    if (idx >= 0) {
      const [removed] = state.floorItems.splice(idx, 1);
      const def = removed ? FLOOR_ITEM_DEFS[removed.type] || FLOOR_ITEM_DEFS.floorBox : null;
      setSelectedSurface({ type: 'floor' }, { skipRender: true });
      return `${def ? def.label : 'Floor item'} removed`;
    }
  } else if (surface.type === 'wallItem') {
    const idx = state.wallItems.findIndex(w => w.id === surface.id);
    if (idx >= 0) {
      const [removed] = state.wallItems.splice(idx, 1);
      const geom = removed ? getWallGeometry(removed.wall) : null;
      setSelectedSurface(removed ? { type: 'wall', ref: removed.wall } : { type: 'floor' }, { skipRender: true });
      return `Wall item removed${geom ? ` from ${geom.label}` : ''}`;
    }
  } else if (surface.type === 'door') {
    const idx = state.doors.findIndex(d => d.id === surface.id);
    if (idx >= 0) {
      const [removed] = state.doors.splice(idx, 1);
      const geom = removed ? getWallGeometry(removed.wall) : null;
      setSelectedSurface(removed ? { type: 'wall', ref: removed.wall } : { type: 'floor' }, { skipRender: true });
      return `Door removed${geom ? ` from ${geom.label}` : ''}`;
    }
  } else if (surface.type === 'wall' && typeof surface.ref === 'string' && surface.ref.startsWith('custom:')) {
    const id = surface.ref.split(':')[1];
    const idx = state.customWalls.findIndex(w => String(w.id) === id);
    if (idx >= 0) {
      const [removed] = state.customWalls.splice(idx, 1);
      state.doors = state.doors.filter(d => d.wall !== surface.ref);
      state.wallItems = state.wallItems.filter(it => it.wall !== surface.ref);
      setSelectedSurface({ type: 'floor' }, { skipRender: true });
      return `${removed?.name || 'Custom wall'} removed`;
    }
  }
  return null;
}

document.addEventListener('keydown', evt => {
  if (evt.key !== 'Delete' && evt.key !== 'Backspace') return;
  if (isEditingFormControl(document.activeElement)) return;
  const message = deleteSelectedItem();
  if (message) {
    evt.preventDefault();
    showHud(message);
    render();
  }
});

document.addEventListener('focusin', evt => {
  const target = evt.target;
  if (!(target instanceof HTMLElement)) return;
  if (svg.contains(target)) return;
  if (state.selectedSurface?.type && state.selectedSurface.type !== 'floor') {
    setSelectedSurface({ type: 'floor' });
  }
});

svg.addEventListener('pointerdown', evt => {
  if (!isPlanViewActive()) return;
  if (!drawWallState || state.mode !== 'custom') return;
  if (evt.target.closest('[data-floor-item-id],[data-wall-item-id],[data-door-id],[data-wall-id]')) return;
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  if (!drawWallState.start) {
    drawWallState.start = snapPoint(roomPt);
    showHud('Select second point for new wall');
  } else {
    const start = drawWallState.start;
    const end = snapPoint(roomPt);
    if (Math.hypot(end.x - start.x, end.y - start.y) > 10) {
      const wall = {
        id: genId('wall'),
        name: `Custom Wall ${state.customWalls.length + 1}`,
        x1: start.x,
        y1: start.y,
        x2: end.x,
        y2: end.y,
        thickness: BASE_WALL_THICKNESS
      };
      state.customWalls.push(wall);
      showHud(`${wall.name} added`);
      setSelectedSurface({ type: 'wall', ref: `custom:${wall.id}` });
    }
    drawWallState = null;
  }
  evt.preventDefault();
  render();
});

svg.addEventListener('pointerdown', evt => {
  if (!isPlanViewActive()) return;
  if (drawWallState && state.mode === 'custom') return;
  if (evt.target.closest('[data-floor-item-id],[data-wall-item-id],[data-door-id],[data-wall-id],[data-wall-ref]')) return;
  setSelectedSurface({ type: 'floor' });
});

roomRect.addEventListener('pointerdown', evt => {
  if (!isPlanViewActive()) return;
  setSelectedSurface({ type: 'floor' });
  evt.preventDefault();
});

applyBtn.addEventListener('click', () => {
  state.Wmm = Math.max(1000, Number(Winput.value || 0));
  state.Lmm = Math.max(1000, Number(Linput.value || 0));
  state.imperial = imperialChk.checked;
  state.snap = state.imperial ? 150 : Math.max(10, Number(snapInput.value || 100));
  snapInput.value = state.snap;
  resnapAll();
  recomputeScale();
  clampStateToRoom();
  render();
});

imperialChk.addEventListener('change', () => {
  state.imperial = imperialChk.checked;
  state.snap = state.imperial ? 150 : Math.max(10, Number(snapInput.value || 100));
  snapInput.value = state.snap;
  resnapAll();
  clampStateToRoom();
  drawGrid();
  render();
});

snapInput.addEventListener('change', () => {
  if (state.imperial) return;
  state.snap = Math.max(10, Number(snapInput.value || 100));
  resnapAll();
  clampStateToRoom();
  drawGrid();
  render();
});

basicAddBtn.addEventListener('click', () => {
  const type = basicAddType.value;
  const def = FLOOR_ITEM_DEFS[type] || FLOOR_ITEM_DEFS.floorBox;
  const item = {
    id: genId('floor'),
    type,
    x: snapValue(state.Wmm / 2),
    y: snapValue(state.Lmm / 2),
    w: def.w,
    l: def.l,
    rotation: 0
  };
  state.floorItems.push(item);
  setSelectedSurface({ type: 'floorItem', id: item.id });
  showHud(`${def.label} added`);
  render();
});

addBtn.addEventListener('click', () => {
  const type = addType.value;
  if (WALL_ITEM_DEFS[type]) {
    const def = WALL_ITEM_DEFS[type];
    const wallRef = wallSel.value;
    const geom = getWallGeometry(wallRef);
    if (!geom) {
      showHud('Select a wall before adding wall items');
      return;
    }
    const s = snapValue(geom.length / 2);
    const depth = snapValue(def.defaultDepth);
    const mountHeight = def.mountHeightMm !== undefined
      ? snapValue(def.mountHeightMm)
      : snapValue(1200);
    const item = {
      id: genId(def.idPrefix || 'wallItem'),
      type,
      wall: wallRef,
      s,
      h: depth,
      mountHeight_mm: mountHeight
    };
    state.wallItems.push(item);
    setSelectedSurface({ type: 'wallItem', id: item.id });
    showHud(`${def.label} added to ${geom.label}`);
    render();
  } else {
    const def = FLOOR_ITEM_DEFS[type] || FLOOR_ITEM_DEFS.floorBox;
    const item = {
      id: genId('floor'),
      type,
      x: snapValue(state.Wmm / 2),
      y: snapValue(state.Lmm / 2),
      w: def.w,
      l: def.l,
      rotation: 0
    };
    state.floorItems.push(item);
    setSelectedSurface({ type: 'floorItem', id: item.id });
    showHud(`${def.label} added`);
    render();
  }
});

addWallBtn.addEventListener('click', () => {
  if (state.mode !== 'custom') {
    showHud('Switch to custom mode to draw walls');
    return;
  }
  drawWallState = { start: null };
  showHud('Click start point for new wall');
});

addDoorBtn.addEventListener('click', () => {
  if (state.mode !== 'custom') {
    showHud('Switch to custom mode to add doors');
    return;
  }
  if (state.selectedSurface?.type !== 'wall') {
    showHud('Select a wall before adding a door');
    return;
  }
  const geom = getWallGeometry(state.selectedSurface.ref);
  if (!geom) {
    showHud('Selected wall is not available');
    return;
  }
  const width = DOOR_DEFAULT_WIDTH;
  const maxOffset = Math.max(0, geom.length - width);
  const door = {
    id: genId('door'),
    wall: geom.ref,
    offset: snapValue(maxOffset / 2),
    width,
    thickness: DOOR_DEFAULT_THICKNESS
  };
  state.doors.push(door);
  setSelectedSurface({ type: 'door', id: door.id });
  showHud(`Door added to ${geom.label}`);
  render();
});

exportBtn.addEventListener('click', () => {
  const snapshot = snapshotLayout();
  const blob = new Blob([JSON.stringify(snapshot, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'room_survey.json';
  a.click();
  URL.revokeObjectURL(url);
});

orientationButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    const key = btn.dataset.orientation;
    if (!key) return;
    setOrientation(key, { announce: true });
  });
});

if (viewSelectedWallBtn) {
  viewSelectedWallBtn.addEventListener('click', () => {
    let wallRef = wallSel && wallSel.value;
    if (!wallRef) {
      if (state.selectedSurface?.type === 'wall') {
        wallRef = state.selectedSurface.ref;
      } else if (state.selectedSurface?.type === 'wallItem') {
        const wallItem = state.wallItems.find(w => w.id === state.selectedSurface.id);
        wallRef = wallItem ? wallItem.wall : null;
      } else if (state.selectedSurface?.type === 'door') {
        const door = state.doors.find(d => d.id === state.selectedSurface.id);
        wallRef = door ? door.wall : null;
      }
    }
    if (!wallRef) {
      showHud('Select a wall from the dropdown or canvas to view.');
      return;
    }
    const key = wallRef.startsWith('wall:') ? wallRef : `wall:${wallRef}`;
    setOrientation(key, { announce: true });
  });
}

roomTypeSel.addEventListener('change', () => {
  setMode(roomTypeSel.value);
});

// initialize
async function initializeSurvey() {
  try {
    const restored = await restorePersistedLayout({ preferRemote: true });
    if (restored && restored.data) {
      applyLayout(restored.data, {
        skipPersist: true,
        message: restored.source === 'server'
          ? 'Restored layout from server.'
          : 'Restored layout from previous session.'
      });
      return;
    }
  } catch (err) {
    console.error('Failed to load persisted layout', err);
  }
  applyDefaultPreset();
  recomputeScale();
  showHud('Loaded demo preset layout.');
  setMode('basic');
}

const CABLE_CATALOG_URL = '../../resources/layout_samples/catalog.json';
const FALLBACK_CABLE_COLORS = (function () {
  if (!window.DEFAULT_CABLE_CATALOG || !window.DEFAULT_CABLE_CATALOG.cableTypes) {
    return {};
  }
  const colors = {};
  Object.entries(window.DEFAULT_CABLE_CATALOG.cableTypes).forEach(([key, def]) => {
    colors[key] = def.color;
  });
  return colors;
})();
const DEFAULT_ROOM_HEIGHT_MM = 3000;
const CABLE_SAMPLE_SEGMENTS = 48;
const CABLE_CONTROLS_TEMPLATE = `
      <div class="panel" id="cableControls">
        <h3>Service Cables</h3>
        <label>
          Cable type
          <select id="cableType"></select>
        </label>
        <div class="note">Select a cable type, then click two sockets to connect them.</div>
        <div class="row">
          <button class="btn" id="cancelCable" disabled>Cancel selection</button>
          <button class="btn" id="deleteCable" disabled>Delete cable</button>
        </div>
        <div class="hud" id="cableHud"></div>
      </div>
`;

let cableTypeSelectEl = null;
let cancelCableBtnEl = null;
let deleteCableBtnEl = null;
let cableHudEl = null;
let cablesLayerEl = null;
let cableHandlesLayerEl = null;
let socketOverlayEl = null;
let cableCatalog = null;
let pendingCable = null;
const socketMap = new Map();
const cableCurveCache = new Map();

function getCableTypeMeta(type) {
  return (cableCatalog && cableCatalog.cableTypes && cableCatalog.cableTypes[type]) || null;
}

function getCableColor(type) {
  const meta = getCableTypeMeta(type);
  if (meta && meta.color) return meta.color;
  if (window.DEFAULT_CABLE_CATALOG && window.DEFAULT_CABLE_CATALOG.cableTypes[type]) {
    return window.DEFAULT_CABLE_CATALOG.cableTypes[type].color;
  }
  return FALLBACK_CABLE_COLORS[type] || (window.getDefaultCableColor ? window.getDefaultCableColor(type) : '#64748b');
}

async function ensureCableCatalog() {
  if (cableCatalog) return cableCatalog;
  let loaded = null;
  try {
    const resp = await fetch(CABLE_CATALOG_URL, { cache: 'no-store' });
    if (!resp.ok) {
      throw new Error(`Failed to load cable catalog: ${resp.status}`);
    }
    loaded = await resp.json();
  } catch (err) {
    console.warn('Falling back to default cable catalog', err);
  }
  if (typeof window.normalizeCableCatalogWithDefaults === 'function') {
    cableCatalog = window.normalizeCableCatalogWithDefaults(loaded);
  } else {
    cableCatalog = loaded || window.DEFAULT_CABLE_CATALOG || {};
  }
  return cableCatalog;
}

function populateCableTypeSelect() {
  if (!cableTypeSelectEl) return;
  cableTypeSelectEl.innerHTML = '';
  if (!cableCatalog || !cableCatalog.cableTypes) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'Loadingâ€¦';
    cableTypeSelectEl.appendChild(opt);
    cableTypeSelectEl.disabled = true;
    return;
  }
  cableTypeSelectEl.disabled = false;
  Object.entries(cableCatalog.cableTypes).forEach(([key, def]) => {
    const opt = document.createElement('option');
    opt.value = key;
    opt.textContent = def.label || key;
    cableTypeSelectEl.appendChild(opt);
  });
  if (cableTypeSelectEl.options.length > 0) {
    cableTypeSelectEl.value = cableTypeSelectEl.options[0].value;
  }
}

function getSocketKey(ref) {
  return `${ref.kind}:${ref.assetId}:${ref.socketId}`;
}

function listCableSockets() {
  if (!cableCatalog || !cableCatalog.assets) return [];
  const sockets = [];
  const assetsCatalog = cableCatalog.assets;
  (state.floorItems || []).forEach(item => {
    const meta = assetsCatalog[item.type];
    if (!meta || !Array.isArray(meta.connectionSockets)) return;
    meta.connectionSockets.forEach(socket => {
      sockets.push({
        kind: 'floor',
        assetId: item.id,
        assetType: item.type,
        socketId: socket.id,
        label: `${socket.label} (${item.id})`,
        anchor: socket.anchor || { u: 0.5, v: 0.5, w: 0.5 },
        allowedCableTypes: socket.allowedCableTypes || [],
        surface: socket.surface || 'floor'
      });
    });
  });
  (state.wallItems || []).forEach(item => {
    const def = WALL_ITEM_DEFS[item.type] || WALL_ITEM_DEFS.socket;
    const assetType = def.assetKey || 'wall_socket';
    const meta = assetsCatalog[assetType] || {};
    const socketsMeta = Array.isArray(meta.connectionSockets) && meta.connectionSockets.length
      ? meta.connectionSockets
      : def.fallbackSockets || [];
    socketsMeta.forEach(socket => {
      const offsetDirection = socket.offsetDirection !== undefined
        ? Math.sign(socket.offsetDirection) || 1
        : 1;
      sockets.push({
        kind: 'wall',
        assetId: item.id,
        assetType,
        socketId: socket.id,
        label: `${socket.label} (${item.id})`,
        anchor: socket.anchor || { u: 0.5, v: 0.5, w: 0.5 },
        allowedCableTypes: socket.allowedCableTypes || [],
        surface: socket.surface || 'wall',
        offsetDirection,
        defaultDepth: def.defaultDepth
      });
    });
  });
  return sockets;
}

function resolveSocketPosition(ref) {
  if (!ref) return null;
  if (ref.kind === 'floor') {
    const item = state.floorItems.find(f => f.id === ref.assetId);
    if (!item) return null;
    const assets = (cableCatalog && cableCatalog.assets) || {};
    const meta = assets[item.type];
    if (!meta) return null;
    const socket = (meta.connectionSockets || []).find(s => s.id === ref.socketId);
    if (!socket) return null;
    const anchor = socket.anchor || { u: 0.5, v: 0.5, w: 0.5 };
    const dims = meta.boundingBox_mm || {};
    const width = toNumber(item.w, dims.w || 0);
    const length = toNumber(item.l, dims.l || 0);
    const height = dims.h || DEFAULT_ROOM_HEIGHT_MM;
    const offsetX = (anchor.u - 0.5) * width;
    const offsetY = (anchor.v - 0.5) * length;
    const rad = ((item.rotation || 0) * Math.PI) / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const worldX = item.x + offsetX * cos - offsetY * sin;
    const worldY = item.y + offsetX * sin + offsetY * cos;
    const elevation = toNumber(item.elevation_mm, 0);
    const baseZ = (anchor.w || 0) * height + elevation;
    return { x: worldX, y: worldY, z: baseZ };
  }
  if (ref.kind === 'wall') {
    const item = state.wallItems.find(w => w.id === ref.assetId);
    if (!item) return null;
    const geom = getWallGeometry(item.wall);
    if (!geom) return null;
    const assets = (cableCatalog && cableCatalog.assets) || {};
    const def = WALL_ITEM_DEFS[item.type] || WALL_ITEM_DEFS.socket;
    const assetType = def.assetKey || 'wall_socket';
    const meta = assets[assetType] || {};
    const socketsMeta = Array.isArray(meta.connectionSockets) && meta.connectionSockets.length
      ? meta.connectionSockets
      : def.fallbackSockets || [];
    const socket = socketsMeta.find(s => s.id === ref.socketId) || socketsMeta[0] || null;
    const anchor = socket && socket.anchor ? socket.anchor : { u: 0.5, v: 0.5, w: 0.5 };
    const offset = clamp(toNumber(item.s, 0), 0, geom.length);
    const base = pointAlongWall(geom, offset);
    const rawDepth = toNumber(item.h, def.defaultDepth);
    const depthMagnitude = clamp(Math.abs(rawDepth), 0, 4000);
    const offsetDirection = ref.offsetDirection !== undefined
      ? Math.sign(ref.offsetDirection) || 1
      : socket && socket.offsetDirection !== undefined
        ? Math.sign(socket.offsetDirection) || 1
        : 1;
    const depth = depthMagnitude * offsetDirection;
    const tip = {
      x: base.x + geom.normal.x * depth,
      y: base.y + geom.normal.y * depth
    };
    const heightBasis = meta.boundingBox_mm && meta.boundingBox_mm.h ? meta.boundingBox_mm.h : DEFAULT_ROOM_HEIGHT_MM;
    const height = heightBasis * (anchor.w || 0.5);
    return { x: tip.x, y: tip.y, z: height };
  }
  return null;
}

function cloneCablePoint(pt) {
  if (!pt) return { x: 0, y: 0, z: 0 };
  return { x: Number(pt.x) || 0, y: Number(pt.y) || 0, z: Number(pt.z) || 0 };
}

function distance2d(a, b) {
  const dx = (b.x || 0) - (a.x || 0);
  const dy = (b.y || 0) - (a.y || 0);
  return Math.hypot(dx, dy);
}

function getCableAnchors(cable, start, end) {
  const anchors = [];
  if (start) anchors.push(cloneCablePoint(start));
  const bends = Array.isArray(cable.bendPoints) ? cable.bendPoints : [];
  bends.forEach(pt => {
    anchors.push(cloneCablePoint(pt));
  });
  if (end) anchors.push(cloneCablePoint(end));
  return anchors;
}

function defaultHandlesForSegment(start, end) {
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const length = Math.hypot(dx, dy) || 1;
  const nx = -dy / length;
  const ny = dx / length;
  const slack = length * 0.25;
  const midZ = (start.z + end.z) / 2;
  return [
    {
      x: start.x + dx * 0.25 + nx * slack,
      y: start.y + dy * 0.25 + ny * slack,
      z: midZ
    },
    {
      x: start.x + dx * 0.75 + nx * slack,
      y: start.y + dy * 0.75 + ny * slack,
      z: midZ
    }
  ];
}

function ensureCableControlPoints(cable, start, end, forceDefaults = false) {
  if (!start || !end) return [];
  if (!Array.isArray(cable.bendPoints)) cable.bendPoints = [];
  if (!Array.isArray(cable.controlPoints)) cable.controlPoints = [];
  const anchors = getCableAnchors(cable, start, end);
  const segmentCount = Math.max(anchors.length - 1, 1);
  const requiredHandles = segmentCount * 2;
  const handles = new Array(requiredHandles);
  for (let i = 0; i < segmentCount; i++) {
    const [def1, def2] = defaultHandlesForSegment(anchors[i], anchors[i + 1]);
    const existing1 = !forceDefaults ? cable.controlPoints[i * 2] : null;
    const existing2 = !forceDefaults ? cable.controlPoints[i * 2 + 1] : null;
    handles[i * 2] = existing1 ? cloneCablePoint(existing1) : def1;
    handles[i * 2 + 1] = existing2 ? cloneCablePoint(existing2) : def2;
  }
  cable.controlPoints = handles;
  return anchors;
}

function resetCableHandles(cable, start, end) {
  ensureCableControlPoints(cable, start, end, true);
}

function cubicPoint(t, p0, p1, p2, p3) {
  const it = 1 - t;
  const it2 = it * it;
  const t2 = t * t;
  const a = it2 * it;
  const b = 3 * it2 * t;
  const c = 3 * it * t2;
  const d = t * t2;
  return {
    x: a * p0.x + b * p1.x + c * p2.x + d * p3.x,
    y: a * p0.y + b * p1.y + c * p2.y + d * p3.y,
    z: a * p0.z + b * p1.z + c * p2.z + d * p3.z
  };
}

function distance3d(a, b) {
  const dx = (b.x || 0) - (a.x || 0);
  const dy = (b.y || 0) - (a.y || 0);
  const dz = (b.z || 0) - (a.z || 0);
  return Math.hypot(dx, dy, dz);
}

function updateCableMetrics(cable, start, end) {
  if (!start || !end) return;
  const anchors = ensureCableControlPoints(cable, start, end);
  if (!anchors || anchors.length < 2) return;
  let total = 0;
  const samples = [];
  for (let segment = 0; segment < anchors.length - 1; segment++) {
    const p0 = anchors[segment];
    const p3 = anchors[segment + 1];
    const c1 = cable.controlPoints[segment * 2];
    const c2 = cable.controlPoints[segment * 2 + 1];
    let prev = { x: p0.x, y: p0.y, z: p0.z };
    for (let i = 1; i <= CABLE_SAMPLE_SEGMENTS; i++) {
      const t = i / CABLE_SAMPLE_SEGMENTS;
      const point = cubicPoint(t, p0, c1, c2, p3);
      total += distance3d(prev, point);
      prev = point;
      samples.push({ segmentIndex: segment, t, point: cloneCablePoint(point) });
    }
  }
  cable.length_mm = total;
  const meta = getCableTypeMeta(cable.cableType);
  const maxLength = meta && meta.maxLength_mm ? meta.maxLength_mm : 3048;
  cable.status = total > maxLength ? 'over_limit' : 'within_limit';
  cableCurveCache.set(cable.id, {
    anchors: anchors.map(cloneCablePoint),
    controlPoints: cable.controlPoints.map(cloneCablePoint),
    samples
  });
}

function exportCableToSnapshot(cable) {
  const safePoints = (cable.controlPoints || []).map(pt => ({
    u: clamp(pt.x / state.Wmm, 0, 1),
    v: clamp(pt.y / state.Lmm, 0, 1),
    w: clamp((pt.z || 0) / DEFAULT_ROOM_HEIGHT_MM, 0, 1)
  }));
  const bendPoints = (cable.bendPoints || []).map(pt => ({
    u: clamp(pt.x / state.Wmm, 0, 1),
    v: clamp(pt.y / state.Lmm, 0, 1),
    w: clamp((pt.z || 0) / DEFAULT_ROOM_HEIGHT_MM, 0, 1)
  }));
  return {
    id: cable.id,
    cableType: cable.cableType,
    source: {
      assetId: cable.source.assetId,
      socketId: cable.source.socketId,
      kind: cable.source.kind
    },
    target: {
      assetId: cable.target.assetId,
      socketId: cable.target.socketId,
      kind: cable.target.kind
    },
    controlPoints: safePoints,
    bendPoints,
    pins: Array.isArray(cable.pins) ? cable.pins : [],
    length_mm: Math.round(cable.length_mm || 0),
    status: cable.status || 'unknown'
  };
}

function guessCableEndpointKind(assetId) {
  if (!assetId) return null;
  if ((state.floorItems || []).some(f => f.id === assetId)) return 'floor';
  if ((state.wallItems || []).some(w => w.id === assetId)) return 'wall';
  return null;
}

function normalizeCableFromLayout(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const cableType = typeof entry.cableType === 'string' ? entry.cableType : null;
  if (!cableType) return null;
  const sourceRaw = entry.source && typeof entry.source === 'object' ? entry.source : {};
  const targetRaw = entry.target && typeof entry.target === 'object' ? entry.target : {};
  const sourceAssetId = sourceRaw.assetId || entry.sourceAssetId;
  const targetAssetId = targetRaw.assetId || entry.targetAssetId;
  const sourceSocketId = sourceRaw.socketId || entry.sourceSocketId;
  const targetSocketId = targetRaw.socketId || entry.targetSocketId;
  if (!sourceAssetId || !sourceSocketId || !targetAssetId || !targetSocketId) return null;
  const sourceKind = sourceRaw.kind || guessCableEndpointKind(sourceAssetId);
  const targetKind = targetRaw.kind || guessCableEndpointKind(targetAssetId);
  if (!sourceKind || !targetKind) return null;
  const controlPoints = Array.isArray(entry.controlPoints)
    ? entry.controlPoints
        .map(pt => {
          if (!pt || typeof pt !== 'object') return null;
          const u = Number(pt.u);
          const v = Number(pt.v);
          const w = Number(pt.w != null ? pt.w : pt.z);
          if (!Number.isFinite(u) || !Number.isFinite(v)) return null;
          return {
            x: clamp(u, 0, 1) * state.Wmm,
            y: clamp(v, 0, 1) * state.Lmm,
            z: Number.isFinite(w) ? clamp(w, 0, 1) * DEFAULT_ROOM_HEIGHT_MM : 0
          };
        })
        .filter(Boolean)
    : [];
  const bendPoints = Array.isArray(entry.bendPoints)
    ? entry.bendPoints
        .map(pt => {
          if (!pt || typeof pt !== 'object') return null;
          const u = Number(pt.u);
          const v = Number(pt.v);
          const w = Number(pt.w != null ? pt.w : pt.z);
          if (!Number.isFinite(u) || !Number.isFinite(v)) return null;
          return {
            x: clamp(u, 0, 1) * state.Wmm,
            y: clamp(v, 0, 1) * state.Lmm,
            z: Number.isFinite(w) ? clamp(w, 0, 1) * DEFAULT_ROOM_HEIGHT_MM : 0
          };
        })
        .filter(Boolean)
    : [];
  return {
    id: entry.id || genId('cable'),
    cableType,
    source: { kind: sourceKind, assetId: sourceAssetId, socketId: sourceSocketId },
    target: { kind: targetKind, assetId: targetAssetId, socketId: targetSocketId },
    bendPoints,
    controlPoints,
    pins: Array.isArray(entry.pins) ? entry.pins : [],
    length_mm: toNumber(entry.length_mm, 0),
    status: entry.status || 'unknown'
  };
}

function normalizeCableArray(layout) {
  if (!layout || typeof layout !== 'object' || !Array.isArray(layout.cables)) return [];
  return layout.cables.map(normalizeCableFromLayout).filter(Boolean);
}

function pruneInvalidCables() {
  if (!Array.isArray(state.cables) || state.cables.length === 0) return;
  const next = [];
  let removed = 0;
  state.cables.forEach(cable => {
    const start = resolveSocketPosition(cable.source);
    const end = resolveSocketPosition(cable.target);
    if (start && end) {
      next.push(cable);
    } else {
      removed += 1;
    }
  });
  if (removed > 0) {
    state.cables = next;
    if (state.selectedSurface && state.selectedSurface.type === 'cable') {
      const stillExists = state.cables.some(c => c.id === state.selectedSurface.id);
      if (!stillExists) {
        setSelectedSurface({ type: 'floor' }, { skipRender: true });
      }
    }
    showHud(`Removed ${removed} cable${removed === 1 ? '' : 's'} referencing missing sockets.`);
  }
}

function createCableFromSockets(sourceSocket, targetSocket, cableType) {
  const cable = {
    id: genId('cable'),
    cableType,
    source: { kind: sourceSocket.kind, assetId: sourceSocket.assetId, socketId: sourceSocket.socketId },
    target: { kind: targetSocket.kind, assetId: targetSocket.assetId, socketId: targetSocket.socketId },
    bendPoints: [],
    controlPoints: [],
    pins: [],
    status: 'within_limit',
    length_mm: 0
  };
  const start = resolveSocketPosition(cable.source);
  const end = resolveSocketPosition(cable.target);
  ensureCableControlPoints(cable, start, end);
  updateCableMetrics(cable, start, end);
  return cable;
}

function updateCableHud() {
  if (!cableHudEl) return;
  if (pendingCable && pendingCable.socket) {
    const typeMeta = getCableTypeMeta(pendingCable.cableType);
    const label = typeMeta ? typeMeta.label : pendingCable.cableType;
    cableHudEl.textContent = `Starting ${label || 'Cable'} from ${pendingCable.socket.label}. Select a destination.`;
    if (deleteCableBtnEl) deleteCableBtnEl.disabled = true;
    return;
  }
  if (state.selectedSurface && state.selectedSurface.type === 'cable') {
    const cable = state.cables.find(c => c.id === state.selectedSurface.id);
    if (cable) {
      const meta = getCableTypeMeta(cable.cableType);
      const label = meta ? meta.label : cable.cableType;
      const status = cable.status === 'over_limit' ? 'âš ï¸ Exceeds max length' : 'Within limit';
      cableHudEl.textContent = `${label || 'Cable'} length ${fmtLen(Math.round(cable.length_mm || 0))} â€” ${status}`;
      if (deleteCableBtnEl) deleteCableBtnEl.disabled = false;
      return;
    }
  }
  cableHudEl.textContent = 'Select a cable type and click two sockets to connect them.';
  if (deleteCableBtnEl) deleteCableBtnEl.disabled = true;
}

function handleSocketPointerDown(evt) {
  if (!isPlanViewActive()) return;
  const key = evt.currentTarget.dataset.socketKey;
  const socket = socketMap.get(key);
  if (!socket) return;
  const cableType = cableTypeSelectEl && cableTypeSelectEl.value ? cableTypeSelectEl.value : null;
  if (!cableType) {
    showHud('Select a cable type before starting a connection.');
    return;
  }
  if (!socket.allowedCableTypes.includes(cableType)) {
    showHud('This socket does not accept the selected cable type.');
    return;
  }
  evt.stopPropagation();
  evt.preventDefault();
  if (!pendingCable) {
    pendingCable = { socket: { ...socket, key }, cableType };
    render();
    return;
  }
  if (pendingCable.socket.key === key) {
    pendingCable = null;
    render();
    return;
  }
  if (pendingCable.cableType !== cableType) {
    pendingCable = { socket: { ...socket, key }, cableType };
    render();
    return;
  }
  const cable = createCableFromSockets(pendingCable.socket, { ...socket, key }, cableType);
  state.cables.push(cable);
  pendingCable = null;
  setSelectedSurface({ type: 'cable', id: cable.id });
  showHud(`Connected ${cable.source.socketId} to ${cable.target.socketId}.`);
  render();
}

function handleSocketPointerEnter(evt) {
  evt.currentTarget.dataset.hover = 'true';
}

function handleSocketPointerLeave(evt) {
  evt.currentTarget.dataset.hover = 'false';
}

function handleCableHandleDown(evt) {
  if (!isPlanViewActive()) return;
  const cableId = evt.currentTarget.dataset.cableId;
  const index = Number(evt.currentTarget.dataset.handleIndex || 0);
  const cable = state.cables.find(c => c.id === cableId);
  if (!cable) return;
  setSelectedSurface({ type: 'cable', id: cableId }, { skipRender: true });
  drag = {
    kind: 'cable-handle',
    cableId,
    handleIndex: index,
    captureEl: svg,
    pointerId: evt.pointerId
  };
  svg.setPointerCapture(evt.pointerId);
  evt.stopPropagation();
  evt.preventDefault();
}

function handleCableBendDown(evt) {
  if (!isPlanViewActive()) return;
  const cableId = evt.currentTarget.dataset.cableId;
  const index = Number(evt.currentTarget.dataset.bendIndex || 0);
  const cable = state.cables.find(c => c.id === cableId);
  if (!cable) return;
  setSelectedSurface({ type: 'cable', id: cableId }, { skipRender: true });
  drag = {
    kind: 'cable-bend',
    cableId,
    bendIndex: index,
    captureEl: svg,
    pointerId: evt.pointerId
  };
  svg.setPointerCapture(evt.pointerId);
  evt.stopPropagation();
  evt.preventDefault();
}

function handleCableBendDoubleClick(evt) {
  if (!isPlanViewActive()) return;
  const cableId = evt.currentTarget.dataset.cableId;
  const index = Number(evt.currentTarget.dataset.bendIndex || 0);
  const cable = state.cables.find(c => c.id === cableId);
  if (!cable || !Array.isArray(cable.bendPoints)) return;
  if (index < 0 || index >= cable.bendPoints.length) return;
  const start = resolveSocketPosition(cable.source);
  const end = resolveSocketPosition(cable.target);
  cable.bendPoints.splice(index, 1);
  resetCableHandles(cable, start, end);
  showHud('Removed bend point.');
  render();
  evt.stopPropagation();
  evt.preventDefault();
}

function renderSocketOverlay() {
  if (!socketOverlayEl) return;
  if (!isPlanViewActive()) {
    socketOverlayEl.innerHTML = '';
    socketMap.clear();
    return;
  }
  socketOverlayEl.innerHTML = '';
  socketMap.clear();
  if (!cableCatalog) return;
  const sockets = listCableSockets();
  const selectedKeys = new Set();
  if (state.selectedSurface && state.selectedSurface.type === 'cable') {
    const cable = state.cables.find(c => c.id === state.selectedSurface.id);
    if (cable) {
      selectedKeys.add(getSocketKey(cable.source));
      selectedKeys.add(getSocketKey(cable.target));
    }
  }
  sockets.forEach(socket => {
    const resolved = resolveSocketPosition(socket);
    if (!resolved) return;
    const [px, py] = mmToPx(resolved.x, resolved.y);
    const key = getSocketKey(socket);
    socket.key = key;
    socketMap.set(key, socket);
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', px);
    circle.setAttribute('cy', py);
    circle.setAttribute('r', 12);
    circle.classList.add('socket-target');
    circle.dataset.socketKey = key;
    const cableType = cableTypeSelectEl && cableTypeSelectEl.value ? cableTypeSelectEl.value : null;
    const allowed = !cableType || socket.allowedCableTypes.includes(cableType);
    circle.dataset.disabled = allowed ? 'false' : 'true';
    if (allowed) {
      circle.addEventListener('pointerdown', handleSocketPointerDown);
    }
    circle.addEventListener('pointerenter', handleSocketPointerEnter);
    circle.addEventListener('pointerleave', handleSocketPointerLeave);
    if (selectedKeys.has(key)) {
      circle.dataset.active = 'true';
    }
    if (pendingCable && pendingCable.socket && pendingCable.socket.key === key) {
      circle.dataset.pending = 'true';
    }
    socketOverlayEl.appendChild(circle);
  });
}

function renderCables() {
  if (!cablesLayerEl) return;
  if (!isPlanViewActive()) {
    cablesLayerEl.innerHTML = '';
    cableCurveCache.clear();
    return;
  }
  cablesLayerEl.innerHTML = '';
  cableCurveCache.clear();
  if (!Array.isArray(state.cables)) return;
  state.cables.forEach(cable => {
    const start = resolveSocketPosition(cable.source);
    const end = resolveSocketPosition(cable.target);
    if (!start || !end) return;
    updateCableMetrics(cable, start, end);
    const anchors = getCableAnchors(cable, start, end);
    if (anchors.length < 2 || cable.controlPoints.length < (anchors.length - 1) * 2) return;
    const [sx, sy] = mmToPx(anchors[0].x, anchors[0].y);
    const segments = anchors.length - 1;
    const parts = [`M ${sx} ${sy}`];
    for (let seg = 0; seg < segments; seg++) {
      const cp1 = cable.controlPoints[seg * 2];
      const cp2 = cable.controlPoints[seg * 2 + 1];
      const [c1x, c1y] = mmToPx(cp1.x, cp1.y);
      const [c2x, c2y] = mmToPx(cp2.x, cp2.y);
      const anchor = anchors[seg + 1];
      const [ex, ey] = mmToPx(anchor.x, anchor.y);
      parts.push(`C ${c1x} ${c1y} ${c2x} ${c2y} ${ex} ${ey}`);
    }
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', parts.join(' '));
    path.classList.add('cable-path');
    path.setAttribute('stroke', getCableColor(cable.cableType));
    path.setAttribute('stroke-width', 4);
    path.setAttribute('fill', 'none');
    path.dataset.cableId = cable.id;
    path.dataset.status = cable.status || 'unknown';
    if (state.selectedSurface && state.selectedSurface.type === 'cable' && state.selectedSurface.id === cable.id) {
      path.classList.add('selected');
    }
    path.addEventListener('pointerdown', evt => {
      setSelectedSurface({ type: 'cable', id: cable.id });
      evt.stopPropagation();
      evt.preventDefault();
    });
    path.addEventListener('dblclick', evt => {
      setSelectedSurface({ type: 'cable', id: cable.id });
      const pt = svgPoint(evt);
      const roomPt = svgPointToRoomMm(pt);
      const snapped = snapPoint(clampPointToRoom(roomPt));
      if (insertCableBendPoint(cable, snapped)) {
        evt.stopPropagation();
        evt.preventDefault();
        render();
      }
    });
    cablesLayerEl.appendChild(path);
  });
}

function renderCableHandles() {
  if (!cableHandlesLayerEl) return;
  if (!isPlanViewActive()) {
    cableHandlesLayerEl.innerHTML = '';
    return;
  }
  cableHandlesLayerEl.innerHTML = '';
  if (!state.selectedSurface || state.selectedSurface.type !== 'cable') return;
  const cable = state.cables.find(c => c.id === state.selectedSurface.id);
  if (!cable) return;
  if (Array.isArray(cable.controlPoints)) {
    cable.controlPoints.forEach((pt, index) => {
      const [px, py] = mmToPx(pt.x, pt.y);
      const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      handle.setAttribute('cx', px);
      handle.setAttribute('cy', py);
      handle.setAttribute('r', 6);
      handle.classList.add('cable-handle');
      handle.dataset.cableId = cable.id;
      handle.dataset.handleIndex = String(index);
      handle.addEventListener('pointerdown', handleCableHandleDown);
      cableHandlesLayerEl.appendChild(handle);
    });
  }
  if (Array.isArray(cable.bendPoints)) {
    cable.bendPoints.forEach((pt, index) => {
      const [px, py] = mmToPx(pt.x, pt.y);
      const bend = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bend.setAttribute('x', px - 6);
      bend.setAttribute('y', py - 6);
      bend.setAttribute('width', 12);
      bend.setAttribute('height', 12);
      bend.classList.add('cable-bend-handle');
      bend.dataset.cableId = cable.id;
      bend.dataset.bendIndex = String(index);
      bend.setAttribute('data-bend-index', String(index));
      bend.addEventListener('pointerdown', handleCableBendDown);
      bend.addEventListener('dblclick', handleCableBendDoubleClick);
      cableHandlesLayerEl.appendChild(bend);
    });
  }
}

function insertCableBendPoint(cable, approxPoint) {
  if (!isPlanViewActive()) return false;
  if (!cable) return false;
  const start = resolveSocketPosition(cable.source);
  const end = resolveSocketPosition(cable.target);
  if (!start || !end) return false;
  const snapped = snapPoint(approxPoint);
  const clamped = clampPointToRoom(snapped);
  let insertIndex = Array.isArray(cable.bendPoints) ? cable.bendPoints.length : 0;
  let finalPoint = {
    x: clamped.x,
    y: clamped.y,
    z: (start.z + end.z) / 2
  };
  const cache = cableCurveCache.get(cable.id);
  const samples = cache && Array.isArray(cache.samples) ? cache.samples : [];
  const anchors = cache && Array.isArray(cache.anchors) && cache.anchors.length > 1 ? cache.anchors : getCableAnchors(cable, start, end);
  if (samples.length > 0 && anchors.length > 1) {
    let best = null;
    samples.forEach(sample => {
      const dist = distance2d(clamped, sample.point);
      if (!best || dist < best.dist) {
        best = { dist, sample };
      }
    });
    if (best && Number.isFinite(best.sample.segmentIndex)) {
      insertIndex = clamp(best.sample.segmentIndex, 0, Array.isArray(cable.bendPoints) ? cable.bendPoints.length : 0);
      const seg = best.sample.segmentIndex;
      const p0 = anchors[seg];
      const p3 = anchors[seg + 1];
      const c1 = cable.controlPoints[seg * 2];
      const c2 = cable.controlPoints[seg * 2 + 1];
      const precise = cubicPoint(best.sample.t, p0, c1, c2, p3);
      finalPoint = {
        x: clamp(precise.x, 0, state.Wmm),
        y: clamp(precise.y, 0, state.Lmm),
        z: Number.isFinite(precise.z) ? precise.z : finalPoint.z
      };
    }
  }
  const snappedFinal = snapPoint(finalPoint);
  const bendPoint = {
    x: clamp(snappedFinal.x, 0, state.Wmm),
    y: clamp(snappedFinal.y, 0, state.Lmm),
    z: finalPoint.z
  };
  if (!Array.isArray(cable.bendPoints)) cable.bendPoints = [];
  insertIndex = clamp(insertIndex, 0, cable.bendPoints.length);
  cable.bendPoints.splice(insertIndex, 0, bendPoint);
  resetCableHandles(cable, start, end);
  showHud('Added bend point.');
  return true;
}

(function setupCablePrototype() {
  const aside = document.querySelector('aside');
  if (!aside) return;
  const style = document.createElement('style');
  style.textContent = `#cableControls h3{margin:0 0 8px;font-size:16px;}#cableControls .row{gap:10px;flex-wrap:wrap;}#cableControls select{min-width:160px;}#cableHud{min-height:1.4em;}#cablesLayer,#cableHandlesLayer,#socketOverlay{pointer-events:none;}#cableHandlesLayer .cable-handle,#cableHandlesLayer .cable-bend-handle,#socketOverlay .socket-target{pointer-events:all;} .cable-path{fill:none;stroke-linecap:round;pointer-events:stroke;} .cable-path.selected{stroke-width:5;filter:drop-shadow(0 0 6px rgba(59,130,246,0.35));} .cable-path[data-status="over_limit"]{stroke-dasharray:8 6;} .cable-handle{fill:#fff;stroke:#2563eb;stroke-width:2;cursor:pointer;} .cable-bend-handle{fill:#fef08a;stroke:#92400e;stroke-width:2;cursor:pointer;} #socketOverlay .socket-target{fill:rgba(59,130,246,0.18);stroke:#2563eb;stroke-width:1.5;cursor:pointer;} #socketOverlay .socket-target[data-disabled="true"]{opacity:0.2;cursor:not-allowed;} #socketOverlay .socket-target[data-active="true"]{fill:rgba(34,197,94,0.35);} #socketOverlay .socket-target[data-pending="true"]{fill:rgba(250,204,21,0.35);} #socketOverlay .socket-target[data-hover="true"]{stroke-width:2.4;}`;
  document.head.appendChild(style);
  aside.insertAdjacentHTML('beforeend', CABLE_CONTROLS_TEMPLATE);
  cableTypeSelectEl = document.getElementById('cableType');
  cancelCableBtnEl = document.getElementById('cancelCable');
  deleteCableBtnEl = document.getElementById('deleteCable');
  cableHudEl = document.getElementById('cableHud');
  cablesLayerEl = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  cablesLayerEl.setAttribute('id', 'cablesLayer');
  cableHandlesLayerEl = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  cableHandlesLayerEl.setAttribute('id', 'cableHandlesLayer');
  socketOverlayEl = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  socketOverlayEl.setAttribute('id', 'socketOverlay');
  if (floorItemsG && floorItemsG.parentNode) {
    const parent = floorItemsG.parentNode;
    parent.insertBefore(cablesLayerEl, floorItemsG.nextSibling);
    parent.insertBefore(cableHandlesLayerEl, cablesLayerEl.nextSibling);
    parent.insertBefore(socketOverlayEl, cableHandlesLayerEl.nextSibling);
  }
  if (!Array.isArray(state.cables)) {
    state.cables = [];
  }
  const originalApplyDefaultPreset = applyDefaultPreset;
  applyDefaultPreset = function () {
    originalApplyDefaultPreset();
    state.cables = [];
  };
  const originalSyncIdCounter = syncIdCounterFromLayout;
  syncIdCounterFromLayout = function () {
    originalSyncIdCounter();
    (state.cables || []).forEach(cable => {
      const match = cable.id && String(cable.id).match(/_(\d+)$/);
      if (match) {
        const candidate = Number(match[1]);
        if (Number.isFinite(candidate)) {
          idCounter = Math.max(idCounter, candidate + 1);
        }
      }
    });
  };
  const originalSnapshotLayout = snapshotLayout;
  snapshotLayout = function () {
    const snapshot = originalSnapshotLayout();
    // cables: state.cables.map(...) is covered by snapshot serialization
    snapshot.cables = state.cables.map(exportCableToSnapshot);
    return snapshot;
  };
  const originalApplyLayout = applyLayout;
  applyLayout = function (raw, options) {
    const result = originalApplyLayout(raw, options);
    if (result) {
      const layout = raw && typeof raw === 'object' && raw.layout && typeof raw.layout === 'object' ? raw.layout : raw;
      state.cables = normalizeCableArray(layout);
      syncIdCounterFromLayout();
      pendingCable = null;
      render();
    }
    return result;
  };
  const originalDeleteSelectedItem = deleteSelectedItem;
  deleteSelectedItem = function () {
    if (state.selectedSurface && state.selectedSurface.type === 'cable') {
      const idx = state.cables.findIndex(c => c.id === state.selectedSurface.id);
      if (idx >= 0) {
        state.cables.splice(idx, 1);
        setSelectedSurface({ type: 'floor' }, { skipRender: true });
        return 'Cable removed';
      }
    }
    return originalDeleteSelectedItem();
  };
  const originalSnapshotSelectedSurface = snapshotSelectedSurface;
  snapshotSelectedSurface = function (surface) {
    if (surface && surface.type === 'cable' && surface.id) {
      return { type: 'cable', id: surface.id };
    }
    return originalSnapshotSelectedSurface(surface);
  };
  const originalNormalizeSelectedSurface = normalizeSelectedSurface;
  normalizeSelectedSurface = function (surface) {
    if (surface && surface.type === 'cable' && surface.id) {
      const cable = state.cables.find(c => c.id === surface.id);
      return cable ? { type: 'cable', id: cable.id } : { type: 'floor' };
    }
    return originalNormalizeSelectedSurface(surface);
  };
  const originalDefaultHudMessage = defaultHudMessage;
  defaultHudMessage = function () {
    const base = originalDefaultHudMessage();
    if (state.selectedSurface && state.selectedSurface.type === 'cable') {
      const cable = state.cables.find(c => c.id === state.selectedSurface.id);
      if (cable) {
        const meta = getCableTypeMeta(cable.cableType);
        const label = meta ? meta.label : cable.cableType;
        const replacement = `| Selected: ${label || 'Cable'} (${fmtLen(Math.round(cable.length_mm || 0))})`;
        return base.replace(/\| Selected: .*/, replacement);
      }
    }
    return base;
  };
  const originalRender = render;
  render = function () {
    pruneInvalidCables();
    originalRender();
    renderCables();
    renderCableHandles();
    renderSocketOverlay();
    updateCableHud();
    if (cancelCableBtnEl) cancelCableBtnEl.disabled = !pendingCable;
  };
  const originalInitializeSurvey = initializeSurvey;
  initializeSurvey = async function () {
    try {
      await ensureCableCatalog();
      populateCableTypeSelect();
    } catch (err) {
      console.error('Failed to load cable catalog', err);
    }
    await originalInitializeSurvey();
    render();
  };
  if (cableTypeSelectEl) {
    cableTypeSelectEl.addEventListener('change', () => {
      pendingCable = null;
      render();
    });
  }
  if (cancelCableBtnEl) {
    cancelCableBtnEl.addEventListener('click', () => {
      pendingCable = null;
      render();
    });
  }
  if (deleteCableBtnEl) {
    deleteCableBtnEl.addEventListener('click', () => {
      if (state.selectedSurface && state.selectedSurface.type === 'cable') {
        const message = deleteSelectedItem();
        if (message) showHud(message);
        render();
      }
    });
  }
  document.addEventListener('pointermove', evt => {
    if (!drag) return;
    if (!isPlanViewActive()) return;
    const cable = state.cables.find(c => c.id === drag.cableId);
    if (!cable) return;
    const pt = svgPoint(evt);
    const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
    const snapped = snapPoint(roomPt);
    if (drag.kind === 'cable-handle') {
      const handle = cable.controlPoints[drag.handleIndex];
      if (!handle) return;
      handle.x = snapped.x;
      handle.y = snapped.y;
      render();
    } else if (drag.kind === 'cable-bend') {
      if (!Array.isArray(cable.bendPoints)) return;
      const bend = cable.bendPoints[drag.bendIndex];
      if (!bend) return;
      bend.x = snapped.x;
      bend.y = snapped.y;
      render();
    }
  });
})();

initializeSurvey();
  </script>
</body>
</html>
