<html lang="en">
<head>
  <!-- Prototype version 1 (baseline implementation used as source for future iterations) -->
  <meta charset="utf-8" />
  <title>Room Survey (SVG Drag + Snap) â€” v1 Baseline</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font: 14px/1.4 system-ui; margin: 16px; }
    .row { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
    label { display: inline-flex; align-items: center; gap: 6px; }
    input[type="number"] { width: 7em; }
    #stage { border: 1px solid #ccc; background: #fafafa; }
    .btn { padding: 6px 10px; border: 1px solid #444; background: #f0f0f0; cursor: pointer; }
    .legend { margin-top: 8px; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: middle; }
    .hud { font: 12px/1.2 system-ui; color: #333; }
    .toggle { display: inline-flex; align-items: center; gap: 6px; }
    .note { font-size: 12px; color: #555; max-width: 420px; }
    .wall-choice { min-width: 220px; }
    .handle { fill: #fff; stroke: #333; stroke-width: 1.5; cursor: pointer; }
    .custom-wall-line { cursor: move; }
    #roomRect.floor-selected { stroke: #1976d2; stroke-width: 3; }
    body[data-mode="basic"] .custom-only { display: none !important; }
    body[data-mode="custom"] .basic-only { display: none !important; }
    body[data-mode="basic"] .wall-choice { display: none !important; }
  </style>
</head>
<body>
<h1>Room Survey (Top-Down)</h1>

<div class="row" id="primaryControls">
  <label class="toggle">Room type
    <select id="roomType">
      <option value="basic">Basic (Rectangular)</option>
      <option value="custom">Custom Layout</option>
    </select>
  </label>
  <label class="dim">Width W (mm) <input id="W" type="number" value="6000" min="1000"></label>
  <label class="dim">Length L (mm) <input id="L" type="number" value="8000" min="1000"></label>
  <label class="custom-only">Snap (mm) <input id="snap" type="number" value="100" min="10" step="10" title="Grid snap step in millimeters"></label>
  <label class="toggle custom-only"><input id="imperial" type="checkbox"> Show imperial (in) & use 150&nbsp;mm snap</label>
  <button class="btn" id="apply">Apply</button>
</div>

<div class="row basic-only" id="basicAddRow">
  <label>
    Add item:
    <select id="basicAddType">
      <option value="microscope">Microscope</option>
      <option value="table">Table</option>
      <option value="pump">Vacuum Pump</option>
    </select>
  </label>
  <button class="btn" id="basicAdd">Add</button>
</div>

<div class="row custom-only" id="customAddRow">
  <label>
    Add:
    <select id="addType">
      <option value="floorBox">Floor Box</option>
      <option value="microscope">Microscope</option>
      <option value="table">Table</option>
      <option value="pump">Vacuum Pump</option>
      <option value="socket">Wall Socket</option>
    </select>
  </label>
  <label class="wall-choice">
    Wall for socket:
    <select id="wallSel"></select>
  </label>
  <button class="btn" id="add">Add</button>
</div>

<div class="row custom-only" id="structureRow">
  <button class="btn" id="addWall">Draw Wall</button>
  <button class="btn" id="addDoor">Add Door to Selected Wall</button>
  <span class="note">Select a wall or floor to attach items. Drag wall end dots to reshape custom walls.</span>
</div>

<svg id="stage" width="900" height="640" viewBox="0 0 900 640">
  <!-- Room rectangle (scaled to fit) -->
  <g id="roomGroup">
    <rect id="roomRect" x="50" y="50" width="700" height="500" fill="none" stroke="#333" stroke-width="2"/>
    <!-- Origin marker (rear-left corner) -->
    <circle id="origin" cx="50" cy="550" r="5" fill="#d33"></circle>
    <text x="60" y="545" font-size="12">Origin (0,0)</text>
    <!-- grid group -->
    <g id="grid"></g>
  </g>

  <!-- Draggable items -->
  <g id="baseWallsOverlay"></g>
  <g id="selectionOverlay"></g>
  <g id="customWalls"></g>
  <g id="doorsLayer"></g>
  <g id="floorItems"></g>
  <g id="wallItems"></g>
</svg>

<div class="row" id="exportRow">
  <button class="btn" id="export">Export JSON</button>
  <span class="hud" id="hud"></span>
</div>

<div class="legend">
  <span class="dot" style="background:#1e88e5"></span>Floor Box
  &nbsp;&nbsp;
  <span class="dot" style="background:#f9a825"></span>Socket
  &nbsp;&nbsp;
  <span class="dot" style="background:#8e24aa"></span>Microscope
  &nbsp;&nbsp;
  <span class="dot" style="background:#3949ab"></span>Table
  &nbsp;&nbsp;
  <span class="dot" style="background:#ef6c00"></span>Vacuum Pump
</div>

<script>
const bodyEl = document.body;
const svg = document.getElementById('stage');
const roomTypeSel = document.getElementById('roomType');
const Winput = document.getElementById('W');
const Linput = document.getElementById('L');
const snapInput = document.getElementById('snap');
const imperialChk = document.getElementById('imperial');
const applyBtn = document.getElementById('apply');
const basicAddBtn = document.getElementById('basicAdd');
const basicAddType = document.getElementById('basicAddType');
const addBtn = document.getElementById('add');
const addType = document.getElementById('addType');
const wallSel = document.getElementById('wallSel');
const addWallBtn = document.getElementById('addWall');
const addDoorBtn = document.getElementById('addDoor');
const exportBtn = document.getElementById('export');
const hud = document.getElementById('hud');

const roomRect = document.getElementById('roomRect');
const originDot = document.getElementById('origin');
const gridG = document.getElementById('grid');
const baseWallsG = document.getElementById('baseWallsOverlay');
const selectionG = document.getElementById('selectionOverlay');
const customWallsG = document.getElementById('customWalls');
const doorsG = document.getElementById('doorsLayer');
const floorItemsG = document.getElementById('floorItems');
const wallItemsG = document.getElementById('wallItems');

const FLOOR_ITEM_DEFS = {
  floorBox: { label: 'Floor Box', w: 600, l: 600, fill: '#1e88e5', stroke: '#1e88e5' },
  microscope: { label: 'Microscope', w: 2200, l: 1800, fill: '#8e24aa', stroke: '#5e35b1' },
  table: { label: 'Table', w: 1800, l: 900, fill: '#3949ab', stroke: '#1a237e' },
  pump: { label: 'Vacuum Pump', w: 1200, l: 600, fill: '#ef6c00', stroke: '#e65100' }
};

const BASE_WALL_THICKNESS = 200;
const DOOR_DEFAULT_WIDTH = 900;
const DOOR_DEFAULT_THICKNESS = 80;

let idCounter = 1;
function genId(prefix = 'id') { return `${prefix}_${idCounter++}`; }

const state = {
  mode: 'basic',
  Wmm: 6000,
  Lmm: 8000,
  scale: 1,
  snap: 100,
  imperial: false,
  floorItems: [],
  wallItems: [],
  customWalls: [],
  doors: [],
  selectedSurface: { type: 'floor' }
};

let hudTransient = null;
let drawWallState = null;
function showHud(message) { hudTransient = message; }

function mmToIn(mm) { return mm / 25.4; }
function fmtLen(mm) {
  if (!state.imperial) return `${Math.round(mm)} mm`;
  const inches = mmToIn(mm);
  return `${Math.round(mm)} mm (${inches.toFixed(2)} in)`;
}

function snapValue(vmm) {
  const s = state.snap;
  if (!s) return vmm;
  return Math.round(vmm / s) * s;
}

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function recomputeScale() {
  const maxWpx = 800, maxLpx = 520;
  const sx = maxWpx / state.Wmm;
  const sy = maxLpx / state.Lmm;
  state.scale = Math.min(sx, sy);
  const wpx = state.Wmm * state.scale;
  const lpx = state.Lmm * state.scale;
  const x0 = 50;
  const y0 = 570 - lpx;
  roomRect.setAttribute('width', wpx);
  roomRect.setAttribute('height', lpx);
  roomRect.setAttribute('x', x0);
  roomRect.setAttribute('y', y0);
  originDot.setAttribute('cx', x0);
  originDot.setAttribute('cy', 570);
  drawGrid();
}

function drawGrid() {
  gridG.innerHTML = '';
  const step = state.snap;
  const x0 = Number(roomRect.getAttribute('x'));
  const y0 = Number(roomRect.getAttribute('y'));
  const wpx = Number(roomRect.getAttribute('width'));
  const lpx = Number(roomRect.getAttribute('height'));
  if (step <= 0) return;
  for (let xmm = 0; xmm <= state.Wmm; xmm += step) {
    const x = x0 + xmm * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x); line.setAttribute('y1', y0);
    line.setAttribute('x2', x); line.setAttribute('y2', y0 + lpx);
    line.setAttribute('stroke', '#ddd'); line.setAttribute('stroke-width', 1);
    gridG.appendChild(line);
  }
  for (let ymm = 0; ymm <= state.Lmm; ymm += step) {
    const y = y0 + (state.Lmm - ymm) * state.scale;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x0); line.setAttribute('y1', y);
    line.setAttribute('x2', x0 + wpx); line.setAttribute('y2', y);
    line.setAttribute('stroke', '#eee'); line.setAttribute('stroke-width', 1);
    gridG.appendChild(line);
  }
}

function mmToPx(xmm, ymm) {
  const x0 = Number(roomRect.getAttribute('x'));
  const y0 = Number(roomRect.getAttribute('y'));
  const px = x0 + xmm * state.scale;
  const py = y0 + (state.Lmm - ymm) * state.scale;
  return [px, py];
}

function svgPoint(evt) {
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX; pt.y = evt.clientY;
  const ctm = svg.getScreenCTM();
  return ctm ? pt.matrixTransform(ctm.inverse()) : pt;
}

function svgPointToRoomMm(pt) {
  const x0 = Number(roomRect.getAttribute('x'));
  const y0 = Number(roomRect.getAttribute('y'));
  const xmm = (pt.x - x0) / state.scale;
  const ymm = state.Lmm - ((pt.y - y0) / state.scale);
  return { x: xmm, y: ymm };
}

function clampPointToRoom(pt) {
  return {
    x: clamp(pt.x, 0, state.Wmm),
    y: clamp(pt.y, 0, state.Lmm)
  };
}

function baseWallDefinitions() {
  const W = state.Wmm;
  const L = state.Lmm;
  return [
    { ref: 'base:1', label: `Wall 1 (y=0)`, start: { x: 0, y: 0 }, end: { x: W, y: 0 }, thickness: BASE_WALL_THICKNESS },
    { ref: 'base:2', label: `Wall 2 (x=W)`, start: { x: W, y: 0 }, end: { x: W, y: L }, thickness: BASE_WALL_THICKNESS },
    { ref: 'base:3', label: `Wall 3 (y=L)`, start: { x: W, y: L }, end: { x: 0, y: L }, thickness: BASE_WALL_THICKNESS },
    { ref: 'base:4', label: `Wall 4 (x=0)`, start: { x: 0, y: L }, end: { x: 0, y: 0 }, thickness: BASE_WALL_THICKNESS }
  ];
}

function getCustomWallById(id) { return state.customWalls.find(w => w.id === id); }

function enrichWallGeometry(wall) {
  const dx = wall.end.x - wall.start.x;
  const dy = wall.end.y - wall.start.y;
  const length = Math.hypot(dx, dy);
  if (length < 1e-6) return null;
  const tangent = { x: dx / length, y: dy / length };
  const normal = { x: -tangent.y, y: tangent.x };
  return { ...wall, length, tangent, normal };
}

function getWallGeometry(ref) {
  if (!ref) return null;
  if (typeof ref === 'number') {
    ref = `base:${ref}`;
  }
  if (/^\d$/.test(ref)) {
    ref = `base:${ref}`;
  }
  if (ref.startsWith('base:')) {
    const wall = baseWallDefinitions().find(w => w.ref === ref);
    return wall ? enrichWallGeometry(wall) : null;
  }
  if (ref.startsWith('custom:')) {
    const id = ref.split(':')[1];
    const wall = getCustomWallById(id);
    if (!wall) return null;
    return enrichWallGeometry({
      ref,
      label: wall.name || `Custom Wall`,
      start: { x: wall.x1, y: wall.y1 },
      end: { x: wall.x2, y: wall.y2 },
      thickness: wall.thickness || BASE_WALL_THICKNESS
    });
  }
  return null;
}

function listAllWalls() {
  const base = baseWallDefinitions();
  const customs = state.customWalls.map((w, i) => ({
    ref: `custom:${w.id}`,
    label: w.name || `Custom Wall ${i + 1}`,
    start: { x: w.x1, y: w.y1 },
    end: { x: w.x2, y: w.y2 },
    thickness: w.thickness || BASE_WALL_THICKNESS
  }));
  return [...base, ...customs].map(enrichWallGeometry).filter(Boolean);
}

function pointAlongWall(geom, offset) {
  const dist = clamp(offset, 0, geom.length);
  return {
    x: geom.start.x + geom.tangent.x * dist,
    y: geom.start.y + geom.tangent.y * dist
  };
}

function projectPointOntoWall(geom, point) {
  const px = point.x - geom.start.x;
  const py = point.y - geom.start.y;
  const along = px * geom.tangent.x + py * geom.tangent.y;
  const distance = px * geom.normal.x + py * geom.normal.y;
  const clamped = clamp(along, 0, geom.length);
  return {
    s: clamped,
    rawS: along,
    distance,
    point: {
      x: geom.start.x + geom.tangent.x * clamped,
      y: geom.start.y + geom.tangent.y * clamped
    }
  };
}

function wallShToXY(wallRef, s, h) {
  const geom = getWallGeometry(wallRef);
  if (!geom) return null;
  const offset = clamp(s, 0, geom.length);
  const baseMm = pointAlongWall(geom, offset);
  const depthMm = clamp(h, 0, 4000);
  const tipMm = {
    x: baseMm.x + geom.normal.x * depthMm,
    y: baseMm.y + geom.normal.y * depthMm
  };
  const basePx = mmToPx(baseMm.x, baseMm.y);
  const tipPx = mmToPx(tipMm.x, tipMm.y);
  return { base: basePx, tip: tipPx, geom };
}

function updateWallSelect() {
  if (!wallSel) return;
  const prev = wallSel.value;
  wallSel.innerHTML = '';
  const walls = listAllWalls();
  walls.forEach((w, idx) => {
    const opt = document.createElement('option');
    opt.value = w.ref;
    opt.textContent = w.label || `Wall ${idx + 1}`;
    wallSel.appendChild(opt);
  });
  if (walls.length === 0) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'No walls available';
    wallSel.appendChild(opt);
  }
  if (prev && [...wallSel.options].some(o => o.value === prev)) {
    wallSel.value = prev;
  }
}

function setMode(mode) {
  state.mode = mode;
  bodyEl.dataset.mode = mode;
  roomTypeSel.value = mode;
  if (mode === 'basic') {
    state.selectedSurface = { type: 'floor' };
  }
  if (mode !== 'custom') {
    drawWallState = null;
  }
  updateWallSelect();
  render();
}

function setSelectedSurface(surface, { skipRender = false } = {}) {
  state.selectedSurface = surface;
  if (skipRender) {
    renderSelection();
    hud.textContent = hudTransient || defaultHudMessage();
    hudTransient = null;
  } else {
    render();
  }
}

function clampStateToRoom() {
  state.floorItems.forEach(it => {
    it.x = clamp(it.x, 0, state.Wmm);
    it.y = clamp(it.y, 0, state.Lmm);
  });
  state.customWalls.forEach(w => {
    const start = clampPointToRoom({ x: w.x1, y: w.y1 });
    const end = clampPointToRoom({ x: w.x2, y: w.y2 });
    w.x1 = start.x; w.y1 = start.y;
    w.x2 = end.x; w.y2 = end.y;
  });
  state.wallItems.forEach(it => {
    const geom = getWallGeometry(it.wall);
    if (!geom) return;
    it.s = clamp(it.s, 0, geom.length);
    it.h = clamp(it.h, 0, 4000);
  });
  state.doors.forEach(door => {
    const geom = getWallGeometry(door.wall);
    if (!geom) return;
    const maxOffset = Math.max(0, geom.length - door.width);
    door.offset = clamp(door.offset, 0, maxOffset);
  });
}

function defaultHudMessage() {
  const snapStr = `Snap: ${state.snap} mm` + (state.imperial ? ` (${mmToIn(state.snap).toFixed(2)} in)` : '');
  let sel = 'Floor';
  if (state.selectedSurface?.type === 'wall') {
    const geom = getWallGeometry(state.selectedSurface.ref);
    sel = geom ? geom.label : 'Wall';
  }
  return `${snapStr} | Selected: ${sel}`;
}

function render() {
  updateWallSelect();
  renderBaseWallsOverlay();
  renderCustomWalls();
  renderDoors();
  renderWallItems();
  renderFloorItems();
  renderSelection();
  hud.textContent = hudTransient || defaultHudMessage();
  hudTransient = null;
}

function renderBaseWallsOverlay() {
  baseWallsG.innerHTML = '';
  baseWallDefinitions().forEach(w => {
    const geom = enrichWallGeometry(w);
    if (!geom) return;
    const startPx = mmToPx(geom.start.x, geom.start.y);
    const endPx = mmToPx(geom.end.x, geom.end.y);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', startPx[0]);
    line.setAttribute('y1', startPx[1]);
    line.setAttribute('x2', endPx[0]);
    line.setAttribute('y2', endPx[1]);
    line.setAttribute('stroke', 'transparent');
    line.setAttribute('stroke-width', Math.max(geom.thickness * state.scale, 12));
    line.dataset.wallRef = geom.ref;
    line.addEventListener('pointerdown', evt => {
      if (state.mode !== 'custom') {
        setSelectedSurface({ type: 'wall', ref: geom.ref });
        evt.preventDefault();
        return;
      }
      setSelectedSurface({ type: 'wall', ref: geom.ref });
      evt.preventDefault();
    });
    baseWallsG.appendChild(line);
  });
}

function renderSelection() {
  selectionG.innerHTML = '';
  const isFloor = state.selectedSurface?.type === 'floor';
  roomRect.classList.toggle('floor-selected', !!isFloor);
  if (state.selectedSurface?.type === 'wall') {
    const geom = getWallGeometry(state.selectedSurface.ref);
    if (!geom) return;
    const start = mmToPx(geom.start.x, geom.start.y);
    const end = mmToPx(geom.end.x, geom.end.y);
    const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    highlight.setAttribute('x1', start[0]);
    highlight.setAttribute('y1', start[1]);
    highlight.setAttribute('x2', end[0]);
    highlight.setAttribute('y2', end[1]);
    highlight.setAttribute('stroke', '#1976d2');
    highlight.setAttribute('stroke-width', Math.max(geom.thickness * state.scale + 4, 6));
    highlight.setAttribute('stroke-linecap', 'round');
    selectionG.appendChild(highlight);
  }
}

function renderCustomWalls() {
  customWallsG.innerHTML = '';
  state.customWalls.forEach(wall => {
    const geom = getWallGeometry(`custom:${wall.id}`);
    if (!geom) return;
    const start = mmToPx(geom.start.x, geom.start.y);
    const end = mmToPx(geom.end.x, geom.end.y);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', start[0]);
    line.setAttribute('y1', start[1]);
    line.setAttribute('x2', end[0]);
    line.setAttribute('y2', end[1]);
    line.setAttribute('stroke', '#444');
    line.setAttribute('stroke-width', Math.max(geom.thickness * state.scale, 4));
    line.setAttribute('stroke-linecap', 'round');
    line.classList.add('custom-wall-line');
    line.dataset.wallId = wall.id;
    line.dataset.wallRef = geom.ref;
    line.addEventListener('pointerdown', handleCustomWallLineDown);
    customWallsG.appendChild(line);

    const handleStart = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    handleStart.setAttribute('cx', start[0]);
    handleStart.setAttribute('cy', start[1]);
    handleStart.setAttribute('r', 6);
    handleStart.classList.add('handle');
    handleStart.dataset.wallId = wall.id;
    handleStart.dataset.handle = 'start';
    handleStart.addEventListener('pointerdown', handleWallHandleDown);
    customWallsG.appendChild(handleStart);

    const handleEnd = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    handleEnd.setAttribute('cx', end[0]);
    handleEnd.setAttribute('cy', end[1]);
    handleEnd.setAttribute('r', 6);
    handleEnd.classList.add('handle');
    handleEnd.dataset.wallId = wall.id;
    handleEnd.dataset.handle = 'end';
    handleEnd.addEventListener('pointerdown', handleWallHandleDown);
    customWallsG.appendChild(handleEnd);
  });
}

function renderDoors() {
  doorsG.innerHTML = '';
  state.doors.forEach(door => {
    const geom = getWallGeometry(door.wall);
    if (!geom) return;
    const startMm = pointAlongWall(geom, door.offset);
    const endMm = pointAlongWall(geom, door.offset + door.width);
    const startPx = mmToPx(startMm.x, startMm.y);
    const endPx = mmToPx(endMm.x, endMm.y);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', startPx[0]);
    line.setAttribute('y1', startPx[1]);
    line.setAttribute('x2', endPx[0]);
    line.setAttribute('y2', endPx[1]);
    line.setAttribute('stroke', '#2e7d32');
    line.setAttribute('stroke-width', Math.max((door.thickness || DOOR_DEFAULT_THICKNESS) * state.scale, 4));
    line.setAttribute('stroke-linecap', 'butt');
    line.dataset.doorId = door.id;
    line.addEventListener('pointerdown', handleDoorDragStart);
    doorsG.appendChild(line);
  });
}

function renderWallItems() {
  wallItemsG.innerHTML = '';
  state.wallItems.forEach(it => {
    if (it.type !== 'socket') return;
    const data = wallShToXY(it.wall, it.s, it.h);
    if (!data) return;
    const wh = 16;
    const base = data.base;
    const tip = data.tip;
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const mk = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    mk.setAttribute('x', base[0] - wh / 2);
    mk.setAttribute('y', base[1] - wh / 2);
    mk.setAttribute('width', wh);
    mk.setAttribute('height', wh);
    mk.setAttribute('fill', '#f9a825');
    mk.setAttribute('stroke', '#aa7a00');
    mk.dataset.wallItemId = it.id;
    mk.addEventListener('pointerdown', handleSocketAlongDragStart);

    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', base[0]);
    line.setAttribute('y1', base[1]);
    line.setAttribute('x2', tip[0]);
    line.setAttribute('y2', tip[1]);
    line.setAttribute('stroke', '#f9a825');
    line.setAttribute('stroke-width', 2);
    line.dataset.wallItemId = it.id;
    line.addEventListener('pointerdown', handleSocketHeightDragStart);

    g.appendChild(line);
    g.appendChild(mk);
    wallItemsG.appendChild(g);
  });
}

function renderFloorItems() {
  floorItemsG.innerHTML = '';
  state.floorItems.forEach(item => {
    const def = FLOOR_ITEM_DEFS[item.type] || FLOOR_ITEM_DEFS.floorBox;
    const wmm = item.w || def.w;
    const lmm = item.l || def.l;
    const wpx = wmm * state.scale;
    const lpx = lmm * state.scale;
    const [cx, cy] = mmToPx(item.x, item.y);
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.dataset.floorItemId = item.id;
    group.setAttribute('transform', `translate(${cx},${cy}) rotate(${item.rotation || 0})`);
    group.setAttribute('cursor', 'move');
    group.addEventListener('pointerdown', handleFloorDragStart);

    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', -wpx / 2);
    rect.setAttribute('y', -lpx / 2);
    rect.setAttribute('width', wpx);
    rect.setAttribute('height', lpx);
    rect.setAttribute('fill', def.fill);
    rect.setAttribute('fill-opacity', 0.45);
    rect.setAttribute('stroke', def.stroke);
    rect.setAttribute('stroke-width', 2);
    group.appendChild(rect);

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', 0);
    text.setAttribute('y', 4);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('font-size', 12);
    text.setAttribute('fill', '#111');
    text.textContent = def.label;
    group.appendChild(text);

    floorItemsG.appendChild(group);
  });
}

let drag = null;

function handleFloorDragStart(evt) {
  const id = evt.currentTarget.dataset.floorItemId;
  const item = state.floorItems.find(f => f.id === id);
  if (!item) return;
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  drag = {
    kind: 'floor',
    id,
    offsetX: roomPt.x - item.x,
    offsetY: roomPt.y - item.y,
    captureEl: svg,
    pointerId: evt.pointerId
  };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleSocketAlongDragStart(evt) {
  const id = evt.currentTarget.dataset.wallItemId;
  const item = state.wallItems.find(w => w.id === id);
  if (!item) return;
  drag = { kind: 'socketS', id, captureEl: svg, pointerId: evt.pointerId };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleSocketHeightDragStart(evt) {
  const id = evt.currentTarget.dataset.wallItemId;
  const item = state.wallItems.find(w => w.id === id);
  if (!item) return;
  drag = { kind: 'socketH', id, captureEl: svg, pointerId: evt.pointerId };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleCustomWallLineDown(evt) {
  const wallId = evt.currentTarget.dataset.wallId;
  const wallRef = evt.currentTarget.dataset.wallRef;
  setSelectedSurface({ type: 'wall', ref: wallRef }, { skipRender: true });
  const wall = getCustomWallById(wallId);
  if (!wall) return;
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  drag = {
    kind: 'wall-move',
    wallId,
    start: roomPt,
    orig: { x1: wall.x1, y1: wall.y1, x2: wall.x2, y2: wall.y2 },
    captureEl: svg,
    pointerId: evt.pointerId
  };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleWallHandleDown(evt) {
  const wallId = evt.currentTarget.dataset.wallId;
  const handle = evt.currentTarget.dataset.handle;
  const wall = getCustomWallById(wallId);
  if (!wall) return;
  setSelectedSurface({ type: 'wall', ref: `custom:${wallId}` }, { skipRender: true });
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  drag = {
    kind: 'wall-handle',
    wallId,
    handle,
    captureEl: svg,
    pointerId: evt.pointerId
  };
  drag.start = roomPt;
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

function handleDoorDragStart(evt) {
  const id = evt.currentTarget.dataset.doorId;
  const door = state.doors.find(d => d.id === id);
  if (!door) return;
  setSelectedSurface({ type: 'wall', ref: door.wall }, { skipRender: true });
  drag = { kind: 'door', id, captureEl: svg, pointerId: evt.pointerId };
  svg.setPointerCapture(evt.pointerId);
  evt.preventDefault();
}

document.addEventListener('pointermove', evt => {
  if (!drag) return;
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  if (drag.kind === 'floor') {
    const item = state.floorItems.find(f => f.id === drag.id);
    if (!item) return;
    const newX = snapValue(roomPt.x - drag.offsetX);
    const newY = snapValue(roomPt.y - drag.offsetY);
    item.x = clamp(newX, 0, state.Wmm);
    item.y = clamp(newY, 0, state.Lmm);
    showHud(`${FLOOR_ITEM_DEFS[item.type]?.label || 'Item'} @ (${fmtLen(item.x)}, ${fmtLen(item.y)})`);
    render();
  } else if (drag.kind === 'socketS') {
    const item = state.wallItems.find(w => w.id === drag.id);
    if (!item) return;
    const geom = getWallGeometry(item.wall);
    if (!geom) return;
    const proj = projectPointOntoWall(geom, roomPt);
    item.s = snapValue(proj.s);
    showHud(`Socket offset ${fmtLen(item.s)} on ${geom.label}`);
    render();
  } else if (drag.kind === 'socketH') {
    const item = state.wallItems.find(w => w.id === drag.id);
    if (!item) return;
    const geom = getWallGeometry(item.wall);
    if (!geom) return;
    const proj = projectPointOntoWall(geom, roomPt);
    const height = clamp(proj.distance, 0, 4000);
    item.h = snapValue(height);
    showHud(`Socket height ${fmtLen(item.h)} on ${geom.label}`);
    render();
  } else if (drag.kind === 'wall-move') {
    const wall = getCustomWallById(drag.wallId);
    if (!wall) return;
    const dx = roomPt.x - drag.start.x;
    const dy = roomPt.y - drag.start.y;
    wall.x1 = clamp(drag.orig.x1 + dx, 0, state.Wmm);
    wall.y1 = clamp(drag.orig.y1 + dy, 0, state.Lmm);
    wall.x2 = clamp(drag.orig.x2 + dx, 0, state.Wmm);
    wall.y2 = clamp(drag.orig.y2 + dy, 0, state.Lmm);
    showHud(`Moved ${wall.name || 'custom wall'}`);
    render();
  } else if (drag.kind === 'wall-handle') {
    const wall = getCustomWallById(drag.wallId);
    if (!wall) return;
    if (drag.handle === 'start') {
      wall.x1 = roomPt.x;
      wall.y1 = roomPt.y;
    } else {
      wall.x2 = roomPt.x;
      wall.y2 = roomPt.y;
    }
    showHud(`Reshaping ${wall.name || 'custom wall'}`);
    render();
  } else if (drag.kind === 'door') {
    const door = state.doors.find(d => d.id === drag.id);
    if (!door) return;
    const geom = getWallGeometry(door.wall);
    if (!geom) return;
    const proj = projectPointOntoWall(geom, roomPt);
    const half = door.width / 2;
    const center = clamp(proj.s, half, Math.max(half, geom.length - half));
    door.offset = clamp(center - half, 0, Math.max(0, geom.length - door.width));
    showHud(`Door position ${fmtLen(center)} along ${geom.label}`);
    render();
  }
});

document.addEventListener('pointerup', evt => {
  if (drag && drag.captureEl) {
    try {
      drag.captureEl.releasePointerCapture(drag.pointerId ?? evt.pointerId);
    } catch (e) {}
  }
  drag = null;
});

svg.addEventListener('pointerdown', evt => {
  if (!drawWallState || state.mode !== 'custom') return;
  if (evt.target.closest('[data-floor-item-id],[data-wall-item-id],[data-door-id],[data-wall-id]')) return;
  const pt = svgPoint(evt);
  const roomPt = clampPointToRoom(svgPointToRoomMm(pt));
  if (!drawWallState.start) {
    drawWallState.start = roomPt;
    showHud('Select second point for new wall');
  } else {
    const start = drawWallState.start;
    const end = roomPt;
    if (Math.hypot(end.x - start.x, end.y - start.y) > 10) {
      const wall = {
        id: genId('wall'),
        name: `Custom Wall ${state.customWalls.length + 1}`,
        x1: start.x,
        y1: start.y,
        x2: end.x,
        y2: end.y,
        thickness: BASE_WALL_THICKNESS
      };
      state.customWalls.push(wall);
      showHud(`${wall.name} added`);
      setSelectedSurface({ type: 'wall', ref: `custom:${wall.id}` });
    }
    drawWallState = null;
  }
  evt.preventDefault();
  render();
});

roomRect.addEventListener('pointerdown', evt => {
  setSelectedSurface({ type: 'floor' });
  evt.preventDefault();
});

applyBtn.addEventListener('click', () => {
  state.Wmm = Math.max(1000, Number(Winput.value || 0));
  state.Lmm = Math.max(1000, Number(Linput.value || 0));
  state.imperial = imperialChk.checked;
  state.snap = state.imperial ? 150 : Math.max(10, Number(snapInput.value || 100));
  snapInput.value = state.snap;
  recomputeScale();
  clampStateToRoom();
  render();
});

imperialChk.addEventListener('change', () => {
  state.imperial = imperialChk.checked;
  state.snap = state.imperial ? 150 : Math.max(10, Number(snapInput.value || 100));
  snapInput.value = state.snap;
  drawGrid();
  render();
});

snapInput.addEventListener('change', () => {
  if (state.imperial) return;
  state.snap = Math.max(10, Number(snapInput.value || 100));
  drawGrid();
  render();
});

basicAddBtn.addEventListener('click', () => {
  const type = basicAddType.value;
  const def = FLOOR_ITEM_DEFS[type] || FLOOR_ITEM_DEFS.floorBox;
  const item = {
    id: genId('floor'),
    type,
    x: snapValue(state.Wmm / 2),
    y: snapValue(state.Lmm / 2),
    w: def.w,
    l: def.l,
    rotation: 0
  };
  state.floorItems.push(item);
  showHud(`${def.label} added`);
  render();
});

addBtn.addEventListener('click', () => {
  const type = addType.value;
  if (type === 'socket') {
    const wallRef = wallSel.value;
    const geom = getWallGeometry(wallRef);
    if (!geom) {
      showHud('Select a wall before adding sockets');
      return;
    }
    const s = snapValue(geom.length / 2);
    const item = { id: genId('socket'), type: 'socket', wall: wallRef, s, h: snapValue(300) };
    state.wallItems.push(item);
    setSelectedSurface({ type: 'wall', ref: wallRef });
    showHud(`Socket added to ${geom.label}`);
    render();
  } else {
    const def = FLOOR_ITEM_DEFS[type] || FLOOR_ITEM_DEFS.floorBox;
    const item = {
      id: genId('floor'),
      type,
      x: snapValue(state.Wmm / 2),
      y: snapValue(state.Lmm / 2),
      w: def.w,
      l: def.l,
      rotation: 0
    };
    state.floorItems.push(item);
    setSelectedSurface({ type: 'floor' });
    showHud(`${def.label} added`);
    render();
  }
});

addWallBtn.addEventListener('click', () => {
  if (state.mode !== 'custom') {
    showHud('Switch to custom mode to draw walls');
    return;
  }
  drawWallState = { start: null };
  showHud('Click start point for new wall');
});

addDoorBtn.addEventListener('click', () => {
  if (state.mode !== 'custom') {
    showHud('Switch to custom mode to add doors');
    return;
  }
  if (state.selectedSurface?.type !== 'wall') {
    showHud('Select a wall before adding a door');
    return;
  }
  const geom = getWallGeometry(state.selectedSurface.ref);
  if (!geom) {
    showHud('Selected wall is not available');
    return;
  }
  const width = DOOR_DEFAULT_WIDTH;
  const maxOffset = Math.max(0, geom.length - width);
  const door = {
    id: genId('door'),
    wall: geom.ref,
    offset: snapValue(maxOffset / 2),
    width,
    thickness: DOOR_DEFAULT_THICKNESS
  };
  state.doors.push(door);
  setSelectedSurface({ type: 'wall', ref: geom.ref });
  showHud(`Door added to ${geom.label}`);
  render();
});

exportBtn.addEventListener('click', () => {
  const out = {
    units: 'mm',
    room: { W: state.Wmm, L: state.Lmm },
    snap_mm: state.snap,
    imperial_display: state.imperial,
    mode: state.mode,
    floor_items: state.floorItems,
    wall_items: state.wallItems,
    custom_walls: state.customWalls,
    doors: state.doors,
    selected_surface: state.selectedSurface
  };
  const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'room_survey.json';
  a.click();
  URL.revokeObjectURL(url);
});

roomTypeSel.addEventListener('change', () => {
  setMode(roomTypeSel.value);
});

// initialize
setMode('basic');
recomputeScale();
render();
</script>
</body>
</html>