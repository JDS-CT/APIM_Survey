<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Prototype version 1 of the interactive 3D room viewer -->
  <meta charset="utf-8" />
  <title>Interactive 3D Room (Orbit Viewer)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://www.x3dom.org/release/x3dom.css">
  <link rel="stylesheet" href="../shared/styles/glass_light_theme.css" />
  <link rel="stylesheet" href="../shared/styles/glass_dark_theme.css" />
  <script src="https://www.x3dom.org/release/x3dom.js"></script>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      background: var(--room-ui-bg);
      color: var(--room-ui-text);
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 15% 20%, rgba(96, 165, 250, 0.18), transparent 45%),
                  radial-gradient(circle at 85% 10%, rgba(99, 102, 241, 0.22), transparent 52%);
      opacity: 0.75;
      pointer-events: none;
      z-index: -2;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 20px;
      gap: 16px;
      border-bottom: 1px solid var(--room-ui-border);
      background: var(--room-ui-surface);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header .subtitle {
      font-size: 13px;
      color: var(--room-ui-muted-strong);
      margin-top: 2px;
    }
    nav {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .nav-link {
      color: var(--room-ui-link);
      text-decoration: none;
      font-weight: 600;
      padding: 6px 10px;
      border-radius: 6px;
      transition: background 120ms ease, color 120ms ease;
    }
    .nav-link:hover {
      background: rgba(37, 99, 235, 0.12);
    }
    .nav-link.active {
      background: rgba(37, 99, 235, 0.18);
    }
    main {
      display: grid;
      grid-template-columns: minmax(280px, 340px) 1fr;
      gap: 20px;
      padding: 24px;
      min-height: 0;
    }
    @media (max-width: 960px) {
      main {
        grid-template-columns: 1fr;
      }
    }
    aside {
      display: grid;
      gap: 16px;
      align-content: start;
    }
    .panel {
      background: var(--room-ui-surface);
      border-radius: 14px;
      padding: 18px;
      border: 1px solid var(--room-ui-border-soft);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.08);
      display: grid;
      gap: 12px;
    }
    .panel hr {
      border: none;
      border-top: 1px solid var(--room-ui-border-soft);
      margin: 12px -18px;
    }
    label {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      color: var(--room-ui-muted-strong);
    }
    input[type="number"] {
      width: 7em;
      font: inherit;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--room-ui-border);
      background: rgba(255, 255, 255, 0.92);
      color: inherit;
    }
    .file-label {
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      font-weight: 600;
    }
    .file-label input {
      width: 100%;
      font: inherit;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--room-ui-border);
      background: rgba(255, 255, 255, 0.92);
      color: inherit;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .note {
      font-size: 13px;
      color: var(--room-ui-muted);
    }
    .btn {
      appearance: none;
      font: inherit;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--room-ui-button-border);
      background: linear-gradient(180deg, var(--room-ui-button-bg-top), var(--room-ui-button-bg-bottom));
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px var(--room-ui-shadow);
    }
    .btn.secondary {
      border-color: rgba(148, 163, 184, 0.25);
      background: rgba(30, 41, 59, 0.78);
      color: var(--room-ui-link);
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    .viewport {
      background: var(--room-ui-viewport-bg);
      border-radius: 18px;
      border: 1px solid var(--room-ui-border-soft);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.1);
      overflow: hidden;
      display: flex;
      min-height: 0;
    }
    x3d {
      width: 100%;
      height: 100%;
      min-height: 520px;
    }
    .status-line {
      font-size: 13px;
      color: var(--room-ui-muted);
      min-height: 18px;
      transition: color 160ms ease;
    }
    .status-line[data-tone="success"] {
      color: #34d399;
    }
    .status-line[data-tone="warn"] {
      color: #facc15;
    }
    .status-line[data-tone="error"] {
      color: #f87171;
    }
  </style>
</head>
<body data-room-theme="glass-dark">
  <header>
    <div>
      <strong>Interactive 3D Room â€” Orbit Viewer</strong>
      <div class="subtitle">Review walls, doors, and items from the exported survey before committing to the layout.</div>
    </div>
    <nav>
      <a class="nav-link" href="../index.html">Home</a>
      <a class="nav-link" href="../room_survey_min/room_survey_min_v1.html">2D Survey</a>
      <a class="nav-link active" href="interactive_3d_room_v1.html">Orbit Viewer</a>
      <a class="nav-link" href="interactive_3d_room_fps_demo.html">First-Person Demo</a>
    </nav>
  </header>
  <main>
    <aside>
      <div class="panel">
        <div class="row"><strong>Units:</strong> millimeters for inputs; converted to meters in 3D.</div>
        <label>Room Width (X, mm) <input id="Wmm" type="number" min="1000" value="6000" step="100"></label>
        <label>Room Length (Y, mm) <input id="Lmm" type="number" min="1000" value="8000" step="100"></label>
        <div class="note">Height is fixed to 8 ft = 2438.4 mm.</div>
        <hr>
        <label>Triangle X (mm) <input id="Txmm" type="number" min="0" value="3000" step="50"></label>
        <label>Triangle Y (mm) <input id="Tymm" type="number" min="0" value="3000" step="50"></label>
        <div class="row">
          <button class="btn" id="apply">Apply</button>
          <button class="btn" id="home">Home View</button>
        </div>
        <div class="note">Triangle is a flat marker on the floor. (X, Y) maps to (X, Z) in the 3D scene.</div>
        <hr>
        <label class="file-label">Import 2D JSON <input id="import2d" type="file" accept="application/json"></label>
        <div class="note">Load a layout exported from the 2D survey. Dimensions and items are populated automatically.</div>
        <div class="row">
          <button class="btn secondary" id="saveLayout">Save Layout</button>
          <button class="btn secondary" id="loadLayout">Load Saved</button>
        </div>
        <div class="status-line" id="statusLine" role="status" aria-live="polite"></div>
      </div>
    </aside>
    <section class="viewport">
      <x3d id="viewer" showStat="false" showLog="false">
        <Scene>
          <Background skyColor="0.06 0.08 0.14"></Background>
          <NavigationInfo type='"EXAMINE" "ANY"' headlight="true"></NavigationInfo>
          <Viewpoint id="vp" description="Home" position="4 2 4" orientation="0 1 0 0"></Viewpoint>

          <!-- Room wireframe -->
          <Transform id="roomTf">
            <Shape>
              <Appearance><Material emissiveColor="0.1 0.1 0.1"></Material></Appearance>
              <IndexedLineSet id="roomEdges" coordIndex="">
                <Coordinate id="roomCoords" point=""></Coordinate>
              </IndexedLineSet>
            </Shape>
          </Transform>

          <!-- Floor grid (1m spacing, auto-extended around room size) -->
          <Transform id="gridTf">
            <Shape>
              <Appearance><Material emissiveColor="0.85 0.85 0.85"></Material></Appearance>
              <IndexedLineSet id="gridLines" coordIndex=""></IndexedLineSet>
            </Shape>
          </Transform>

          <!-- Triangle marker (flat on floor Y=0) -->
          <Transform id="triTf" translation="0 0 0">
            <Shape>
              <Appearance><Material diffuseColor="0.2 0.5 0.95" transparency="0.2"></Material></Appearance>
              <IndexedFaceSet coordIndex="0 1 2 -1">
                <Coordinate id="triCoords" point="-0.2 0 0  0.2 0 0  0 0 0.3"></Coordinate>
              </IndexedFaceSet>
            </Shape>
          </Transform>

          <!-- Extruded items (populated from 2D layout) -->
          <Transform id="wallsRoot"></Transform>
          <Transform id="doorsRoot"></Transform>
          <Transform id="itemsRoot"></Transform>
        </Scene>
      </x3d>
    </section>
  </main>

  <script>

const mm2m = v => v / 1000.0;
const FT8_MM = 2438.4; // 8 feet
const Hm = mm2m(FT8_MM);

const Wmm = document.getElementById('Wmm');
const Lmm = document.getElementById('Lmm');
const Txmm = document.getElementById('Txmm');
const Tymm = document.getElementById('Tymm');
const applyBtn = document.getElementById('apply');
const homeBtn = document.getElementById('home');
const importInput = document.getElementById('import2d');
const saveBtn = document.getElementById('saveLayout');
const loadBtn = document.getElementById('loadLayout');
const statusLine = document.getElementById('statusLine');

const vp = document.getElementById('vp');
const roomCoords = document.getElementById('roomCoords');
const roomEdges = document.getElementById('roomEdges');
const gridLines = document.getElementById('gridLines');
const triTf = document.getElementById('triTf');
const triCoords = document.getElementById('triCoords');
const wallsRoot = document.getElementById('wallsRoot');
const doorsRoot = document.getElementById('doorsRoot');
const itemsRoot = document.getElementById('itemsRoot');
const viewer = document.getElementById('viewer');

const DEFAULT_WALL_THICKNESS_MM = 200;
const DOOR_DEFAULT_THICKNESS_MM = 80;
const DOOR_HEIGHT_M = 2.1;
const LAYOUT_STORAGE_KEY = 'room-orbit-viewer.latest-layout';
const STATUS_TIMEOUT_MS = 3200;

const FLOOR_ITEM_META = {
  floorBox: { wmm: 600, lmm: 600, color: '0.12 0.53 0.90', height: 0.05 },
  microscope: { wmm: 2200, lmm: 1800, color: '0.55 0.14 0.67', height: 1.6 },
  table: { wmm: 1800, lmm: 900, color: '0.23 0.33 0.68', height: 0.9 },
  pump: { wmm: 1200, lmm: 600, color: '0.93 0.44 0.13', height: 0.6 }
};

const DEFAULT_ROOM_PRESET = () => ({
  room: { W: 6000, L: 8000 },
  floor_items: [
    { type: 'microscope', x: 2200, y: 5200, rotation: 0 },
    { type: 'table', x: 3800, y: 5200, rotation: 0 },
    { type: 'pump', x: 4200, y: 3400, rotation: 0 },
    { type: 'floorBox', x: 3000, y: 3600, rotation: 0 }
  ],
  wall_items: [
    { type: 'socket', wall: 'base:1', s: 1500, h: 300 },
    { type: 'socket', wall: 'base:3', s: 4500, h: 300 }
  ],
  custom_walls: [],
  doors: []
});

const WALL_COLOR = '0.84 0.80 0.76';
const CUSTOM_WALL_COLOR = '0.65 0.50 0.42';
const DOOR_COLOR = '0.29 0.63 0.34';

const layout = {
  room: { Wmm: Number(Wmm.value || 6000), Lmm: Number(Lmm.value || 8000) },
  triangle: { x: Number(Txmm.value || 0), y: Number(Tymm.value || 0) },
  floor_items: [],
  wall_items: [],
  custom_walls: [],
  doors: []
};
let statusTimer = null;

function toNumber(value, fallback = 0) {
  const v = Number(value);
  return Number.isFinite(v) ? v : fallback;
}

function clearChildren(node) {
  while (node.firstChild) node.removeChild(node.firstChild);
}

function showStatus(message, tone = 'info') {
  if (!statusLine) return;
  if (statusTimer) {
    clearTimeout(statusTimer);
    statusTimer = null;
  }
  if (!message) {
    statusLine.textContent = '';
    statusLine.removeAttribute('data-tone');
    return;
  }
  statusLine.textContent = message;
  statusLine.dataset.tone = tone;
  statusTimer = setTimeout(() => {
    statusLine.textContent = '';
    statusLine.removeAttribute('data-tone');
  }, STATUS_TIMEOUT_MS);
}

function persistLayoutLocal(data) {
  try {
    if (window.localStorage) {
      window.localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(data));
    }
  } catch (err) {
    console.warn('Failed to persist layout locally', err);
  }
}

function loadLayoutLocal() {
  try {
    if (!window.localStorage) return null;
    const raw = window.localStorage.getItem(LAYOUT_STORAGE_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch (err) {
    console.warn('Failed to load layout from local storage', err);
    return null;
  }
}

async function saveLayoutRemote(data) {
  try {
    const resp = await fetch('/api/layout', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    if (!resp.ok) throw new Error(await resp.text());
    return true;
  } catch (err) {
    console.warn('Failed to save layout to server', err);
    return false;
  }
}

async function loadLayoutRemote() {
  try {
    const resp = await fetch('/api/layout', {
      method: 'GET',
      headers: { Accept: 'application/json' },
      cache: 'no-store'
    });
    if (!resp.ok) {
      if (resp.status === 404) return null;
      throw new Error(await resp.text());
    }
    const text = await resp.text();
    if (!text) return null;
    const payload = JSON.parse(text);
    if (payload && typeof payload === 'object' && payload.layout !== undefined) {
      return payload.layout;
    }
    if (payload && typeof payload === 'object') {
      return payload;
    }
    return null;
  } catch (err) {
    console.warn('Failed to load layout from server', err);
    return null;
  }
}

function snapshotLayout() {
  const triangle = layout.triangle || { x: 0, y: 0 };
  return {
    room: { W: toNumber(layout.room.Wmm, 6000), L: toNumber(layout.room.Lmm, 8000) },
    triangle: {
      x: toNumber(triangle.x, 0),
      y: toNumber(triangle.y, 0)
    },
    floor_items: (layout.floor_items || []).map(item => {
      const meta = FLOOR_ITEM_META[item.type] || FLOOR_ITEM_META.floorBox;
      return {
        id: item.id,
        type: item.type,
        x: toNumber(item.x, 0),
        y: toNumber(item.y, 0),
        w: toNumber(item.w, meta.wmm),
        l: toNumber(item.l, meta.lmm),
        rotation: toNumber(item.rotation, 0)
      };
    }),
    wall_items: (layout.wall_items || []).map(item => ({
      id: item.id,
      type: item.type,
      wall: item.wall,
      s: toNumber(item.s, 0),
      h: toNumber(item.h, 0)
    })),
    custom_walls: (layout.custom_walls || []).map(wall => ({
      id: wall.id,
      name: wall.name,
      x1: toNumber(wall.x1, 0),
      y1: toNumber(wall.y1, 0),
      x2: toNumber(wall.x2, 0),
      y2: toNumber(wall.y2, 0),
      thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM)
    })),
    doors: (layout.doors || []).map(door => ({
      id: door.id,
      wall: door.wall,
      offset: toNumber(door.offset, 0),
      width: toNumber(door.width, 900),
      thickness: toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM)
    }))
  };
}

async function restorePersistedLayout(options = {}) {
  const { preferRemote = false } = options;
  const order = preferRemote ? ['remote', 'local'] : ['local', 'remote'];
  for (const source of order) {
    if (source === 'local') {
      const local = loadLayoutLocal();
      if (local) return { data: local, source: 'local' };
    } else {
      const remote = await loadLayoutRemote();
      if (remote) return { data: remote, source: 'server' };
    }
  }
  return null;
}

function ensureLayoutIds() {
  layout.custom_walls = (layout.custom_walls || []).map((wall, idx) => ({
    ...wall,
    id: wall.id !== undefined ? String(wall.id) : `cw_${idx}`
  }));
  layout.doors = (layout.doors || []).map((door, idx) => ({
    ...door,
    id: door.id !== undefined ? String(door.id) : `door_${idx}`
  }));
}

function baseWallDefinitions() {
  const W = layout.room.Wmm;
  const L = layout.room.Lmm;
  const t = DEFAULT_WALL_THICKNESS_MM;
  return [
    { ref: 'base:1', label: 'Wall 1 (y=0)', start: { x: 0, y: 0 }, end: { x: W, y: 0 }, thickness: t },
    { ref: 'base:2', label: 'Wall 2 (x=W)', start: { x: W, y: 0 }, end: { x: W, y: L }, thickness: t },
    { ref: 'base:3', label: 'Wall 3 (y=L)', start: { x: W, y: L }, end: { x: 0, y: L }, thickness: t },
    { ref: 'base:4', label: 'Wall 4 (x=0)', start: { x: 0, y: L }, end: { x: 0, y: 0 }, thickness: t }
  ];
}

function enrichWallGeometry(wall) {
  const dx = wall.end.x - wall.start.x;
  const dy = wall.end.y - wall.start.y;
  const length = Math.hypot(dx, dy);
  if (length < 1e-6) return null;
  const tangent = { x: dx / length, y: dy / length };
  const normal = { x: -tangent.y, y: tangent.x };
  return { ...wall, length, tangent, normal };
}

function getCustomWall(ref) {
  const id = ref.split(':')[1];
  return layout.custom_walls.find(w => String(w.id) === id);
}

function getWallGeometry(ref) {
  if (ref === undefined || ref === null) return null;
  let normalized = ref;
  if (typeof normalized === 'number') normalized = `base:${normalized}`;
  normalized = String(normalized);
  if (/^\d$/.test(normalized)) normalized = `base:${normalized}`;
  if (normalized.startsWith('base:')) {
    const wall = baseWallDefinitions().find(w => w.ref === normalized);
    return wall ? enrichWallGeometry(wall) : null;
  }
  if (normalized.startsWith('custom:')) {
    const wall = getCustomWall(normalized);
    if (!wall) return null;
    return enrichWallGeometry({
      ref: normalized,
      label: wall.name || 'Custom Wall',
      start: { x: toNumber(wall.x1, 0), y: toNumber(wall.y1, 0) },
      end: { x: toNumber(wall.x2, 0), y: toNumber(wall.y2, 0) },
      thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM)
    });
  }
  return null;
}

function pointAlongWall(geom, offsetMm) {
  const distance = Math.max(0, Math.min(geom.length, offsetMm));
  return {
    x: geom.start.x + geom.tangent.x * distance,
    y: geom.start.y + geom.tangent.y * distance
  };
}

function buildRoomEdges(Wm, Lm, Hm) {
  const pts = [
    [0,0,0], [Wm,0,0], [Wm,0,Lm], [0,0,Lm],
    [0,Hm,0], [Wm,Hm,0], [Wm,Hm,Lm], [0,Hm,Lm]
  ];
  const pstr = pts.map(p => p.join(' ')).join(' ');
  roomCoords.setAttribute('point', pstr);
  const idx = [
    0,1,-1, 1,2,-1, 2,3,-1, 3,0,-1,
    4,5,-1, 5,6,-1, 6,7,-1, 7,4,-1,
    0,4,-1, 1,5,-1, 2,6,-1, 3,7,-1
  ].join(' ');
  roomEdges.setAttribute('coordIndex', idx);
}

function buildGrid(Wm, Lm) {
  const spanX = Math.max(1, Math.ceil(Wm));
  const spanZ = Math.max(1, Math.ceil(Lm));
  const coords = [];
  const indices = [];
  let idx = 0;
  function addLine(a, b) {
    coords.push(a, b);
    indices.push(idx, idx + 1, -1);
    idx += 2;
  }
  for (let x = 0; x <= spanX; x += 1) addLine([x, 0, 0], [x, 0, spanZ]);
  for (let z = 0; z <= spanZ; z += 1) addLine([0, 0, z], [spanX, 0, z]);
  const coordEl = document.createElement('Coordinate');
  coordEl.setAttribute('point', coords.map(p => p.join(' ')).join(' '));
  while (gridLines.firstChild) gridLines.removeChild(gridLines.firstChild);
  gridLines.appendChild(coordEl);
  gridLines.setAttribute('coordIndex', indices.join(' '));
}

function updateTriangle(xm, zm) {
  triTf.setAttribute('translation', `${xm} 0 ${zm}`);
}

function fitView(Wm, Lm, Hm) {
  const cx = Wm / 2;
  const cy = Hm * 0.8 + Math.max(Wm, Lm) * 0.3;
  const cz = Lm * 1.1;
  vp.setAttribute('position', `${cx} ${cy} ${cz}`);
  vp.setAttribute('orientation', `0 1 0 0`);
}

function createBoxShape(length, height, depth, color, transparency = 0.15) {
  const shape = document.createElement('Shape');
  const app = document.createElement('Appearance');
  const material = document.createElement('Material');
  material.setAttribute('diffuseColor', color);
  material.setAttribute('transparency', transparency);
  app.appendChild(material);
  shape.appendChild(app);
  const box = document.createElement('Box');
  box.setAttribute('size', `${Math.max(length, 0.01)} ${Math.max(height, 0.01)} ${Math.max(depth, 0.01)}`);
  shape.appendChild(box);
  return shape;
}

function renderWalls3d() {
  clearChildren(wallsRoot);
  const Wm = mm2m(layout.room.Wmm);
  const Lm = mm2m(layout.room.Lmm);
  const thickness = mm2m(DEFAULT_WALL_THICKNESS_MM);
  const baseWalls = [
    { length: Wm, thickness, x: Wm / 2, z: thickness / 2, rotation: 0 },
    { length: Wm, thickness, x: Wm / 2, z: Lm - thickness / 2, rotation: 0 },
    { length: Lm, thickness, x: thickness / 2, z: Lm / 2, rotation: Math.PI / 2 },
    { length: Lm, thickness, x: Wm - thickness / 2, z: Lm / 2, rotation: Math.PI / 2 }
  ];
  baseWalls.forEach(w => {
    const tf = document.createElement('Transform');
    tf.setAttribute('translation', `${w.x} ${Hm / 2} ${w.z}`);
    if (w.rotation) tf.setAttribute('rotation', `0 1 0 ${w.rotation}`);
    tf.appendChild(createBoxShape(w.length, Hm, w.thickness, WALL_COLOR, 0.25));
    wallsRoot.appendChild(tf);
  });

  (layout.custom_walls || []).forEach(wall => {
    const geom = getWallGeometry(`custom:${wall.id}`);
    if (!geom) return;
    const center = {
      x: mm2m((geom.start.x + geom.end.x) / 2),
      z: mm2m((geom.start.y + geom.end.y) / 2)
    };
    const length = mm2m(geom.length);
    const thick = mm2m(toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM));
    const angle = Math.atan2(geom.tangent.y, geom.tangent.x);
    const tf = document.createElement('Transform');
    tf.setAttribute('translation', `${center.x} ${Hm / 2} ${center.z}`);
    tf.setAttribute('rotation', `0 1 0 ${angle}`);
    tf.appendChild(createBoxShape(length, Hm, thick, CUSTOM_WALL_COLOR, 0.15));
    wallsRoot.appendChild(tf);
  });
}

function renderDoors3d() {
  clearChildren(doorsRoot);
  (layout.doors || []).forEach(door => {
    const geom = getWallGeometry(door.wall);
    if (!geom) return;
    const offsetStart = pointAlongWall(geom, toNumber(door.offset, 0));
    const offsetEnd = pointAlongWall(geom, toNumber(door.offset, 0) + toNumber(door.width, 900));
    const center = {
      x: mm2m((offsetStart.x + offsetEnd.x) / 2),
      z: mm2m((offsetStart.y + offsetEnd.y) / 2)
    };
    const length = mm2m(Math.min(geom.length, Math.abs(door.width || 900)));
    const thick = mm2m(toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM));
    const angle = Math.atan2(geom.tangent.y, geom.tangent.x);
    const tf = document.createElement('Transform');
    tf.setAttribute('translation', `${center.x} ${DOOR_HEIGHT_M / 2} ${center.z}`);
    tf.setAttribute('rotation', `0 1 0 ${angle}`);
    tf.appendChild(createBoxShape(length, DOOR_HEIGHT_M, thick, DOOR_COLOR, 0.1));
    doorsRoot.appendChild(tf);
  });
}

function renderItems3d() {
  clearChildren(itemsRoot);
  (layout.floor_items || []).forEach(item => {
    const type = item.type || 'floorBox';
    const meta = FLOOR_ITEM_META[type] || FLOOR_ITEM_META.floorBox;
    const w = mm2m(toNumber(item.w, meta.wmm));
    const l = mm2m(toNumber(item.l, meta.lmm));
    const h = meta.height || 0.8;
    const x = mm2m(toNumber(item.x, layout.room.Wmm / 2));
    const z = mm2m(toNumber(item.y, layout.room.Lmm / 2));
    const tf = document.createElement('Transform');
    tf.setAttribute('translation', `${x} ${h / 2} ${z}`);
    const rot = toNumber(item.rotation, 0);
    if (rot) tf.setAttribute('rotation', `0 1 0 ${(rot * Math.PI) / 180}`);
    tf.appendChild(createBoxShape(w, h, l, meta.color, 0.2));
    itemsRoot.appendChild(tf);
  });
}

function renderLayout3d() {
  ensureLayoutIds();
  renderWalls3d();
  renderDoors3d();
  renderItems3d();
}

function normalizeFloorItem(item) {
  const type = item.type || 'floorBox';
  const meta = FLOOR_ITEM_META[type] || FLOOR_ITEM_META.floorBox;
  return {
    ...item,
    id: item.id,
    type,
    x: toNumber(item.x, layout.room.Wmm / 2),
    y: toNumber(item.y, layout.room.Lmm / 2),
    w: toNumber(item.w ?? item.size, meta.wmm),
    l: toNumber(item.l ?? item.size, meta.lmm),
    rotation: toNumber(item.rotation, 0)
  };
}

function normalizeWallItem(item) {
  let wallRef = item.wall;
  if (typeof wallRef === 'number') wallRef = `base:${wallRef}`;
  if (typeof wallRef === 'string' && /^\d$/.test(wallRef)) wallRef = `base:${wallRef}`;
  return {
    ...item,
    wall: wallRef || 'base:1',
    s: toNumber(item.s, 0),
    h: toNumber(item.h, 0)
  };
}

function normalizeCustomWall(wall, idx) {
  return {
    ...wall,
    id: wall.id !== undefined ? String(wall.id) : `cw_${idx}`,
    x1: toNumber(wall.x1, 0),
    y1: toNumber(wall.y1, 0),
    x2: toNumber(wall.x2, 0),
    y2: toNumber(wall.y2, 0),
    thickness: toNumber(wall.thickness, DEFAULT_WALL_THICKNESS_MM),
    name: wall.name
  };
}

function normalizeDoor(door, idx) {
  let wallRef = door.wall;
  if (typeof wallRef === 'number') wallRef = `base:${wallRef}`;
  if (typeof wallRef === 'string' && /^\d$/.test(wallRef)) wallRef = `base:${wallRef}`;
  return {
    ...door,
    id: door.id !== undefined ? String(door.id) : `door_${idx}`,
    wall: wallRef || 'base:1',
    offset: toNumber(door.offset, 0),
    width: toNumber(door.width, 900),
    thickness: toNumber(door.thickness, DOOR_DEFAULT_THICKNESS_MM)
  };
}

function ingestLayout(data) {
  if (data.room) {
    layout.room.Wmm = toNumber(data.room.W, layout.room.Wmm);
    layout.room.Lmm = toNumber(data.room.L, layout.room.Lmm);
    Wmm.value = layout.room.Wmm;
    Lmm.value = layout.room.Lmm;
  }
  if (Array.isArray(data.floor_items)) {
    layout.floor_items = data.floor_items.map(normalizeFloorItem);
  } else if (Array.isArray(data.items)) {
    const floor = data.items.filter(it => it.type !== 'socket').map(normalizeFloorItem);
    const wallItems = data.items.filter(it => it.type === 'socket').map(normalizeWallItem);
    layout.floor_items = floor;
    layout.wall_items = wallItems;
  }
  if (Array.isArray(data.wall_items)) {
    layout.wall_items = data.wall_items.map(normalizeWallItem);
  }
  if (Array.isArray(data.custom_walls)) {
    layout.custom_walls = data.custom_walls.map(normalizeCustomWall);
  }
  if (Array.isArray(data.doors)) {
    layout.doors = data.doors.map(normalizeDoor);
  }
  let triX = layout.triangle ? toNumber(layout.triangle.x, toNumber(Txmm.value, 0)) : toNumber(Txmm.value, 0);
  let triY = layout.triangle ? toNumber(layout.triangle.y, toNumber(Tymm.value, 0)) : toNumber(Tymm.value, 0);
  if (data.triangle) {
    if (data.triangle.x !== undefined) triX = toNumber(data.triangle.x, triX);
    if (data.triangle.y !== undefined) triY = toNumber(data.triangle.y, triY);
  }
  layout.triangle = { x: triX, y: triY };
  Txmm.value = layout.triangle.x;
  Tymm.value = layout.triangle.y;
  ensureLayoutIds();
}

function apply(options = {}) {
  const { fromUser = false, skipStatus = false, skipPersist = false } = options;
  layout.room.Wmm = toNumber(Wmm.value, layout.room.Wmm);
  layout.room.Lmm = toNumber(Lmm.value, layout.room.Lmm);
  layout.triangle = {
    x: toNumber(Txmm.value, layout.triangle ? layout.triangle.x : 0),
    y: toNumber(Tymm.value, layout.triangle ? layout.triangle.y : 0)
  };
  const Wm = mm2m(layout.room.Wmm);
  const Lm = mm2m(layout.room.Lmm);
  const xm = mm2m(layout.triangle.x);
  const zm = mm2m(layout.triangle.y);
  buildRoomEdges(Wm, Lm, Hm);
  buildGrid(Wm, Lm);
  updateTriangle(xm, zm);
  fitView(Wm, Lm, Hm);
  if (viewer && viewer.runtime) {
    if (typeof viewer.runtime.resetExamine === 'function') viewer.runtime.resetExamine();
    if (typeof viewer.runtime.showAll === 'function') viewer.runtime.showAll();
  }
  renderLayout3d();
  if (!skipPersist) {
    persistLayoutLocal(snapshotLayout());
  }
  if (fromUser && !skipStatus) {
    showStatus('Layout updated.', 'success');
  }
}


function applyDefaultPreset() {
  const preset = DEFAULT_ROOM_PRESET();
  layout.room.Wmm = preset.room.W;
  layout.room.Lmm = preset.room.L;
  Wmm.value = layout.room.Wmm;
  Lmm.value = layout.room.Lmm;
  layout.floor_items = (preset.floor_items || []).map(normalizeFloorItem);
  layout.wall_items = (preset.wall_items || []).map(normalizeWallItem);
  layout.custom_walls = (preset.custom_walls || []).map(normalizeCustomWall);
  layout.doors = (preset.doors || []).map(normalizeDoor);
  const presetTriangle = preset.triangle || { x: layout.room.Wmm / 2, y: layout.room.Lmm / 2 };
  layout.triangle = {
    x: toNumber(presetTriangle.x, layout.room.Wmm / 2),
    y: toNumber(presetTriangle.y, layout.room.Lmm / 2)
  };
  Txmm.value = layout.triangle.x;
  Tymm.value = layout.triangle.y;
  ensureLayoutIds();
  apply({ skipStatus: true });
}

applyBtn.addEventListener('click', () => apply({ fromUser: true }));

homeBtn.addEventListener('click', () => {
  fitView(mm2m(layout.room.Wmm), mm2m(layout.room.Lmm), Hm);
  if (viewer && viewer.runtime) {
    if (typeof viewer.runtime.resetExamine === 'function') viewer.runtime.resetExamine();
    if (typeof viewer.runtime.showAll === 'function') viewer.runtime.showAll();
  }
  showStatus('Camera reset to home view.', 'info');
});

importInput.addEventListener('change', evt => {
  const file = evt.target.files && evt.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      ingestLayout(data);
      apply({ skipStatus: true });
      showStatus('Layout imported from file.', 'success');
    } catch (err) {
      console.error('Failed to load layout', err);
      alert('Unable to parse layout file. Please ensure it is a valid export from the 2D survey.');
    }
  };
  reader.readAsText(file);
});

if (saveBtn) {
  saveBtn.addEventListener('click', async () => {
    saveBtn.disabled = true;
    try {
      const snapshot = snapshotLayout();
      persistLayoutLocal(snapshot);
      const remoteOk = await saveLayoutRemote(snapshot);
      showStatus(remoteOk ? 'Layout saved to server.' : 'Saved locally. Server unavailable?', remoteOk ? 'success' : 'warn');
    } finally {
      saveBtn.disabled = false;
    }
  });
}

if (loadBtn) {
  loadBtn.addEventListener('click', async () => {
    loadBtn.disabled = true;
    try {
      const restored = await restorePersistedLayout({ preferRemote: true });
      if (restored) {
        ingestLayout(restored.data);
        apply({ skipStatus: true });
        const tone = restored.source === 'server' ? 'success' : 'info';
        const message = restored.source === 'server'
          ? 'Layout loaded from server.'
          : 'Layout loaded from this browser.';
        showStatus(message, tone);
      } else {
        showStatus('No saved layout found yet.', 'warn');
      }
    } finally {
      loadBtn.disabled = false;
    }
  });
}

async function initializeViewer() {
  const restored = await restorePersistedLayout();
  if (restored) {
    ingestLayout(restored.data);
    apply({ skipStatus: true });
    const tone = restored.source === 'server' ? 'success' : 'info';
    const message = restored.source === 'server'
      ? 'Restored saved layout from server.'
      : 'Restored layout from previous browser session.';
    showStatus(message, tone);
  } else {
    applyDefaultPreset();
    showStatus('Loaded demo preset layout.', 'info');
  }
}

initializeViewer();
  </script>
</body>
</html>
